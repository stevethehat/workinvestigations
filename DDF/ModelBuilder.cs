using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Text;

namespace Api.Util
{
    public class RepoFileInfo
    {
        public string Key;
        public string Value;
    }

    public class ModelBuilder
    {
        public static string DEFAULT_NAMESPACE = "Net.Ibcos.GoldAPIServer.DataLayer.Models";
        public static string WORKSPACE = @"C:\ibcos\Repositorys\gold";
        public static string REPO_PATH = $@"{WORKSPACE}\repository\";
        //public static string OUTPUT_PATH = $@"{WORKSPACE}\api-server\src\DALs\GoldAPIServer.DataLayer\AutoGeneratedModels\";
        public static string OUTPUT_PATH = @"C:\ibcos\Repositorys\gold\api-server\src\DALs\GoldAPIServer.DataLayer\AutoGeneratatedModels\";

        public static List<RepoFileInfo> REPOS = new List<RepoFileInfo>
        {
            /*
            new RepoFileInfo(){ Key = "ACCESS", Value = "ACCREC" },
            new RepoFileInfo(){ Key = "APP_FILE", Value = "APPREC" },
            new RepoFileInfo(){ Key = "AS_FILE", Value = "ASREC" },
            new RepoFileInfo(){ Key = "AT_FILE", Value = "ATREC" },
            new RepoFileInfo(){ Key = "AU_FILE", Value = "AUREC" },
            new RepoFileInfo(){ Key = "RM_FILE", Value = "RMREC" },
            new RepoFileInfo(){ Key = "ROLE_FILE", Value = "ROLEREC" },
            new RepoFileInfo(){ Key = "UT_FILE", Value = "UTREC" },

            new RepoFileInfo(){ Key = "PUN_FILE", Value = "PUNREC" },
            new RepoFileInfo(){ Key = "PUS_FILE", Value = "PUSREC" },
            new RepoFileInfo(){ Key = "CMF_FILE", Value = "CMFREC" },
            new RepoFileInfo(){ Key = "SRP_FILE", Value = "SRPREC" },
            new RepoFileInfo(){ Key = "NMX_FILE", Value = "NMXREC" },
            new RepoFileInfo(){ Key = "OPN_FILE", Value = "OPNREC" },
            new RepoFileInfo(){ Key = "OPC_FILE", Value = "OPCREC" },
            new RepoFileInfo(){ Key = "OPR_FILE", Value = "OPRREC" },
            new RepoFileInfo(){ Key = "CMA_FILE", Value = "CMAREC" },
            new RepoFileInfo(){ Key = "MAF_FILE", Value = "MAFREC" },
            new RepoFileInfo(){ Key = "CON_FILE", Value = "CONREC" },
            new RepoFileInfo(){ Key = "COP_FILE", Value = "COPREC" },
            new RepoFileInfo(){ Key = "WLS_FILE", Value = "WLSREC" },
            new RepoFileInfo(){ Key = "PRE_FILE", Value = "PREREC" },
            new RepoFileInfo(){ Key = "HM_FILE", Value = "HMREC" },
            new RepoFileInfo(){ Key = "VM_FILE", Value = "VMREC" },
            new RepoFileInfo(){ Key = "PMF_FILE", Value = "PMFREC" },
            new RepoFileInfo(){ Key = "VW_FILE", Value = "VWREC" },
            new RepoFileInfo(){ Key = "TIM_FILE", Value = "TIMREC" },
            new RepoFileInfo(){ Key = "ILA_FILE", Value = "ILAREC" },
            new RepoFileInfo(){ Key = "FIT_FILE", Value = "FITREC" },
            */


            new RepoFileInfo(){ Key = "PRI_TAPE", Value = "PRHREC" },
            new RepoFileInfo(){ Key = "PRI_TAPE", Value = "PRIREC" },
            new RepoFileInfo(){ Key = "PRI_TAPE", Value = "PRSREC" }
        };

        /*
        public static Dictionary<string, string> _REPOS = new Dictionary<string, string>
        {
            //System
            { "ACCESS",     "ACCREC" },
            { "APP_FILE",   "APPREC" },
            { "AS_FILE",    "ASREC" },
            { "AT_FILE",    "ATREC" },
            { "AU_FILE",    "AUREC" },
            { "RM_FILE",    "RMREC" },
            { "ROLE_FILE",  "ROLEREC" },
            { "UT_FILE",    "UTREC" },

            //Company
            { "PUN_FILE",   "PUNREC" },
            { "PUS_FILE",   "PUSREC" },
            { "CMF_FILE",   "CMFREC" },
            { "SRP_FILE",   "SRPREC" },
            { "NMX_FILE",   "NMXREC" },
            { "OPN_FILE",   "OPNREC" },
            { "OPC_FILE",   "OPCREC" },
            { "OPR_FILE",   "OPRREC" },
            { "CMA_FILE",   "CMAREC" },
            { "MAF_FILE",   "MAFREC" },
            { "CON_FILE",   "CONREC" },
            { "COP_FILE",   "COPREC" },
            { "WLS_FILE",   "WLSREC" },
            { "PRE_FILE",   "PREREC" },
            { "HM_FILE",    "HMREC"  },
            { "VM_FILE",    "VMREC"  },
            { "PMF_FILE",   "PMFREC" },
            { "VW_FILE",    "VWREC"  },
            { "TIM_FILE",   "TIMREC" },
            { "ILA_FILE",   "ILAREC" },
            { "FIT_FILE",   "FITREC" },

            { "PRI_TAPE",   "PRHREC" },
            { "PRI_TAPE",   "PRIREC" },
            { "PRI_TAPE",   "PRSREC" }

            //Had to manually do these for now, as they cannot currently be auto generated
            //"IST_FILE"
        };
        */
        public void Log(string message)
        {
            //Context.Output["log.txt"].BuildAction = BuildAction.None;
            //Context.Output["log.txt"].WriteLine(message);
        }

        public List<RepoStructor> BuildFromFiles(List<RepoFileInfo> files)
        {
            List<RepoStructor> repos = new List<RepoStructor>();
            foreach (var file in files)
            {
                RepoStructor repo = ReadDDFFile(file);
                repos.Add(repo);
            }
            return repos;
        }

        RepoStructor ReadDDFFile(RepoFileInfo file)
        {
            RepoStructor repo = new RepoStructor();
            string[] lines = File.ReadAllLines($@"{REPO_PATH}file\{file.Key.ToUpper()}.ddf");

            for (int i = 0; i < lines.Length; i++)
            {
                if (lines[i].StartsWith("File"))
                {
                    string[] fileInfo = lines[i].Replace("   ", "~").Split('~');


                    repo.IsamName = fileInfo.Last().Replace("\"", "");

                    Log($"repo.IsamName = {repo.IsamName}");

                    if (repo.IsamName.StartsWith("DVS"))
                        repo.DbSchema = "gold_common";
                    else
                        repo.DbSchema = "companyccc";

                    string[] assignInfo = lines[i].Trim().Replace("   ", "~").Split('~');
                    repo.DbName = file.Value.ToLower();

                    string[] classNameParts = repo.DbName.Split('_');
                    for (int j = 0; j < classNameParts.Length; j++)
                    {
                        classNameParts[j] = Capitalise(classNameParts[j]);
                    }

                    repo.ClassName = string.Join("", classNameParts);
                    Log($"repo.ClassName = {repo.ClassName}");

                }
                else if (i == 2) // File info
                {
                    Log("HERE!!!");
                    var values = lines[i].Trim().Replace("   ", "~").Split('~');
                    foreach (var value in values)
                    {
                        Log(value);
                        switch (value)
                        {
                            case "Compress":
                                repo.Compressed = true;
                                break;

                            case "Static RFA":
                                repo.StaticRFA = true;
                                break;
                        }
                    }
                }
            }
            return repo;
        }


        public void Build()
        {
            Log("Start");
            var repos = BuildFromFiles(ModelBuilder.REPOS);

            // Generate standard shared enums
            GenrateEnum(new RepoEnum { Name = "GoldBool", FirstValue = 0, Step = 1, Values = { "No", "Yes" } }, repos.First(), true);
            GenrateEnum(new RepoEnum { Name = "DocSendBy", FirstValue = 0, Step = 1, Values = { "Post", "FAX", "Email", "Email & Post", "Electronic" } }, repos.First(), true);

            foreach (var repo in repos)
            {
                BuildRepStructor(repo);

                foreach (var enumItem in repo.Enums)
                {
                    GenrateEnum(enumItem, repo);
                }

                StringBuilder output = new StringBuilder();
                GenerateUsing(output);
                output.AppendLine("// produced from ModuleBuilder.cs NOW!!");
                output.AppendLine($"namespace {DEFAULT_NAMESPACE}");
                output.AppendLine("{");
                GenerateClass(output, repo);
                output.AppendLine("}");
                //context.Output[$"{repo.ClassName}.cs"].WriteLine(output.ToString());

                string outputFileName = System.IO.Path.Combine(ModelBuilder.OUTPUT_PATH, $"{repo.ClassName}.cs");
                File.WriteAllText(outputFileName, output.ToString());
            }

        }

        public void GenrateEnum(RepoEnum repoEnum, RepoStructor repoStruct, bool isShared = false)
        {
            var enumName = repoStruct.ClassName + repoEnum.Name;
            if (isShared)
                enumName = repoEnum.Name;

            //var output = Context.Output[$"{enumName}.cs"];
            StringBuilder output = new StringBuilder("");
            output.AppendLine("using System.ComponentModel;");
            Log($"// i have changed this.. and we are generating emum {enumName}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            output.AppendLine($"namespace {DEFAULT_NAMESPACE}");
            output.AppendLine("{");
            output.AppendLine("    /// <summary>");
            output.AppendLine($"    /// {repoEnum.Name}");
            output.AppendLine("    /// </summary>");
            output.AppendLine($"    public enum {enumName}");
            output.AppendLine("    {");

            int postion = repoEnum.FirstValue;
            foreach (string enumValue in repoEnum.Values)
            {
                string name = MakeCodeFriendlyName(enumValue);

                output.AppendLine("        /// <summary>");
                output.AppendLine($"        /// '{name}' <= {enumValue}");
                output.AppendLine("        /// </summary>");
                output.AppendLine($"        [Description(\"{enumValue}\")]");
                output.AppendLine($"        {name} = {postion},");
                output.AppendLine("");

                postion = postion + repoEnum.Step;
            }

            output.AppendLine("    }");
            output.AppendLine("}");

            File.WriteAllText(System.IO.Path.Combine(ModelBuilder.OUTPUT_PATH, $"{enumName}.cs"), output.ToString());
            /// save file here
        }


        public RepoStructor BuildRepStructor(RepoStructor repoStructor)
        {
            int totalSize = 1;
            bool shouldBePK = true;

            //Read file
            string[] lines = File.ReadAllLines($@"{REPO_PATH}structure\{repoStructor.DbName.ToUpper()}.DDF");
            Log($@"BuildRepStructor from {REPO_PATH}structure\{repoStructor.DbName.ToUpper()}.DDF");

            //map it to an object
            for (int i = 0; i < lines.Length; i++)
            {
                if (lines[i].StartsWith("Structure")) // Handle structures
                {
                    string[] structItem = lines[i].Split(' ');
                    if (structItem.Length > 2)
                    {
                        repoStructor.DbName = structItem[1].ToLower();
                        //repoStructor.ClassName = Capitalise(repoStructor.DbName);
                    }

                    if (lines[i + 1].TrimStart().StartsWith("Description"))
                    {
                        repoStructor.Description = GetDescription(lines[i + 1]);
                        i++;
                    }
                    Log($"STRUCTURE: '{repoStructor.DbName}' ({repoStructor.Description})");
                }
                else if (lines[i].StartsWith("Group"))
                {
                    // We have 2 forms of Group syntax to handle:
                    // Group CMF_PSAL_HIRE   Template TBASENUMERIC   Size 24   Report Noview
                    // Group VM_MD_GROUP   Reference WG_MD_GROUP   Type ALPHA
                    //
                    string groupLine = lines[i];
                    Log($"ISAM: '{repoStructor.DbName}'");
                    Log($"LINE: '{groupLine}'");
                    RepoField groupField = new RepoField();
                    string pattern = @"^Group\s+(?<Name>\w*)\s*(?<Type>Reference|Template)\s*(?<Ref>\w*)\s*(?:Size\s*(?<Size>\d{1,}))?";

                    Match match = Regex.Match(groupLine, pattern, RegexOptions.Singleline);
                    GroupCollection groups = match.Groups;

                    string name = groups["Name"].Value;
                    string type = groups["Type"].Value;
                    string reference = groups["Ref"].Value;
                    int size = 0;

                    int.TryParse(groups["Size"].Value, out size);

                    groupField.Name = GetPropertyName(repoStructor.DbName, name);
                    groupField.ColumnName = name.ToLower();
                    groupField.Ignored = true;
                    groupField.Type = typeof(Byte[]);
                    groupField.Start = totalSize;

                    if ("Reference" == type)
                    {
                        RepoStructor groupRepo = new RepoStructor()
                        {
                            DbName = reference
                        };

                        groupRepo = BuildRepStructor(groupRepo);

                        groupField.Size = 0;
                        foreach (RepoField field in groupRepo.Fields)
                        {
                            if (!field.IsOverlay)
                            {
                                groupField.Size += field.Size;
                            }
                        }

                        Log($"{repoStructor.DbName} Group: '{groupField.Name}' is '{groupField.Size}' bytes");

                        totalSize += groupField.Size;
                        repoStructor.TotalSize = totalSize;
                        repoStructor.Fields.Add(groupField);
                    }
                    else if ("Template" == type)
                    {
                        groupField = GetTemplate(reference, groupField, repoStructor, totalSize);

                        if (size != 0)
                        {
                            groupField.Size = size;
                            totalSize += size;
                        }
                        else
                        {
                            totalSize += groupField.Size;
                        }

                        repoStructor.TotalSize = totalSize;

                        repoStructor.Fields.Add(groupField);
                    }
                    else
                    {
                        Log($"Unknown Group type: '{groupLine}'");
                    }
                }
                else if (lines[i].StartsWith("Field")) // Handle fields
                {
                    RepoField field = new RepoField();
                    for (int fieldIndex = i; fieldIndex < lines.Length; fieldIndex++) // Hoping that no field is bigger than 20 rows
                    {
                        string fieldLine = lines[fieldIndex].Trim();
                        if (string.IsNullOrEmpty(fieldLine))
                        {
                            i = fieldIndex;
                            break;
                        }

                        //Handle lines that wrap on to multiple lines.
                        if (fieldLine.EndsWith(","))
                        {
                            StringBuilder fieldLinesBuilder = new StringBuilder();

                            for (int lineNumber = fieldIndex; lineNumber < lines.Length; lineNumber++)
                            {
                                string indexLine = lines[lineNumber].Trim();
                                fieldLinesBuilder.Append(indexLine);
                                if (!indexLine.EndsWith(","))
                                {
                                    fieldIndex = lineNumber;
                                    break;
                                }
                            }

                            string[] fieldItem = fieldLinesBuilder.ToString().Replace("   ", "~").Split('~');

                            Log("\n\nCalling BuildField 2");
                            BuildField(fieldItem, field, repoStructor, totalSize);
                        }
                        else
                        {
                            string[] fieldItem = fieldLine.Replace("   ", "~").Split('~');

                            Log("\n\nCalling BuildField 3");
                            BuildField(fieldItem, field, repoStructor, totalSize);
                        }
                    }

                    //Overlay shouldn't increase the size of the record
                    if (false == field.IsOverlay)
                    {
                        if (field.Dimensions > 0)
                        {
                            totalSize += (field.Size * (field.Dimensions * field.SubDimensions));
                        }
                        else
                        {
                            totalSize += field.Size;
                        }
                        repoStructor.TotalSize = totalSize;
                    }

                    // Spare space so ignore
                    if (field.Name == "Spare")
                    {
                        field.Ignored = true;
                    }

                    repoStructor.Fields.Add(field);
                }
                else if (lines[i].StartsWith("Key"))
                {
                    RepoKey repoKey = new RepoKey();

                    for (int segmentIndex = i; segmentIndex < i + 20; segmentIndex++)
                    {
                        if (string.IsNullOrEmpty(lines[segmentIndex].Trim())) // Find a blank line means end of key data so move on
                            break;

                        string[] keyItems = lines[segmentIndex].Trim().Replace("   ", "~").Split('~');
                        bool isSegementField = false;

                        foreach (var keyItem in keyItems)
                        {
                            if (keyItem.StartsWith("Key"))
                                repoKey.Name = keyItem.Substring(4);
                            else if (keyItem.StartsWith("Krf"))
                                repoKey.Index = int.Parse(keyItem.Substring(4));
                            else if (keyItem == "Dups YES")
                                repoKey.Duplicates = true;
                            else if (keyItem == "Order ASCENDING")
                                repoKey.IsAccending = true;
                            else if (keyItem == "Modifiable YES")
                                repoKey.Modifiable = true;
                            else if (keyItem == "Segment FIELD")
                                isSegementField = true;
                            else if (isSegementField)
                            {
                                var lowerCaseKeyItem = keyItem.ToLower();
                                Log($"{lowerCaseKeyItem} is segment");
                                repoKey.KeyColumns.Add(lowerCaseKeyItem);
                                if (shouldBePK)
                                {
                                    var field = repoStructor.Fields.FirstOrDefault(x => x.ColumnName == lowerCaseKeyItem);
                                    if (field != null)
                                        field.IsKey = true;
                                }
                            }
                        }
                    }

                    shouldBePK = false;
                    repoStructor.Keys.Add(repoKey);
                    Log($"{repoKey.Name} Has Dups: {repoKey.Duplicates} IsAccending: {repoKey.IsAccending}");
                }
            }

            //Total size initialised to +1 at start to calculate correct ISAM offsets (1 based),
            // however actual length is one less than that.
            repoStructor.TotalSize -= 1;

            return repoStructor;
        }

        public RepoField BuildField(string[] fieldItems, RepoField repoField, RepoStructor repoStructor, int currentSize)
        {

            Log($"BUILD FIELD JOINED {fieldItems.ToString()}");
            fieldItems.ToList().ForEach(i => Log($"fi={i}"));
            foreach (var unTrimmedfieldItem in fieldItems)
            {
                var fieldItem = unTrimmedfieldItem.TrimStart();
                Log($"field item = {fieldItem}");
                if (fieldItem.StartsWith("Field"))
                {
                    Match match = Regex.Match(fieldItem, @"^Field\s*(?<name>\w*)\s*");
                    var name = match.Groups["name"].Value;

                    repoField.ColumnName = name.ToLower();
                    repoField.Name = GetPropertyName(repoStructor.DbName, name);
                    Log($"Name = {repoField.Name}");
                }
                else if (fieldItem.StartsWith("Template") || fieldItem.StartsWith("Parent"))
                {
                    string templateName = string.Empty;
                    if (fieldItem.StartsWith("Template"))
                    {
                        templateName = fieldItem.Substring(9);
                    }
                    else
                    {
                        templateName = fieldItem.Substring(7);
                    }

                    if (templateName == "UUID")
                    {
                        repoField.Type = typeof(Guid);
                        repoField.Size = 36;
                    }
                    else if (templateName == "YES_NO" || templateName == "YES_NO_PRT" || templateName == "YES_NO_ALW" || templateName == "YES_NO_ALW_SHRT")
                    {
                        repoField.EnumName = "GoldBool";
                        repoField.Size = 1;
                    }
                    else if (templateName == "DOC_SEND_BY")
                    {
                        repoField.EnumName = "DocSendBy";
                        repoField.Size = 1;
                    }
                    else if (templateName == "CURRENCY_ARRAY" || templateName == "CURRENCY" || templateName == "PRICE" || templateName == "TBASECURRENCY" || templateName == "CURRENCY_BC" || templateName == "TBASE_UPLIFT")
                    {
                        repoField = GetTemplate(templateName, repoField, repoStructor, currentSize);
                        repoField.Precision = 2;
                    }
                    else if (templateName == "M_DATETIME")
                    {
                        repoField = GetTemplate(templateName, repoField, repoStructor, currentSize);
                        repoField.Type = typeof(DateTime);
                        repoField.IsNullable = true;
                    }
                    else
                    {
                        repoField = GetTemplate(templateName, repoField, repoStructor, currentSize);
                    }
                }
                else if (fieldItem.StartsWith("Selection List") && repoField.ColumnName != "vmpsys") // @todo we shouldn't do this
                {
                    RepoEnum repoEnum = new RepoEnum();

                    // We need to extract the numbers and the enumValues from the string formatted like below.
                    //"Selection List 1 2 0  Entries {enum values}"
                    string entities = string.Join("", fieldItems).Substring(fieldItem.IndexOf("Entries") + 8);
                    int enumStartIndex = 0;
                    int enumStep = 1;

                    repoField.EnumName = $"{repoField.Name}Enum";
                    repoEnum.Name = repoField.EnumName;
                    repoEnum.FirstValue = enumStartIndex;
                    repoEnum.Step = enumStep;

                    string[] entityItems = entities.Split(',');
                    foreach (var entity in entityItems)
                    {
                        var enumName = entity.Replace("\"", "").Trim();

                        Log($"Enum for {repoField.EnumName} = {enumName}");
                        repoEnum.Values.Add(enumName);
                    }

                    repoStructor.Enums.Add(repoEnum);

                    Log($"We have an enum {repoField.EnumName} and enums real name {repoEnum.Name}");
                }
                else if (fieldItem.StartsWith("Enumerated"))
                {
                    var repoEnum = repoStructor.Enums.LastOrDefault();
                    if (repoEnum != null)
                    {
                        var enumValues = fieldItem.Substring(11, fieldItem.Length - 11).Split(' ');
                        if (enumValues.Length > 2)
                        {
                            if (int.TryParse(enumValues[1], out int first))
                            {
                                repoEnum.FirstValue = first;
                                Log($"Updating {repoEnum.Name} with first value {first}");
                            }

                            if (int.TryParse(enumValues[2], out int step))
                            {
                                repoEnum.Step = step;
                                //Log($"Updating {repoEnum.Name} with step value {step}");
                            }
                        }
                    }
                }
                else if (fieldItem.StartsWith("Type"))
                {
                    string type = fieldItem.Substring(5);
                    switch (type)
                    {
                        case "ALPHA":
                            repoField.Type = typeof(string);
                            break;

                        case "DECIMAL":
                            repoField.IsNullable = true;
                            repoField.Type = typeof(decimal);
                            break;

                        case "INTEGER":
                            repoField.Type = typeof(int);
                            break;

                        case "TIME":
                            repoField.Type = typeof(TimeSpan);
                            break;

                        case "DATE":
                            repoField.IsNullable = true;
                            repoField.Type = typeof(DateTime);
                            break;

                        default:
                            repoField.Type = typeof(string);
                            break;
                    }
                }
                else if (fieldItem.StartsWith("Size"))
                {
                    var size = fieldItem.Substring(5);
                    if (int.TryParse(size, out int value))
                    {
                        repoField.Size = value;
                    }
                }
                else if (fieldItem.StartsWith("Dimension"))
                {
                    var dimension = fieldItem.Substring(10);
                    if (dimension.Contains(":"))
                    {
                        var dimensionArray = dimension.Split(':');
                        repoField.Ignored = true; // Currently the dibol class template engine ignores these dimensional arrays
                        if (int.TryParse(dimensionArray[0], out int dimensions))
                        {
                            repoField.Dimensions = dimensions;
                        }

                        if (int.TryParse(dimensionArray[1], out int subDimensions))
                        {
                            repoField.SubDimensions = subDimensions;
                        }
                    }
                    else
                    {
                        if (int.TryParse(dimension, out int dimensions))
                        {
                            repoField.Dimensions = dimensions;
                            repoField.SubDimensions = 1;
                        }
                    }
                }
                else if (fieldItem.StartsWith("Overlay"))
                {
                    repoField.IsOverlay = true;
                    Log($"Name = {repoField.Name} is an overlay");
                }
                //REMOVED FOR NOW, as the only fields that can use precision are currency, and non of those are marked with precision
                //else if (fieldItem.StartsWith("Precision"))
                //{
                //    repoField.Type = typeof(decimal);

                //    var precision = fieldItem.Substring(10);
                //    if (int.TryParse(precision, out int value))
                //    {
                //        repoField.Precision = value;
                //    }
                //}
                else if (fieldItem.StartsWith("Description"))
                {
                    repoField.Description = fieldItem.Substring(12).Replace("\"", "");
                    Log($"WE HAVE A DESCRIPTION '{fieldItem}'");
                }
            }
            repoField.Start = currentSize;

            return repoField;
        }



        public void GenerateClass(StringBuilder context, RepoStructor structor)
        {
            context.AppendLine("    /// <summary>");
            context.AppendLine($"    /// {structor.Description}");
            context.AppendLine("    /// </summary>");
            context.AppendLine($"    [Table(\"{structor.DbName}\", Schema =\"{structor.DbSchema}\")]");
            context.AppendLine($"    [Isam(\"{structor.IsamName}\", Compressed={structor.Compressed.ToString().ToLower()}, StaticRFA={structor.StaticRFA.ToString().ToLower()}, Length={structor.TotalSize})]");
            GenerateKeys(context, structor);
            context.AppendLine($"    public partial class {structor.ClassName} : GoldModel");
            context.AppendLine("    {");

            int index = 1;
            Log($"Generating class {structor.ClassName} with {structor.Fields.Count} properties");
            int size = 0;

            foreach (var propItem in structor.Fields)
            {
                //Multi-dimension fields are not currently being sync'd to MySQL so we're just going to
                // put them as a single block for now.
                if (propItem.SubDimensions > 1)
                {
                    propItem.Size = (propItem.SubDimensions * propItem.Dimensions) * propItem.Size;
                    GenerateProperty(context, propItem, structor, index++);
                }
                //Single dimension fields are sync'd in the form base_name_N
                else if (propItem.Dimensions > 1)
                {
                    Int32 baseStart = propItem.Start;
                    for (var i = 1; i <= propItem.Dimensions; i++)
                    {
                        propItem.Start = baseStart + ((i - 1) * propItem.Size);
                        GenerateProperty(context, propItem, structor, index++, $"_{i}");
                    }
                }
                else
                {
                    GenerateProperty(context, propItem, structor, index++);
                }
            }

            context.AppendLine("    }");
        }

        public void GenerateProperty(StringBuilder context, RepoField propertyItem, RepoStructor repoStruct, int index, string nameExtension = "")
        {
            if (propertyItem.Name != null &&
               (propertyItem.Type != null || !string.IsNullOrEmpty(propertyItem.EnumName)) &&
               !propertyItem.IsOverlay)
            {
                context.AppendLine("        /// <summary>");
                context.AppendLine($"        /// {propertyItem.Description}");
                context.AppendLine("        /// </summary>");

                if (propertyItem.IsKey)
                    context.AppendLine("        [Key]");

                if (propertyItem.Ignored)
                    context.AppendLine("        [NotMapped]");

                context.AppendLine($"        [IsamField({propertyItem.Start}, {propertyItem.Size})]");
                context.AppendLine($"        [Column(\"{propertyItem.ColumnName}{nameExtension}\",Order = {index})]");
                if (!string.IsNullOrEmpty(propertyItem.EnumName))
                {
                    int enumStart = 1;
                    int enumStep = 1;
                    Log($"Looking for {propertyItem.EnumName}");
                    var foundEnum = repoStruct.Enums.Where(x => x.Name == propertyItem.EnumName);

                    var enumType = "int";
                    if (foundEnum.Any())
                    {
                        RepoEnum @enum = foundEnum.First();
                        enumType = $"{repoStruct.ClassName}{propertyItem.EnumName}";
                        enumStart = @enum.FirstValue;
                        enumStep = @enum.Step;
                    }

                    if (propertyItem.EnumName == "GoldBool" || propertyItem.EnumName == "DocSendBy")
                    {
                        enumType = $"{propertyItem.EnumName}";
                    }
                    context.AppendLine($"        [Enum(typeof({enumType}), Start = {enumStart}, Step = {enumStep})]");
                    context.AppendLine($"        public string {propertyItem.Name}{nameExtension} {{ get; set; }}");
                }
                else
                {
                    string nullableVal = "";
                    if (propertyItem.IsNullable && typeof(string) != propertyItem.Type)
                    {
                        nullableVal = "?";
                    }
                    if (typeof(decimal) == propertyItem.Type && propertyItem.Precision > 0)
                    {
                        context.AppendLine($"        [Precision({propertyItem.Precision})]");
                    }
                    context.AppendLine($"        public {propertyItem.Type.Name}{nullableVal} {propertyItem.Name}{nameExtension} {{ get; set; }}");
                }
                context.AppendLine("");
            }
        }


        public void GenerateUsing(StringBuilder context)
        {
            context.AppendLine("using System;");
            context.AppendLine("using System.ComponentModel.DataAnnotations;");
            context.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
            context.AppendLine("using Net.Ibcos.GoldAPIServer.DataLayer;");
            context.AppendLine("");

            context.AppendLine("// produced from ModuleBuilder.cs");
        }

        public void GenerateKeys(StringBuilder context, RepoStructor structor)
        {
            foreach (var key in structor.Keys)
            {
                List<int> StartPositions = new List<int>();
                List<int> Lengths = new List<int>();

                foreach (var columnField in key.KeyColumns)
                {
                    var field = structor.Fields.FirstOrDefault(x => x.ColumnName == columnField);
                    if (field != null)
                    {
                        StartPositions.Add(field.Start);
                        Lengths.Add(field.Size);
                    }
                }

                context.Append($"    [IsamKey(\"{key.Name}\"");

                if (StartPositions.Any())
                    context.Append($", Start=\"{string.Join(":", StartPositions)}\"");

                if (Lengths.Any())
                    context.Append($", Length=\"{string.Join(":", Lengths)}\"");

                if (key.Duplicates)
                    context.Append($", Duplicates=true");

                if (key.IsAccending)
                    context.Append($", IsAscending=true");

                if (key.Modifiable)
                    context.Append($", Modifiable=true");

                context.Append($", Index={key.Index}");

                context.AppendLine(")]");
            }
        }

        public RepoField GetTemplate(string templateName, RepoField repoField, RepoStructor repoStructor, int currentPostion)
        {
            var lines = File.ReadAllLines($@"{REPO_PATH}template\{templateName}.DDF");

            Log($"TEMPLATE FIELD ITEMS = '{lines[0]}'");

            var fieldItems = lines[0].Replace("   ", "~").Split('~').ToList().Skip(1).ToArray(); // Do not take the first item as it has the template in it and creates in infinate loop

            Log("\n\nCalling BuildField 1");
            return BuildField(fieldItems, repoField, repoStructor, currentPostion);
        }

        public String GetDescription(string line)
        {
            return line.Substring(15).Replace("\"", "").Trim();
        }

        public String GetPropertyName(string recName, string fieldName)
        {
            string prefix = recName.ToLower().Replace("rec", "");

            if (prefix != recName)
            {
                if(prefix.Length <= fieldName.Length)
                {
                    fieldName = fieldName.ToLower().Substring(prefix.Length);
                } else
                {
                    fieldName = fieldName.ToLower();
                }
            }

            var words = fieldName.ToLower().Split('_');

            for (int i = 0; i < words.Length; i++)
            {
                words[i] = Capitalise(words[i]);
            }
            var propName = String.Join("", words);
            return propName;
        }

        string Capitalise(string input)
        {
            if (String.IsNullOrEmpty(input))
                return "";
            else
                return input.First().ToString().ToUpper() + input.Substring(1);
        }

        string MakeCodeFriendlyName(string name)
        {
            name = name.Trim();
            name = name.Replace("&", "And");
            name = name.Replace("1", "One");
            name = name.Replace("2", "Two");
            name = name.Replace("3", "Three");
            name = name.Replace("4", "Four");
            name = name.Replace("5", "Five");

            Regex regex = new Regex(@"[^a-zA-Z ]");
            name = regex.Replace(name, "");
            //name = name.Replace(".", "");
            //name = name.Replace("+", "");
            //name = name.Replace("-", "");
            //name = name.Replace("\\", "");
            //name = name.Replace("/", "");
            //name = name.Replace("'", "");
            //name = name.Replace("{", "");
            //name = name.Replace("}", "");

            if (string.IsNullOrEmpty(name))
            {
                name = "Undefined";
            }

            var words = name.ToLower().Split(' ');
            StringBuilder builder = new StringBuilder();
            foreach (var word in words)
                builder.Append(Capitalise(word));

            name = builder.ToString();
            name = name.Replace("*", "");
            return name;
        }
    }

    public class RepoField
    {
        public string Name { get; set; }

        public string ColumnName { get; set; }

        public string Description { get; set; }

        public Type Type { get; set; }

        public int Size { get; set; }

        public bool IsOverlay { get; set; }

        public int Dimensions { get; set; }

        public int SubDimensions { get; set; }

        public string EnumName { get; set; }

        public bool IsKey { get; set; }

        public bool Ignored { get; set; }

        public int Start { get; set; }

        public bool IsNullable { get; set; }

        public int Precision { get; set; }
    }

    public class RepoEnum
    {
        public string Name { get; set; }
        public List<string> Values { get; set; }

        public int FirstValue { get; set; }
        public int Step { get; set; }

        public RepoEnum()
        {
            Values = new List<string>();
        }
    }

    public class RepoKey
    {
        public string Name { get; set; }
        public bool Duplicates { get; set; }

        public bool IsAccending { get; set; }

        public bool Modifiable { get; set; }

        public int Index { get; set; }
        public List<string> KeyColumns { get; set; }

        public RepoKey()
        {
            KeyColumns = new List<string>();
        }
    }

    public class RepoStructor
    {
        public string DbName { get; set; }

        public string ClassName { get; set; }

        public string IsamName { get; set; }

        public string DbSchema { get; set; }

        public string Description { get; set; }

        public List<RepoField> Fields { get; set; }

        public List<RepoEnum> Enums { get; set; }

        public List<RepoKey> Keys { get; set; }

        public bool Compressed { get; set; }

        public bool TByte { get; set; }

        public bool StaticRFA { get; set; }

        public RecordTypeEnum RecordType { get; set; }

        public PageSizeOptions PageSize { get; set; }

        public int TotalSize { get; set; }

        public RepoStructor()
        {
            Fields = new List<RepoField>();
            Enums = new List<RepoEnum>();
            Keys = new List<RepoKey>();
        }

        public enum RecordTypeEnum
        {
            Fixed,
            Multiple,
            Variable
        }

        public enum PageSizeOptions
        {
            B512,
            B1024,
            B2048,
            B4096,
            B8192
        }
    }
}