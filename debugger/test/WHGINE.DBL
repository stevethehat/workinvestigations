; NOTE - WHGINE.KEEP - THIS HAS SOME STATUS CODE PROCESSING ALTHOUGH
; HAVE DISCUSSED WITH MR AND T LOOKS LIKE WE HAVE AGREED TO SIMPLY DISPLAY
; AN IBC MESSAGE IF LOMBARD TYPE - STILL NEED TO AGREE ON A STATUS FIELD FOR
; THIS AND A WAY OF INDICATING IT IS SUCH.  ALTHOUGH, IF A FIELD SPECIFICALLY FOR
; THIS THEN THE NON BLANKNESS OF IT SHOULD DO
;;**********************************************************************
;;
;; Title: WHGINE.DBL
;;
;; Type:  Program

;; Description: Wholegoods Invoice and Self Bill
;;
;; Author: Jim Cobb, Ibcos Computers
;;
;; Copyright 2013 Constellation Software Inc. All rights reserved.
;;
;;**********************************************************************
.include 'DEF:IMPORT.DEF'
.include 'DEF:AUDIT_TYPES.DEF'

.define D_DEFINES_ONLY          ;not in a proc section so only want the defines out of tools.def
.include 'WND:tools.def'
.undefine D_DEFINES_ONLY        ;undefine so OPSCOM includes the full 'tools.def' later
.include 'DEF:ADSDTK.DEF'
.include 'TXT:SUB.TXT'

; FILE CHANNELS
.define FILE_NUM,	35
; update
.define SMF_FILE,	1
.define VM_FILE,	2
.define HM_FILE,	3
.define VI_FILE,	4
.define VJ_FILE,	5
.define VB_FILE,	6
.define PDF_FILE,	7
.define CAT_FILE,	8
.define VD_FILE,	9
; read only
.define VK_FILE,	10
.define VW_FILE,	11
.define HW_FILE,	12
.define VGF_FILE,	13
.define PRE_FILE,	14
.define IVT_FILE,	15
.define CMF_FILE,	16
.define PMF_FILE,	17
.define NMF_FILE,	18
.define DMF_FILE,	19
.define SRP_FILE,	20
.define IVH_FILE,	21
.define CTF_FILE,	22
.define CTH_FILE,	23
.define VA_FILE,	24
.define VQ_FILE,	25
.define ACC_FILE,	26
.define VS_FILE,	27
.define PMH_FILE,	28
.define PML_FILE,	29
.define PMD_FILE,	30
.define PMG_FILE,	31
.define PMC_FILE,	32
.define PMM_FILE,	33
.define IHH_FILE,	34
.define WQL_FILE,	35


;------------------------------------------------------------------------------

; FUNCTION KEYS DEFINES
.define MAX_FKEYS,		29

.define IAD_FKEYS,		1
.define INP_FKEYS,		2
.define LST_FKEYS,		3
.define ADD_FKEYS,		4
.define ADV_FKEYS,		5
.define PRTLST_FKEYS,		6
.define PRTINP_FKEYS,		7
.define SEQ_FKEYS,		8
.define CMNT_FKEYS,		9
.define CMNT_INP_FKEYS,		10
.define WGD_FKEYS,		11
.define WGD_INP_FKEYS,		12
.define BLNK_FKEYS,		13
.define INV_TAB_FKEYS,		14
.define NSTK_FKEYS,		15
.define NSTK_INP_FKEYS,		16
.define TRD_FKEYS,		17
.define TRD_INP_FKEYS,		18
.define INP_ATD_FKEYS,		19
.define HDR_FKEYS,		20
.define INV_CMNT_FKEYS,		21
.define W_TRK_FKEY,		22
.define OIP_FKEYS,		23
.define FIN_FKEYS,		24
.define FIN_INP_FKEYS,		25
.define DOC_FKEYS,		26
.define STG_INP_FKEYS,		27
.define STG_LST_FKEYS,		28
.define SMS_FKEYS,		29

;------------------------------------------------------------------------------

.define WR_SETUP,		1
.define WR_GET_ADV,		2
.define WR_HEADER,		3
.define WR_SHOW_DETS,		4
.define WR_DELETE_ADV,		5

.define WR_QUIT_RTN,		99

.define D_HDR_TAB_ID,		1
.define D_SEQ_TAB_ID,		2
.define D_WGD_TAB_ID,		3
.define D_NSTK_TAB_ID,		4
.define D_PART_TAB_ID,		5
.define D_CMNT_TAB_ID,		7
.define D_TRD_TAB_ID,		8
.define D_INV_CMNT_TAB_ID,	9
.define D_DOC_TAB_ID,		10
.define D_SMS_TAB_ID,		11
.define D_STG_PAY_TAB_ID,	12
.define D_OIP_TAB_ID,		13
.define D_FIN_TAB_ID,		14
.define D_MAX_TABS,         14          ; look for this if changing no
                                        ; as there is some manipulation for
                                        ; plan maintenance invoices where
                                        ; ts_process is done
                                        ; it now uses array of tab_number
                                        ; for next tab in proc seq

.define INP_STOCK		,1
.define INP_ORDER		,2
.define AMD_STOCK		,3
.define DEL_STOCK		,4
.define DEL_ORDER		,5

; Security Access
.define D_ACCESS_25,		25
.define D_ACCESS_26,		26
.define D_ACCESS_27,		27
.define D_ACCESS_28,		28
.define D_ACCESS_29,		29
.define D_ACCESS_30,		30
.define D_ACCESS_31,		31

.define HRT_LIVE_TYPE,		0

.define NON_KIT_LINE,		1
.define KIT_LINE,		2
.define KIT_HEADER,		3

.ifdef D_GUI
	.define TAB_HEIGHT,		15
.else
	.define TAB_HEIGHT,		14
.endc
;-------------------------------------------------------------------------------
;               global structures for use in defineing global common data
structure whgine_pass_chn_data_str
	chn,                [FILE_NUM]i4
	lst_cntrl,          a D_LL_CTLSIZE
	h_stok,             a8
	current_item_type,  a2              ; when list processing vj,vb,vd
	f_vj_eof,           i4              ; in advice list 1=reached end of vj file
	f_some_recs,        i4
	h_prog_code,        d2
	h_supacc,           d4
	line_mode,          i4
endstructure

structure whgine_pass_gen_data_str
	vi_currency,     a3
	vi_exch_rate,    d11.6
	h_vatable,       d1
	h_vatreg,        a16
	h_vat_code,      VAT_CODE
	h_status,        d1
	h_ivcr,          d1
	h_cr_sett_yn,    a1
	adv_mode,        i4
	inp_vj_id,       i4
	inp_atd_id,      i4
	inp_vb_id,       i4
	no_sett, i4      ; if true then no settlement discount (MSF special)
	sb_vat_code,     VAT_CODE              ; validate during self bill entry
	sb_vat_zero,     VAT_CODE              ; after initially being set to
                                        ; above or ivt or default uk
	curr_dsp,        d1
	plan_maint,      d1              ; if true then plan maintenance applicable
	pm_create_cont_ivt,a2           ; planned maint is in use but this is
					; not a pm invoice and therefore will
					; offer contract option on wgd
	f_vg_pm_link,	d1		; from vg_planned_main_link
	f_pm_exists,	d1		; planned maint contract already exists
	f_pm_att,	d1		; true of at least one attachment is down payment
	lPPDInUse,		d1
endstructure

.function whgine
	pm_type,        n       ; optional - if passed and true this is deemed to be
                        ; plan maintenance invoice entry

	.define SYN_TK                  ; define as Synergy Program
	.include 'SRC:OPSCOM.REC'

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM4REC.REC'
	.include 'SRC:CM5REC.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VGREC.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:HWREC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:PMFCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:NMFREC.REC'
	.include 'SRC:PMVREC.REC'
	.include 'SRC:CATCOM.REC'
	.include 'SRC:PDFCOM.REC'
	.include 'SRC:DMFREC.REC'
	.include 'SRC:PREREC.REC'
	.include 'SRC:SRPREC.REC'
	.include 'SRC:SMFREC.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:IVHREC.REC'
	.include 'SRC:WQHREC.REC'
	.include 'SRC:WQLREC.REC'
	.include 'SRC:CTFREC.REC'
	.include 'SRC:CTHREC.REC'
	.include 'SRC:VQREC.REC'
	.include 'SRC:HIDREC.REC'
	.include 'SRC:HPDREC.REC'
	.include 'SRC:ACCREC.REC'
	.include 'SRC:VSREC.REC'
	.include 'SRC:VSPREC.REC'
	.include 'SRC:IHHREC.REC'
	.include 'SRC:IVLREC.REC'

	.include 'SRC:PMHREC.REC'
	.include 'SRC:PMLREC.REC'
	.include 'SRC:PMDREC.REC'
	.include 'SRC:PMGREC.REC'
	.include 'SRC:PMCREC.REC'
	.include 'SRC:PMMREC.REC'
	.include 'DEF:WHGSPC.DEF'
	.include 'TXT:WHGINE.TXT'
	.include 'DEF:VEHINV.DEF'
	.include 'SRC:HORT.CMN'
	.include 'SRC:POS_PARTS.CMN'

	.include 'DEF:DOCREC.DEF'
	.include 'SRC:DRFREC.REC'

	.define T$FK_PRTS,      'Prints ' + 'J_PRTS    ' + 'Prints'
	.define T$FK_SER_AMD,   'Ser Amd' + 'J_SER_AMD ' + 'Serial Amend'
	.define T$FK_FC_CURR,   'FC Curr' + 'J_CURR_FC ' + 'Display sale prices in currency'
	.define T$FK_SPC_WGD,   '{W} Spc' + 'J_SPC_WGD ' + 'Amend {WHOLEGD} Spec'
	.define T$FK_SPC_PM,    'EqpSpec' + 'J_SPC_WGD ' + 'Amend PM Equipment Spec'    ; for plan maint spec
	.define T$FK_CLK_PM,    'UpClock' + 'J_CLOCK   ' + 'Amend PM Clock Details'     ; for plan maint spec
	.define T$FK_AUTO_ADV,  'AutoAdv' + 'J_AUTO_ADV' + 'Auto Advice/Credit'
	.define T$FK_NEW_TFR,   'New Tfr' + 'J_NEW_TFR ' + 'New Transfer In'
	.define T$FK_WGD_ENQ,   '{W} Enq' + 'J_ENQ_WGD ' + '{WHOLEGD} Enquiry'
	.define T$FK_OVR_DSC,   'Ovr Dsc' + 'J_OVR_DSC ' + 'Override Sales by a percentage'

	.define T$FK_DEP_INV,   'Dep Inv' + 'J_DEP_INV ' + 'Raise Deposit Invoice'
	.define T$FK_DEP_CRD,   'Dep Crd' + 'J_DEP_CRD ' + 'Credit Deposit'
	.define T$FK_FIN_DET,   'Fin Det' + 'J_FIN_DET ' + 'Amend Finance  Details'
	.define T$FK_IMP_STY,   'Imp Sty' + 'J_IMP_STY ' + 'Import Standard Story'
	.define T$FK_NEW_MOD,	'New Mod' + 'J_NEW_MOD ' + 'New Model Code'	; WG7465
	.define T$FK_PRV_TRD,   'P.Trad ' + 'J_PRV_TRD ' + 'Add Previous Linked Trade-In'
	.define T$FK_WSTK_NO,   'W.Stkno' + 'J_W_STKNO ' + 'Enter main washout stock no'
	.define T$FK_GRN,       '{W} GRN' + 'J_VEHGRN  ' + '{WHOLEGD} GRN Routine'
	.define T$FK_PDI_REF,   'PDI/REF' + 'J_PDIREF  ' + 'Display PDI Details'

	.define T$SELL_PRI_WARN,    'WARNING - Selling price less than %a of %a'
	.define T$MSF_NO_SETT,          'No Settlement Allowed for Outlet Type Y'
	.define T$SMS_TIP,     "List of SMS Messages Sent"

	.define D_VAT_EXC,      0
	.define D_VAT_INC,      1
	.define T$P_COD_MACH_NO_SPC_TI, '"Machinery Sales No Specific Trade in"'
	.define D_CRT_PM_PROC,  2       ; when view mode flag for pm contract
				; entry is set, allow user function to
				; swap out to contract

	external function
		f_yes_no,               d
		f_no_yes,               d
		listiad_create,         d
		f_rjust,                a
		f_format_money,         a
		f_curr_bc,              d
		f_curr_fc,              d
		f_alpha11_date,         a
		julian,                 d
		f_chk_access,           d
		f_prnt_list,			a

		;-------------------------------------------------------------------------------
		;               global areas for list processing and the like
	global data section whgine_chn_data, init
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data, init
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	literal
	tx_typ,         4a7,    'Invoice','Credit ','Credit ','Invoice'
	modtyp,         5a T$MOD_LEN, T$MODIST, T$MODAMD, T$MODDEL, T$MODVEW,
	&       T$MODPRT

	record vehine_sb_only
		sb_only_ityp,   a2
		,       a30             ;sb_only_desc field not referenced

	record ovr_sal_data
		ovr_value,      a10
		ovr_type,       d1
		ovr_based,      d1

	record ovr_dsc_data
		ovr_disc,       d4
		ovr_dsc_based,  d1

		structure ll_hidrec
			ll_hid,         a ^size(hidrec)
			ll_hid_st,      d1
			ll_loop,        i4

	record xrf
		xrf_items,      @ArrayList
		xrf_item,       drf_item

	record gen
		.include 'DEF:SCUTGRP.DEF'
		group h_shortcut
			h_short_stok, a8
			h_short_prog, a6
			h_short_return, a10
		endgroup
		tabmnu_ctrl,    a2000
		tabmnu_ctrl_cop,a2000
		.include 'doc_print' repository, group = 'doc_print'
		.include 'gold_com' repository, group = 'gold_com'
		.include 'gold_ax' repository, group = 'gold_ax'
		.include 'wvi_user' repository, group='wvi_user'
		.include 'whgine_hdr' repository, group='whgine_hdr'
		.include 'whgine_lst' repository, group='whgine_lst'
		.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
		.include 'whgine_passed' repository, group='whgine_passed'
		.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
		.include 'whgine_vb' repository, group= 'whgine_vb'
		.include 'whgine_vj' repository, group= 'whgine_vj'
		.include 'whgine_vj' repository, group= 'whgine_nstk'
		.include 'whgine_att_lst' repository, group= 'whgine_att_lst'
		.include 'add_part_passed' repository, group='add_part_passed'
		.include 'invoice_totals' repository, group='invoice_totals'
		.include 'wgd_deladd' repository, group='lWgd_del_add'
		.include 'vm_user' repository, group='vm_user'
		.include 'vw_user' repository, group='vw_user'
		.include 'ivt_user' repository, group='ivt_user'
		.include 'cmf_user' repository, group='cmf_user'
		.include 'cmf_user' repository, group='del_cmf_user'
		.include 'vg_user' repository, group = 'vg_user'
		.include 'user_data' repository, group = 'user_data'
		.include 'add_part_str' repository, group='part_data'
		.include 'smf_user' repository, group = 'smf_user'
		.include 'pmh_user' repository, group='pmh_user'
		.include 'doclst_pass' repository, group = 'doclst_pass'
		.include 'doc_search' repository, group='doc_search'
		.include 'smslst_pass' repository, group = 'smslst_pass'
		.include 'SRC:VEHMSG.REC'
		err,            d3
		reject,         d2
		group fkeys,    [MAX_FKEYS] a
			.include 'fkeys' repository, group='fkeys_grp'
		endgroup
		filnam,         [FILE_NUM] a D_FILENAME_LEN
		filmod,         [FILE_NUM] d1
		filtyp,         [FILE_NUM] d1
		sb_inv_type,    a2              ; self billing invoice type
		h_prev_job,     a6
		done,           d1
		quitting,       d1
		vm_rfa,         a6
		vj_rfa,         a6
		vi_rfa,         a6
		disp_line,      a90
		filename,       a D_FILENAME_LEN
		depot_code,     a1
		cost_head,      a9              ; set at start and = '    COST' or 'COST(xxx)'
                                        ; where xxx is base currency code
		yn_ans,         d1
		group opt_array
			opt_data,      7a24
		endgroup
		selection,      a2
		lSelectionType,		[7]d1
		group ivh_key,  a
			ivhk_typ_ser, d1      ; 0 for wholegoods
			ivhk_wgstk,   a8
		endgroup
		h_date,         d8
		yes_no_ans,     d1
		search,         d1
		del_cust,       a6
		.include 'vmrec' repository, group='old_vmrec', nofields
		wsj_access,   d2
		pmv_ctrl,       a D_LL_CTLSIZE
		auto_advice,    a6                      ; new advice note no (autogen)
		stkno,          a8
		attach_no,      a8
		at_bottom,      d1
		hld_vistat,     d1
		ivt_desc_chng,  d1
		h_rrp,          d10
		tab_number,     [D_MAX_TABS]d2
		tmp_qty,        d10
		;        vt_rates,       [10]d4
		tmp_rate,		d4
		h_mode,			d1
	record ivars
		loop,           i4
		req,            i4
		g_rtn,          i4
		f_lock_vi,      i4
		gen_channel,    i4
		key_vi_id,      i4
		inp_bal_id,     i4
		seq_lnp_id,     i4
		lst_chn,        i4
		stat,           i4
		opt_id,         i4
		opt_type,       i4
		sb_it_id,       i4
		inv_cmnt_id,    i4
		tab_index,      i4
		tab_max,        i4
		pmv_chn,        i4
		del_chn,        i4
		auto_id,        i4
		sign,           i4
		ovr_sal_id,     i4
		f_tfr_attach,   i4
		selwd_id,       i4
		doc_lst_id,     i4
		sms_lst_id,	i4
		fin_tab_id,     i4
		oip_tab_id,     i4
		sms_tab_id,     i4
		no_access,      i4
		f_some_idt_os,  i4
.proc
	clear gen, ^i(ivars), vj_line1_id, vj_line2_id, vb_line1_id, vb_line2_id
	clear doc_drf_chn, doc_doc_chn, doc_dct_chn, wnd_id

	; main despatcher routine - initialised to do setup first
	g_rtn = WR_SETUP

	repeat
	begin
		case g_rtn of
		begincase
			WR_SETUP:       call set_up
			WR_GET_ADV:     call get_adv
			WR_HEADER:      call get_hdr
			WR_SHOW_DETS:   call tab_process
			WR_DELETE_ADV:  call delete_advice
			WR_QUIT_RTN:    exitloop
		endcase
	end

	call shutdown

	if (h_short_prog)                                               ; CEW 16Jun05
	begin
		xcall sendm(Shortcut_Key,"[SCUT]")
		freturn h_short_prog
	end

	freturn ''

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       allow user to enter the advice note number
	get_adv,
	if cms_currency
		xcall disp_curr(cms_base_cur)
	clear whgine_hdr, seq_fkeys_active, tmp_job_no
	clear lWgd_del_add
	xcall i_init(inp_vi_id, 'tot_set', whgine_hdr)

	; clear deleted item list
	req = D_LL_FIRST
	xcall ll_process(pass_chn_data.lst_cntrl, req, whgine_lst, err)
	while .not. err
	begin
		req = D_LL_DELETE
		xcall ll_process( pass_chn_data.lst_cntrl, req, whgine_lst, err )
		req = D_LL_NEXT
		xcall ll_process( pass_chn_data.lst_cntrl, req, whgine_lst, err )
	end

	; if this is second time in then not allow any further entries to be made
	if(h_short_return .eq. 'PMINVX' .and. .not. snd_job_no)
	begin
		clear h_shortcut
		g_rtn = WR_QUIT_RTN
		return
	end
	if(h_short_return .eq. 'PMHMNT' .and. .not. snd_job_no)
	begin
		clear h_shortcut
		g_rtn = WR_QUIT_RTN
		return
	end

	; if this is second time in then not allow any further entries to be made
	if(h_short_prog .eq. 'WQSINP' .and. .not. snd_job_no)
	begin
		g_rtn = WR_QUIT_RTN
		return
	end

	pass_gen_data.adv_mode = D_AMD_MODE

	xcall wvi_user_clr( key_vi_id, 'vi_job' )
	clear quitting, done, pass_gen_data.curr_dsp
	xcall ibc_window( D_REMOVE, inp_vi_id, D_PLACE, key_vi_id )

	if(snd_job_no)
	begin
		pass_gen_data.adv_mode=D_AMD_MODE
		vi_job=snd_job_no
		call validate_advice
		;            call display_mode
		clear snd_job_no
	end

	call display_mode
	xcall i_init(key_vi_id, 'adv_set', whgine_vi_grp)
	while .not. quitting .and. .not. done
	begin
		xcall i_next(key_vi_id, 'adv_set', '*FRST*')
		unlock pass_chn_data.chn(VI_FILE)
		xcall ibc_input(key_vi_id, 'adv_set', whgine_vi_grp,
		&               gold_com.inp_col_id, gold_com.sel_col_id,, D_NOTERM,,
		&               fkeys[IAD_FKEYS], gold_com, gold_ax, whgine_passed,
		&               ivt_desc_chng)
		if(g_select) then
		begin
			case g_entnam of
			begincase
				"J_QUIT":           quitting = true
				"J_INS":            begin
					pass_gen_data.adv_mode=D_INS_MODE
					call display_mode
				end
				"J_DEL":            begin
					pass_gen_data.adv_mode=D_DEL_MODE
					call display_mode
				end
				"J_AMD":            begin
					pass_gen_data.adv_mode=D_AMD_MODE
					call display_mode
				end

				"J_NXT_ADV":        begin
					xcall file(pass_chn_data.chn(VI_FILE),virec,h_prev_job,'RD',err
					&                               ,,,,,D_NO_LOCK)
					if(err)
						xcall file(pass_chn_data.chn(VI_FILE),virec,vijob,'FS',err)

					repeat
					begin
						xcall file(pass_chn_data.chn(VI_FILE),virec,,'RS',err,,,,,D_NO_LOCK)
						if(err) exitloop
						if(pass_gen_data.plan_maint.and..not.vi_pm_contract) nextloop
						if(.not.pass_gen_data.plan_maint.and.vi_pm_contract) nextloop
						exitloop
					end
					vi_job=vijob
					if(err) then
						xcall ibc_message('End of File Reached')
					else
						goto prev_adv
				end
				'J_CHG_AMD':        begin
					pass_gen_data.adv_mode = D_AMD_MODE
					call display_mode
					done = true
					call validate_advice
				end
				"J_PRV_ADV":        begin
					xcall file(pass_chn_data.chn(VI_FILE),virec,h_prev_job,'RD',err
					&                               ,,,,,D_NO_LOCK)
					if(err)
						xcall file(pass_chn_data.chn(VI_FILE),virec,vijob,'LA',err)
					repeat
					begin
						xcall file(pass_chn_data.chn(VI_FILE),virec,,'RV',err,,,,,D_NO_LOCK)
						if(err) exitloop
						if(pass_gen_data.plan_maint.and..not.vi_pm_contract) nextloop
						if(.not.pass_gen_data.plan_maint.and.vi_pm_contract) nextloop
						exitloop
					end
					vi_job=vijob
					if(err) then
						xcall ibc_message('Beginning of File Reached')
					else
						prev_adv,
					begin
						if(vistat.ge.D_ADV_INVOICED) then
							pass_gen_data.adv_mode=D_VEW_MODE
						else
							pass_gen_data.adv_mode=D_AMD_MODE
						call validate_advice
					end
				end
			endcase
		end
		else
			call validate_advice
	end

	if g_entnam .eq. 'J_QUIT' then
		g_rtn = WR_QUIT_RTN
	else
	begin
		if pass_gen_data.adv_mode .eq. D_DEL_MODE then
			g_rtn = WR_DELETE_ADV
		else
			g_rtn = WR_HEADER
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	get_hdr,
	xcall ibc_window( D_REMOVE, key_vi_id, D_PLACE, inp_vi_id )
	xcall wnd_title(modtyp(mode), inp_vi_id)
	xcall i_frames( inp_vi_id )
	call set_access
	xcall i_snapshot(D_LOAD, pass_gen_data.inp_atd_id, atd_snap)

	xcall i_user(inp_hdr_id, 'vi_cust', cmf_user)
	cmf_user.chk_min = ivt_cus_fr
	cmf_user.chk_max = ivt_cus_to
	cmf_user.ign_locks = TRUE
	xcall i_user(inp_hdr_id, 'vi_cust',, cmf_user)

	if pass_gen_data.adv_mode .ne. D_INS_MODE then
	begin
		xcall set_vi_fields(gold_com, gold_ax, whgine_hdr, whgine_inv_tab,
		&                   whgine_passed, add_part_passed, lWgd_del_add)
		if vi_crst_inp .eq. D_IVT_CRST_CREDIT then
			xcall i_prompt(inp_hdr_id, 'vi_cr_chrg_inp', T$CRED_PRMPT)
		else
			xcall i_prompt(inp_hdr_id, 'vi_cr_chrg_inp', T$SETT_PRMPT)

		for loop from 1 thru 5
			reseq_req[loop] = true    ; reload lists required

		xcall reset_currency(gold_com, whgine_passed)
		gold_com.cur_dp[D_FC] = fcf_dp

		if pass_gen_data.vi_currency .eq. cms_base_cur
			xcall i_setdel(pass_gen_data.inp_atd_id, 'wgd_fullset',
			& 'vj_bc_rrp,vj_bc_vi_rrp,vj_atd_rrp_bcur, vj_atd_rrp_bcur_o,vj_atd_t_brrp,vj_atd_t_vi_brrp')

		if vistat.ge.D_ADV_INVOICED
		begin
			if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL
			&  .and.vi_not_sbill.eq.D_VI_NOT_SB_PUR_INV) then
				disp_line = modtyp(pass_gen_data.adv_mode) + ' Self Bill Purchase Items'
				&  +' -  Received Date: ' +
				&               %f_alpha11_date(viidat)
			else
				disp_line = modtyp(pass_gen_data.adv_mode) + ' Inv No. ' + viinvo + ' - Date: ' +
				&             %f_alpha11_date(viidat)
			xcall wnd_title(disp_line, inp_vi_id)
		end
		xcall i_display(inp_hdr_id, 'disp_set', whgine_hdr)
	end
	else
	begin
		xcall i_init(inp_hdr_id, 'init_set', whgine_hdr)
		if( vi_narr )
			xcall i_dspfld( inp_hdr_id, 'vi_narr', vi_narr )
		; special for ibcos coventry - default invoice type to 01
		if(cms_user_id.eq.19998)
			vi_inv_typ='01'
		clear adv_totals
		clear lst_cmnt_seq, lst_part_seq
		vi_idat=%ndate
		xcall get_445_inv_date(vi_idat)
		if(cms_country.ne.SAUDI_ARABIA.and.cms_country.ne.NO_VAT)
			set pass_gen_data.h_vatable, vi_vatable=TRUE
		set vi_dep, vi_depot = gold_com.cur_depot
		pass_gen_data.h_ivcr = vi_iorc
		call get_dep_name
		vi_not_sbill=D_VI_NOT_SB_PRT_SB
		clear h_acc, h_invtyp
	end
	xcall i_display(inp_vi_id, 'adv_set', WHGINE_HDR,,,,,,,,,, gold_com)

	xcall restart_all_lists(gold_com, gold_ax, whgine_hdr, whgine_passed, add_part_passed,
	&        doc_lst_id, sms_lst_id, fkeys, doclst_pass, doc_search,smslst_pass)

	; check if vat margin does not have main cost assigned (user can still continue but all costs will be used to calculate vat
	if (%WHGINE_chk_main_cost(gold_com, vijob, whgine_passed))
		g_rtn = WR_GET_ADV
	else
		g_rtn = WR_SHOW_DETS

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	tab_process,
	if(pass_gen_data.plan_maint == false && wg_security != ACC_NO_COST_DISP)
	begin
		; check if there are any restrictions in force for this user
		whgine_passed.f_acc_wg_exclude=%f_get_acc_wg_exclusions()
		if(whgine_passed.f_acc_wg_exclude == 1.and.vijob.and.vijob != T$AUTO)
		begin
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vijob,'FI',err)
			repeat
			begin
				xcall file(pass_chn_data.chn(VJ_FILE), vjrec,,'RS',err, ,,,,Q_NO_LOCK)
				if(err || vjjob.ne.vijob) exitloop
				if(vjnstk > D_VJ_NSTK) nextloop
				if(%f_chk_vgf_restricted(,vjngrp, dt)) whgine_passed.f_acc_wg_exclude=2
				if(whgine_passed.f_acc_wg_exclude==2) exitloop
			end
		end
		if(whgine_passed.f_acc_wg_exclude)
		begin
			xcall i_fldmod(inp_vi_id, 'INV_PROF_V' ,,,D_ON,  D_FLD_BZRO )
			xcall i_fldmod(inp_vi_id, 'INV_PROF_P' ,,,D_ON,  D_FLD_BZRO )
		end
		else
		begin
			xcall i_fldmod(inp_vi_id, 'INV_PROF_V' ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(inp_vi_id, 'INV_PROF_P' ,,,D_OFF, D_FLD_BZRO )
		end
	end

	clear items_moded, hdr_moded, add_part_passed.moded_flag, trd_cmnt_flg
	h_prev_job = vijob
	xcall l_queue(seq_lst_id, D_LBOTTOM)
	req = D_LTOP
	xcall l_process(seq_lst_id, req, whgine_lst,, gold_com, gold_ax,
	&               fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	; populate all other lists as these can be updated by the hide process

	xcall l_queue(wgd_lst_id, D_LBOTTOM)
	req = D_LTOP

	xcall l_process(wgd_lst_id, req, whgine_vj,, gold_com, gold_ax,
	&               fkeys[WGD_FKEYS], whgine_passed, fkeys, whgine_lst,
	&               whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)
	if(fkeys[WGD_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[WGD_FKEYS].fkmnu_id)

	xcall l_queue(nstk_lst_id, D_LBOTTOM)
	req = D_LTOP
	xcall l_process(nstk_lst_id, req, whgine_nstk,, gold_com, gold_ax,
	&               fkeys[NSTK_FKEYS], whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
	&       whgine_hdr, add_part_passed, invoice_totals)
	if(fkeys[NSTK_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[NSTK_FKEYS].fkmnu_id)

	xcall l_queue(prt_lst_id, D_LBOTTOM)
	req = D_LTOP
	xcall l_process(prt_lst_id, req, part_data,,gold_com, gold_ax,
	&              fkeys[PRTLST_FKEYS], add_part_passed, invoice_totals,
	&              pass_chn_data.chn, whgine_passed, fkeys, whgine_lst,
	&              whgine_inv_tab, whgine_hdr)
	if(fkeys[PRTLST_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[PRTLST_FKEYS].fkmnu_id)

	xcall l_queue(cmnt_lst_id, D_LBOTTOM)
	req = D_LTOP
	xcall l_process(cmnt_lst_id, req, whgine_cmnt_lst,, gold_com, gold_ax,
	&               fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)
	if(fkeys[CMNT_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[CMNT_FKEYS].fkmnu_id)

	xcall l_queue(trd_lst_id, D_LBOTTOM)
	req = D_LTOP
	xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
	&               fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
	&               whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)

	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab, add_part_passed, invoice_totals)
	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab)
	call clear_menu_columns

	if(.not. pass_gen_data.plan_maint)
	begin
		if(pass_chn_data.h_prog_code.eq.P_COD_MACH_NO_SPC_TI) then
			xcall ts_tabset(DTS_DISABLE, gold_com.tabset_id, D_TRD_TAB_ID)
		else
			xcall ts_tabset(DTS_ENABLE,  gold_com.tabset_id, D_TRD_TAB_ID)
		if(cm4_wg_end_user_dets)
		begin
			if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL) then
				xcall ts_tabset(DTS_DISABLE, gold_com.tabset_id, oip_tab_id)
			else
				xcall ts_tabset(DTS_ENABLE,  gold_com.tabset_id, oip_tab_id)
		end
	end
	call set_unset_finance_tab

	xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, D_HDR_TAB_ID)
	.ifndef D_GUI
		xcall ibc_column(D_PLACE, tabmnu_id)
	.endc
	xcall ibc_window(D_PLACE, gold_com.tabset_id, 4, 1)

	reject=%whgine_cust_check(whgine_hdr, whgine_passed, whgine_inv_tab,
	&       crlim_pass_ent)

	if( reject.eq.D_CUS_REJECT)
	begin
		g_rtn = WR_GET_ADV
		goto exit_tab_process
	end

	; the tab numbers are sequential from 1 to 10 unless this is a plan
	; maintenance invoice in which case there is cut down set
	; therefore, initilise a tab number array with te subscrpt itself
	; then if plan main, reset

	for loop from 1 thru D_MAX_TABS
	begin
		tab_number(loop)=loop
	end
	if(pass_gen_data.plan_maint)
	begin
		tab_number[D_NSTK_TAB_ID]=3
		tab_number[D_PART_TAB_ID]=4
		tab_number[D_CMNT_TAB_ID]=6
	end
	if(pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL) then
		fkeys[TRD_FKEYS].fkey[D_FK_NO6].disabled_flg = FALSE
	else
		fkeys[TRD_FKEYS].fkey[D_FK_NO6].disabled_flg = TRUE
	xcall wgd_stg_check_vsp(whgine_hdr.vi_job, whgine_passed.wgd_stg_proc_ids_grp, gold_com)
	repeat
	begin
		xcall ts_process(gold_com.tabset_id, gold_com, gold_ax, fkeys,
		&                whgine_passed, whgine_hdr, whgine_lst,
		&                add_part_passed, invoice_totals, whgine_cmnt_lst,
		&                part_data, whgine_inv_tab, whgine_vb, whgine_vj,
		&                whgine_nstk,doclst_pass, doc_search, smslst_pass, lWgd_del_add)
		case g_entnam of
		begincase
			'HDR_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_HDR_TAB_ID])
			'PART_TAB':   xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_PART_TAB_ID])
			'WGD_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_WGD_TAB_ID])
			'NSTK_TAB':   xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_NSTK_TAB_ID])
			'CMNT_TAB':   xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_CMNT_TAB_ID])
			'TRD_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_TRD_TAB_ID])
			'SEQ_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_SEQ_TAB_ID])
			'DOC_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_DOC_TAB_ID])
			'STG_PAY_TAB':xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[whgine_passed.stg_pay_tab_id])
			'OIP_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[oip_tab_id])
			'FIN_TAB':    xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[fin_tab_id])
			'J_QUIT':
			begin
				if whgine_passed.f_del_note_only.eq.false .and.
				&   items_moded .or. add_part_passed.moded_flag .or.
				&       hdr_moded then
				begin
					h_mode=pass_gen_data.adv_mode
					yn_ans = %f_update('Update Invoice?')
					if yn_ans .eq. D_YES .or. yn_ans .eq. D_SAVE_CONTINUE then
						xcall whgine_upd(gold_com, gold_ax, fkeys, whgine_passed,
						&            whgine_hdr, whgine_lst, add_part_passed,
						&            invoice_totals, whgine_cmnt_lst,
						&            whgine_inv_tab, whgine_vj, whgine_vb,
						&            whgine_nstk, part_data, lWgd_del_add, ivtrec)
					else
					begin
						xcall whgine_canc_parts(gold_com, gold_ax, prt_lst_id,
						&                             part_data, add_part_passed)
						call canc_inv_cmnt
						call tidy_attach
						xcall whgine_cancel_wgds(whgine_passed, whgine_hdr)
					end
					call display_mode
					if h_mode .eq. D_INS_MODE .and. yn_ans .eq. D_YES
						xcall ibc_message('Advice ' + vijob + ' created')
				end
				else
					yn_ans = D_NO
				if yn_ans .eq. D_SAVE_CONTINUE
				begin
					; restart the lists, need to do this to pick up prev batch
					; flag changes etc.
					call set_access
					xcall restart_all_lists(gold_com, gold_ax, whgine_hdr, whgine_passed, add_part_passed,
					&        doc_lst_id, sms_lst_id, fkeys, doclst_pass, doc_search,smslst_pass)
					xcall l_queue(seq_lst_id, D_LBOTTOM)
					req = D_LTOP
					xcall l_process(seq_lst_id, req, whgine_lst,, gold_com, gold_ax,
					&           fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
					clear items_moded, hdr_moded
					pass_gen_data.adv_mode = D_AMD_MODE
					tab_max = %ts_tabset(DTS_NUMTABS, gold_com.tabset_id)
					tab_index = %ts_tabset(DTS_ACTIVE, gold_com.tabset_id)
					incr tab_index
					if tab_index .gt. tab_max
						tab_index = 1
					xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_index)
					nextloop
				end
				clear g_select, g_entnam
				exitloop
			end
			'J_PRTS':     begin
				call upd_required
				if yn_ans .eq. D_YES
				begin
					if .not. %chk_all_lines_hid(gold_com, gold_ax, whgine_passed,
					&       whgine_hdr)
					begin
						call print_options
						if(snd_job_no.eq.vijob.and.g_rtn.eq.WR_GET_ADV) exitloop

					end
				end
			end
			'J_INV':      begin
				call upd_required
				if (yn_ans == D_YES)
				begin
					if (cmf_stop == 2 && %get_password( cms_inv_stop_pwd, , 'Account on Stop' ) )
						exit

					if ( ! %chk_all_lines_hid(gold_com, gold_ax, whgine_passed, whgine_hdr))
					begin
						clear err
						if(sb_line_count)
							xcall whgine_check_cmf_sb_exp_date(vi_not_sbill,
							&               cmf_sb_exp_date, vi_idat, err)
						if (err) exit

						stat=D_PRT_INV_UPD

						call check_any_wsj
						call print_control
						if (g_rtn == WR_HEADER)
						begin
							xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, tab_number[D_HDR_TAB_ID])
							nextloop
						end
						if (! reject)
						begin
							snd_job_no = vijob
						end
						g_rtn=WR_GET_ADV
						exitloop
					end
				end
			end
			'J_DEL_ADD':  call delivery_address

			'J_AUTO_ADV': begin
				call create_auto_advice
				if .not. err
					exitloop
			end
			'J_OVR_TOT':  call override_sale      ; Override Sales Total
			'J_OVR_DSC':  call override_disc      ; Override Sales Total
			'J_TFR_ATT':  call tfr_attach
			'J_VEHGRN':   call wholegood_grn_routine
			'SMS_TEXT':   call send_text

			'FINUPDREQD': begin
				call upd_required
				if yn_ans .eq. D_YES
				begin
					xcall m_signal('J_DEP_INV')
				end
				xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, fin_tab_id)
			end
			'FINUPDPRT':
			begin
				call action_update
				xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, fin_tab_id)
			end
		endcase
	end
	exit_tab_process,
	g_rtn = WR_GET_ADV
	xcall ibc_window(D_REMOVE, gold_com.tabset_id)

	call clear_menu_columns

	.ifndef D_GUI
		xcall ibc_column(D_DELETE, tabmnu_id)
	.endc
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	clear_menu_columns,
	; get rid of menu columns loaded by above
	xcall ibc_column(D_REMOVE, fkeys[WGD_FKEYS].fkmnu_id)
	xcall ibc_column(D_REMOVE, fkeys[SEQ_FKEYS].fkmnu_id)
	xcall ibc_column(D_REMOVE, fkeys[NSTK_FKEYS].fkmnu_id)
	xcall ibc_column(D_REMOVE, fkeys[CMNT_FKEYS].fkmnu_id)
	xcall ibc_column(D_REMOVE, fkeys[PRTLST_FKEYS].fkmnu_id)
	xcall ibc_column(D_REMOVE, fkeys[TRD_INP_FKEYS].fkmnu_id)
	xcall ibc_column(D_REMOVE, fkeys[TRD_FKEYS].fkmnu_id)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	Send SMS Text Message
	;
	send_text,
	xcall sms_text( gold_com, gold_ax, SMS_TYP_WHOLEGOOD, vi_job, D_TEL_CUSTOMER, vicust,
	&	, cmf_name, cmf_alt_teln, ,,cusrec,,,,,,,vmrec,,,,,,,,, virec)

	xcall lbc_restart(sms_lst_id)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       Hide flag on Attachments may have been set - unset it!
;
	tidy_attach,

	xcall file(pass_chn_data.chn(VD_FILE),vdrec,lst_stkno,'FI',err,1)
	repeat
	begin
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',err,1)
		if (err.or.lst_stkno.ne.vdstok)
			exitloop
		if(vdcode.eq.cms_wg_att_code) then
			nop
		else
			clear vd_hide
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'WR',err,1)
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;  if job not saved removed any temporary invoice comments
	canc_inv_cmnt,
	xcall ScratchPadDelete(CMNT_WG_INV_STY,tmp_job_no)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	wholegood_grn_routine,
	f_tfr_attach=false
	call transfer_or_grn_process
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	tfr_attach,
	f_tfr_attach=true
	call transfer_or_grn_process
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	transfer_or_grn_process,
	; store stock and attach no in case update messes with context
	if whgine_vj.vj_wg_attach then
	begin
		stkno = whgine_vj.vj_astk
		attach_no = whgine_vj.vj_tstk
	end
	else
	begin
		stkno = whgine_vj.vj_tstk
		clear attach_no
	end

	call upd_required
	if yn_ans .ne. D_YES
		return

	; find the wg item in the seqence list
	clear at_bottom
	xcall l_process( seq_lst_id, req = D_LRESTORE, whgine_lst, , gold_com,
	&                gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
	&                gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	repeat
	begin
		if lst_ntype .eq. D_VJ_WGD .and. lst_stkno .eq. stkno
			exitloop
		if at_bottom
			exitloop
		xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
		&            gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
		xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
	end
	if(f_tfr_attach) then
	begin
		xcall xsubr('VEHAMT', 'WHGINE', gold_com.cur_depot, stkno, attach_no,,
		&       reject)
		if(reject) return
	end
	else
	begin
		xcall e_enter
		shortcut_key=stkno
		xcall sendm(shortcut_key,"[SCUT]")
		xcall execute('vehgrn')
		xcall e_exit
	end
	call action_update
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	override_sale,
	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )

	clear ovr_type, quitting
	xcall ibc_ldinp( ovr_sal_id, g_utlib, 'whgine_override' )

	if(pass_gen_data.plan_maint)
	begin
		set ovr_based = 1
		xcall i_dspfld(ovr_sal_id,'ovr_based',ovr_based,gold_com)
		xcall ibc_disable(ovr_sal_id,'ovr_based')
	end

	xcall i_fldmod(ovr_sal_id, 'ovr_value',,, D_FLD_FMT,
	&               %f_format_money(11,fcf_dp),D_FLD_DEC,fcf_dp )

	ovr_value = inv_nett
	xcall i_dspfld(ovr_sal_id,'ovr_value',ovr_value,gold_com)
	xcall i_next(ovr_sal_id,'disp_set','ovr_value')

	; Input question answers
	repeat
	begin
		; input key data..
		xcall ibc_input( ovr_sal_id, 'disp_set' ,ovr_sal_data, gold_inp_id,
		&                gold_sel_id ,, D_NOTERM )
		if(g_select .AND. g_entnam.eq.'J_QUIT') then
		begin
			quitting = TRUE
			exitloop
		end
		else
			exitloop
	end

	if .not. quitting .and. .not. ovr_based
		xcall ibc_message('WARNING - The retail price of any item with ZERO' +
		&                 ' cost will be set to zero')

	if(.not. quitting .and. %f_yes_no( 'Override Value ? ', 21 ) .eq. D_YES)
		xcall whgine_override(gold_com, gold_ax, whgine_passed, whgine_hdr,
		&                     whgine_inv_tab, add_part_passed, ^d(ovr_value),
		&                     ovr_type, ovr_based, whgine_vj, whgine_nstk,
		&                     part_data, fkeys, invoice_totals)

	xcall e_exit

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	override_disc,
	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )

	clear ovr_type, quitting
	xcall ibc_ldinp( ovr_sal_id, g_utlib, 'whgine_overdisc' )

	if(pass_gen_data.plan_maint)
	begin
		set ovr_dsc_based = 1
		xcall i_dspfld(ovr_sal_id,'ovr_dsc_based',ovr_dsc_based,gold_com)
		xcall ibc_disable(ovr_sal_id,'ovr_dsc_based')
	end
	; Input question answers
	repeat
	begin
		; input key data..
		xcall ibc_input( ovr_sal_id, 'disp_set', ovr_dsc_data, gold_inp_id,
		&                gold_sel_id ,, D_NOTERM )
		if(g_select .AND. g_entnam.eq.'J_QUIT') then
		begin
			quitting = TRUE
			exitloop
		end
		else
			exitloop
	end

	if .not. quitting .and. ovr_disc .gt. 0
		xcall ibc_message('SURCHARGE not discount has been applied')

	if .not. quitting .and. .not. ovr_dsc_based
		xcall ibc_message('WARNING - The retail price of any item with ZERO' +
		&                 ' cost will be set to zero')


	ovr_value = (adv_tot_retail * (10000 + ovr_disc))#4
	ovr_type = D_VAT_EXC
	ovr_based = ovr_dsc_based

	if(.not. quitting .and. %f_yes_no( 'Override Value?', 21 ) .eq. D_YES)
		xcall whgine_override(gold_com, gold_ax, whgine_passed, whgine_hdr,
		&                     whgine_inv_tab, add_part_passed, ^d(ovr_value),
		&                     ovr_type, ovr_based, whgine_vj, whgine_nstk,
		&                     part_data, fkeys, invoice_totals)

	xcall e_exit

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       check if file need updating - prompt to update if so
	upd_required,
	yn_ans = D_YES
	if .not. hdr_moded .and. .not. items_moded .and. .not.
	&       add_part_passed.moded_flag
		return

	yn_ans = %f_yes_no('Update?')
	if yn_ans .eq. D_YES
	begin
		call action_update
	end

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	action_update,

	xcall whgine_upd(gold_com, gold_ax, fkeys, whgine_passed,
	&              whgine_hdr, whgine_lst, add_part_passed,
	&              invoice_totals, whgine_cmnt_lst, whgine_inv_tab,
	&              whgine_vj, whgine_vb, whgine_nstk, part_data, lWgd_del_add, ivtrec)

	if pass_gen_data.adv_mode .eq. D_INS_MODE then
		xcall ibc_message('Advice ' + vijob + ' created')

	else
		xcall i_display(inp_vi_id, 'adv_set', whgine_hdr,,,,,,,,,,
		&               gold_com, gold_ax)
	xcall refresh_all_lists(gold_com, gold_ax, whgine_passed,
	&                       add_part_passed, whgine_lst,
	&                       fkeys[SEQ_FKEYS], invoice_totals)

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       remove advice from file
	delete_advice,

	g_rtn=WR_GET_ADV

	if(.not.( %f_yes_no( T$CONF_DELETE) .EQ. D_YES )) return
	xcall file(pass_chn_data.chn(VI_FILE),virec,vjjob,'DE',err)
	if(err) then
		xcall ibc_message('Failed to delete advice')
	else
		xcall ibc_message('Advice no '+vijob+' deleted successfully')

	return



	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; this section create a new advice to auto credit or invoice the
        ; currently selected one.
	create_auto_advice,
	if(pass_gen_data.vi_currency.ne.cmf_cur_cod)
	begin
		xcall ibc_message('Invalid - the advice currency is '+pass_gen_data.vi_currency
		&               +' while that of the customer is '+cmf_cur_cod)
		return
	end

	disp_line='Please Confirm Auto ' + %atrim(tx_typ(2-viivcr)) +
	&       ' Generation of this Advice is Required?'

	if( %f_yes_no(%atrim(disp_line),9,,,D_NO).ne.D_YES)
		return        ; no further action required

	; CHECK THAT ANY TRADE INS ARE STILL ON THE STOCK FILE
	xcall file(pass_chn_data.chn(VB_FILE),vbrec,vijob,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VB_FILE),vbrec,,'RS',err,,,,,D_NO_LOCK)
		if(err .or. vbjob .ne. vijob) exitloop
		pass_chn_data.h_stok=vbtstk
		xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
		if(.not. vb_vm_exists)
		begin
			xcall ibc_message('Cannot auto-create because trade-in stock no '+
			&                               vbtstk+' does not exist on file.')
			inval_copy,     return
		end

		f_tx_type=1-viivcr  ; set transaction type to what the copied
                                ; advice will be so if credit change to invoice
		if (%WHGINE_Check_Trade_In_Ok(f_tx_type, vmrec, virec))
			goto inval_copy

		if(f_tx_type.eq.D_VIIVCR_CREDIT)
		begin
			xcall whgine_check_sb_int_jobs(yes_no_ans, vbtstk)
			if(yes_no_ans.ne.D_YES)  goto inval_copy
		end

		; now check that the attachments (if any) are still present
		call check_invoice_attachments
		if(err) goto inval_copy

	end

	; now check the vj file and make sure that any stock records are in history

	xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vijob,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'RS',err,,,,,D_NO_LOCK)
		if(err .or. vjjob .ne. vijob) exitloop
		if(vjnstk.eq.D_VJ_WGD)
		begin
			pass_chn_data.h_stok=vjtstk
			xcall check_vm_exists(whgine_passed, lst_vm_exists, lst_vm_rfa)
			if(lst_vm_exists) then
			begin
				clear err
				if(viivcr.and.lst_vm_exists.ne.'S') err=2
				if(.not.viivcr.and.lst_vm_exists.ne.'H') err=3
			end
			else
				err=1
			if(err)
			begin
				disp_line='Cannot auto-create '+tx_typ(2-viivcr)+
				&                   ' because stock no. '+vjtstk+' does not exist'
				if(err.gt.1)
					disp_line(%trim(disp_line)+2,78)='in stock'
				if(err.gt.2)
					disp_line(%trim(disp_line)+2:7)='history'
				xcall ibc_message(disp_line)
				goto inval_copy
			end
			if(vminvf)
			begin
				xcall ibc_message('Invalid - {WHOLEGD} '+vmstok+' has already been '
				&                       +'selected for Invoicing. See advice no ' + vmadno)
				goto inval_copy
			end


			if(dt.ne.vm_depot)
			begin
				xcall ibc_message('Invalid - {WHOLEGD} '+vmstok
				&                       +' is at depot no '+vm_depot)
				goto inval_copy
			end
			; now check that the attachments (if any) are still present
			call check_invoice_attachments
			if(err) goto inval_copy
		end
	end

	xcall WhgineCheckCopyNotDoneBefore(whgine_hdr.vi_job, virec)

	; having passed all the validation checks above proceed with the auto generation
	; of the credit/or invoice

	call input_auto_advice_no       ; get new advice no
	if(.not.auto_advice)
	begin
		auto_gen_fail,
		xcall file(pass_chn_data.chn(VI_FILE),virec,vi_job,'RD',err)
		err = 1
		return
	end
	xcall file(pass_chn_data.chn(VI_FILE),virec,vi_job,'RD',err)

	; store the advice note no,
	vijob=auto_advice
	clear vistat, pass_gen_data.h_status
	viivcr=1-viivcr         ; toggle from inv to cred and visa versa
	pass_gen_data.h_ivcr=viivcr
	clear vi_cr_sett_yn
	pass_gen_data.h_cr_sett_yn=vi_cr_sett_yn

	vi_orig_invo=viinvo
	vi_orig_idat=viidat

	clear viinvo
	clear vi_f_totinv, vi_f_totvat, vi_vrat[], vi_vat_code[]
	vidate=%ndate
	viidat=%ndate
	xcall get_445_inv_date(viidat)
	if(visett) then
		viddat=%julian(%julian(viidat)+visett,1)
	else
		viddat=viidat
	clear vi_pro_form_prn, vi_pro_form_date, vi_pro_form_by
	clear vi_quote

	clear vi_dep_inv_no, vi_dep_inv_date, vi_deposit_status

	if(vi_cmf_add_in_dela)
		clear videla[], vi_del_postcode
	clear vi_cmf_add_in_dela
	clear vi_cmf_vat_no, vi_cmf_vat

	clear VIRec.vi_ppdsnamt[]
	clear VIRec.vi_ppdsnvat[]
	clear VIRec.vi_ppdsfvat[]
	for loop from 1 thru 5
	begin
		clear VIRec.vi_mvf_ppdsnamt[loop, D_FC]
		clear VIRec.vi_mvf_ppdsnamt[loop, D_BC]
		clear VIRec.vi_mvf_ppdsfvat[loop, D_FC]
		clear VIRec.vi_mvf_ppdsfvat[loop, D_BC]
	end
	xcall file(pass_chn_data.chn(VI_FILE),virec,vijob,'ST',err)
	if(err)
	begin
		xcall ibc_message('Error Creating Advice Header Record (VI)')
		goto auto_gen_fail
	end

	xcall file(pass_chn_data.chn(VB_FILE),vbrec,vi_job,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VB_FILE),vbrec,,'RS',err,,,,,D_NO_LOCK)
		if(err .or. vbjob .ne. vi_job) exitloop
		vbjob=auto_advice   ; reset advice no for credit
		clear vbsbin        ; clear invoice no

		pass_chn_data.h_stok=vbtstk
		f_lock_vm=TRUE
		xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
		if(err.or..not. vb_vm_exists) then
			xcall ibc_message('Trade in stock no longer available')
		else
		begin
			vm_sb_adv=1
			vm_sb_advno=vbjob
			vm_buy_rep=virep
			vmcord=viord
			vm_tip(D_FC)=vb_trade_prc(D_FC)
			vmoa=vb_trade_prc(D_BC)-vbtnsp

			vbtclk=vmclok
			vbtser=vmser
			vbtreg=vmreg
			vbtdat=vmdreg
			vb_year = vm_year
			vbtgrp=vmgrp
			vbtmak=vmmak
			for loop=1 until 10 do vbtspc(loop) = vmspec(loop)
			vbcode=vmcode
			vbtmod=vmmodl

			xcall whgine_write_vm(vb_vm_exists, vb_vm_rfa)
			; only write the trade in away if the stock record has been found
			xcall file(pass_chn_data.chn(VB_FILE),vbrec,vbjob,'ST',err)
			if(err) xcall ibc_message('Failed to store trade in '+vbtstk)
		end
	end

	; now copy stock items, non stock items and parts

	xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vi_job,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'RS',err,,,,,Q_NO_TLOCK)
		if (err || vjjob != vi_job)
			exitloop

		if(vjnstk.eq.D_VJ_WGD)
		begin
			if (viivcr) then
			begin
				lst_vm_exists='H'
				gen_channel=pass_chn_data.chn(HM_FILE)
			end
			else
			begin
				lst_vm_exists='S'
				gen_channel=pass_chn_data.chn(VM_FILE)
			end
			if(viivcr != D_VIIVCR_CREDIT)
			begin
				;not a credit note clear out contract details if we cant find them
				whgine_vj.vj_inp_pm_group.wg_pm_contract=vjrec.vj_wg_pm_group.wg_pm_contract
				whgine_vj.vj_inp_pm_group.wg_pm_equip_no=vjrec.vj_wg_pm_group.wg_pm_equip_no
				whgine_vj.vj_inp_pm_group.wg_pm_service_series=vjrec.vj_wg_pm_group.wg_pm_service_series
				if (!vjrec.vj_wg_pm_group.wg_pm_contract) ||
				& %whgine_read_pmh_pml(vjrec.vj_wg_pm_group.wg_pm_contract, whgine_vj, pass_chn_data.chn(PMH_FILE), pass_chn_data.chn(PML_FILE), pmhrec, pmlrec, false)
					clear vjrec.vj_wg_pm_group
				else
					xcall ibc_message("New Advice equipment "+%atrim(vjrec.vj_wg_pm_group.wg_pm_equip_no)+
					&	"\nassigned to existing planned maintenance contract "+vjrec.vj_wg_pm_group.wg_pm_contract)
			end
			xcall file (gen_channel,vmrec,vjtstk,'RD',err,,vm_rfa,,,D_NO_LOCK)
			if(.not.err) then
			begin
				xcall file (gen_channel,vmrec,,'RD',err,,,,vm_rfa)
				vminvf=1
				vmadno=vjjob
				vmcust=vicust
				if (.not. viivcr) then
				begin                             ; invoice
					vm_rrp(D_FC)=vj_f_rrp
					vm_rrp(D_BC)=%f_curr_bc(vm_rrp(D_FC),pass_gen_data.vi_exch_rate)
					vm_sett(D_FC)=vj_f_sett
					vm_sett(D_BC)=%f_curr_bc(vm_sett(D_FC),pass_gen_data.vi_exch_rate)
					vm_f_disc=vj_f_disc
					vmcord=viord
					vmrep=virep
				end
				else
				begin                             ; credit
					clear vmcord, vmrep
					; write customer de-allocated tracking record
					xcall vm_cust_trk_update(vmstok, vicust, , gold_com)

				end
				xcall whgine_write_vm(lst_vm_exists, lst_vm_rfa)

				; in case some fields update on vm since original, update vj fields
				vjcode = vmcode
				vjnmod=vmmodl
				vjnclk=vmclok
				vjnser=vmser
				vjnreg=vmreg
				vj_dreg=vmdreg
				vjused=vmnu
				vjtype=vmtype
				vjngrp=vmgrp
				vjnmak=vmmak
				for loop=1 until 10 do vjnspc(loop) = vmspec(loop)
			end
			else
			begin
				unlock pass_chn_data.chn(VM_FILE)
				unlock pass_chn_data.chn(HM_FILE)
			end
		end

		if(vjnstk.eq.D_VJ_PART)             ; parts
		begin
			if (viivcr == D_VIIVCR_CREDIT && (vjsold - vj_qty_credit - vj_qty_cred_wip) <= 0)
				nextloop

			vjsold = vjsold - vj_qty_credit - vj_qty_cred_wip
			xcall whgine_upd_part_data(virec, vjrec, cusrec, ivtrec, pass_chn_data.chn(PMF_FILE), pass_chn_data.chn(PDF_FILE), g_hid_chn, g_hpd_chn)
		end

		vjjob = auto_advice   ; reset advice no for credit
		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vjjob,'ST',err)
		if(err) xcall ibc_message('Failed to store vj record'+vjtstk)
	end

	; finally, check if there is a wg advice comment.  if so then recreate
	; for auto advice
	xcall ScratchPadCopy(CMNT_WG_INV_STY,vi_job,CMNT_WG_INV_STY,auto_advice)

	clear vq_key
	vq_job = vi_job
	xcall file(pass_chn_data.chn(VQ_FILE), vqrec, vq_key, 'FI', err,,,,, D_NO_LOCK)
	repeat
	begin
		xcall file(pass_chn_data.chn(VQ_FILE), vqrec, vq_key, 'RS', err,,,,, D_NO_LOCK)
		if err .or. vq_job .ne. vi_job
			exitloop
		vq_job = auto_advice
		vq_date_created = %ndate
		xcall file(pass_chn_data.chn(VQ_FILE), vqrec, vq_key, 'ST', err)
		if(err) xcall ibc_message('Failed to store vq record'+vjtstk)
	end

	clear err
	xcall ibc_message('Auto Advice Number '+vijob+' Created Successfully'
	&                       ,D_NOBELL)
	snd_job_no=auto_advice
	g_rtn=WR_GET_ADV
	return

	;-----------------------------------------------------------------------------
	check_invoice_attachments,
	; this section checks that the attachments written to the vk file still exist
	; (for the same stock number) as before.  if not, then error message and exit

	vkstok=vbtstk
	vkgrn=vbjob
	xcall file(pass_chn_data.chn(VK_FILE),vdrec,vkkey,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VK_FILE),vdrec,,'RS',err)
		if(err .or. vdgrn .ne. vbjob .or. vdstok .ne. vmstok) exitloop
		pass_chn_data.h_stok=vdastk
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,vdastk,'RD',err,,,,,D_NO_LOCK)
		if(err)
		begin
			xcall ibc_message('Attachment stock number '+pass_chn_data.h_stok+
			&                 ' for main stock number '+vmstok+' missing - cannot continue')
			return
		end
		if(vdstok .ne. vmstok)
		begin
			err=1
			xcall ibc_message('Attachment stock number '+pass_chn_data.h_stok+
			&                 ' was previously for main stock number '+
			&                   vmstok+'. This is now attached to main stock number '+vdstok
			&                   +' - cannot continue')
			return
		end
	end
	clear err
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       when auto advice nos are not in use, this section allows the
        ;       user to input a new advice number to be used for auto
        ;       generation of invoice and credits only
	input_auto_advice_no,
	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )
	xcall ibc_ldinp( auto_id, g_utlib, 'whgine_auto',, search,,,,
	&               fkeys[BLNK_FKEYS] )

	clear auto_advice
	; set up info line depending on whether auto generation in use or not
	disp_line='Enter New Advice Note Number to Auto Generate '
	if(cms_gngvad) disp_line(%trim(disp_line)+2:20)='- Return For Next'
	do
	begin
		xcall e_sect(%atrim(disp_line),D_INFO,D_LEFT,D_CLEAR)
		xcall ibc_input( auto_id, , auto_advice, , gold_sel_id, ,
		&             D_NOTERM,, fkeys[BLNK_FKEYS] )
		if( g_select.and.g_entnam .eq. 'J_QUIT' ) then
			quitting=TRUE
		else
			done=TRUE
	end
	until( quitting .OR. done )
	if(quitting) clear auto_advice
	set done, quitting, reject = false
	xcall e_exit
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;                               Setup Windows etc
	set_up,
	init add_part_passed

	if(%passed(pm_type).and.pm_type) then
		pass_gen_data.plan_maint=true
	else
		pass_gen_data.plan_maint=false

	if(pass_gen_data.plan_maint) then
		xcall syn_up( T$PM_TITLE )
	else
		xcall syn_up( T$PRG_TITLE )

	xcall cmpdep( cn, dt, reject )              ; get company/depot
	if(.not.reject)
	begin
		xcall get_globals(reject,D_COM_UPD,D_FCF_IN)
		xcall gldcom(gold_com)
		clear pos_part_info
	end

	if(.not.reject)
		call open_files

	if(.not.reject)
	begin
		if(pass_gen_data.plan_maint.eq.false)
		begin
			; doe - defect 111-01-1-233 - delivery note print only
			if(cms_user_id.eq.10687) then
				whgine_passed.f_del_note_only=%f_chk_access(35)
			else
				whgine_passed.f_del_note_only=false
			; doe  - defect 111-01-1-233 - do not allow invoice date outside currentr sl period
			if(cms_user_id.eq.10687) then
				whgine_passed.f_idat_in_sal_per_only=%f_chk_access(37)
			else
				whgine_passed.f_idat_in_sal_per_only=false

			xcall check_chrg_opt(D_CHGOPT_PLAN_MAINT,err, TRUE)
			if(.not.err)
			begin
				; find first pm wgd invoice type and use this as basis for the contract
				; if there is not one, return
				xcall file(pass_chn_data.chn(IVT_FILE), ivtrec,,'FS', err)
				repeat
				begin
					xcall file(pass_chn_data.chn(IVT_FILE), ivtrec,,'RS', err)
					if(err) exitloop
					if(ivtrec.ivt_prog_code.ne.P_PM_CONTRACT) nextloop
					if(ivtrec.ivt_pm_plant_link.ne.D_CMS_PM_WGD_OR_PLT_WGOOD) nextloop
					; WE HAVE FOUND THE FIRST VALID INVOICE TYPE TO
					; BE USED TO CREATE AN EQUIPMENT CONTRACT SO THIS
					; IS STORED AND USED AS A` FLAG ANFD ALSO TO ULTIMATELY
					; CREATE A CONTRACT
					pass_gen_data.pm_create_cont_ivt=ivtrec.ivt_type
					exitloop
				end
			end
		end

		; WG MULTIPLE DISCOUINTING IN USE
		if(.not. pass_gen_data.plan_maint) then
			f_wg_md_disc=cm5_wg_multi_disc
		else
			clear f_wg_md_disc
		h_cm5_wg_md_adv_def=cm5_wg_md_adv_mod
		h_cm4_cred_wg=cm4_cred_wg
		xcall gldcom( gold_com )
		gold_com.cur_dp[D_FC] = cms_base_dp
		gold_com.cur_dp[D_BC] = cms_base_dp

		call set_up_fkeys
		call load_windows

		xcall recvm(shortcut_key,err,"[SCUT]")
		if(.not.err) then
		begin
			h_shortcut=shortcut_key
			snd_job_no=h_short_stok
		end
		else
			clear shortcut_key

		if(cms_hort)            ; Create memory array for hort deliveries
		begin
			hid_lat = 0
			hid_max = 5
			hid_mhndl = %mem_proc( DM_ALLOC, hid_max*^size(ll_hidrec) )
			for loop from 1 thru hid_max
				clear ^m(ll_hidrec[loop],hid_mhndl),^m(ll_hidrec[loop].ll_loop,
				&         hid_mhndl)
		end

		if(cms_sal_per.ne.cms_pur_per)
			xcall ibc_message('Warning - Sales & Purchases are in different'
			&                   +' periods')
		; check for invoice type for self bills (also if vat codes set for sb for eire))
		if(.not.reject)
			call check_trade_in_inv_type
		pass_gen_data.adv_mode=D_AMD_MODE
		; open linked list to store line no's of deleted items
		xcall fs_init( 'LSTSCR.FNM', lst_chn )
		xcall ll_open( pass_chn_data.lst_cntrl, ^size(whgine_lst), lst_chn )
		; open linked list to store temp pmv records
		xcall fs_init( 'TMPPMV.FNM', pmv_chn )
		xcall ll_open( pmv_ctrl, ^size(pmvrec), pmv_chn )
		add_part_passed.pmv_cntrl = pmv_ctrl
		xcall fs_init('DELSCR.FNM', del_chn)
		xcall ll_open(del_cntrl, ^size(part_data), del_chn)
	end
	fin_tab_id=D_FIN_TAB_ID
	oip_tab_id=D_OIP_TAB_ID
	whgine_passed.stg_pay_tab_id=D_STG_PAY_TAB_ID
	sms_tab_id=D_SMS_TAB_ID
	if(.not.cms_doc_store)
	begin
		fin_tab_id-=1
		oip_tab_id-=1
		sms_tab_id-=1
		whgine_passed.stg_pay_tab_id-=1
	end
	if(.NOT. %golddoc_get_docno('SMSTXT') )
	begin
		fin_tab_id-=1
		oip_tab_id-=1
		whgine_passed.stg_pay_tab_id-=1
	end
	if(.not.whgine_passed.wgd_stg_proc_ids_grp.stage_inv_typ)
	begin
		fin_tab_id-=1
		oip_tab_id-=1
	end
	if(.NOT.(.not.pass_gen_data.plan_maint.and.cm4_wg_end_user_dets))
		fin_tab_id-=1

	if( reject ) then
		g_rtn = WR_QUIT_RTN
	else
		g_rtn = WR_GET_ADV

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_fkeys,
	for loop from 1 thru MAX_FKEYS
		clear fkeys[loop], fkeys[loop].fkmnu_id

	fkeys[INP_FKEYS].fkey[ D_FK_NO2] = T$FK_SKIP
	fkeys[INP_FKEYS].fkey[ D_FK_NO3] = T$FK_CANC

	fkeys[IAD_FKEYS].fkey[ D_FK_NO2] = T$FK_INS
	fkeys[IAD_FKEYS].fkey[ D_FK_NO3] = T$FK_AMD
	fkeys[IAD_FKEYS].fkey[ D_FK_NO4] = T$FK_DEL
	fkeys[IAD_FKEYS].fkey[ D_FK_NO7] = T$FK_NXT_ADV
	fkeys[IAD_FKEYS].fkey[ D_FK_NO8] = T$FK_PRV_ADV

	fkeys[ADD_FKEYS].fkey[ D_FK_NO2] = T$FK_SKIP
	fkeys[ADD_FKEYS].fkey[ D_FK_NO3] = T$FK_INS_OVR
	fkeys[ADD_FKEYS].fkey[ D_FK_NO4] = T$FK_FWD_REV
	fkeys[ADD_FKEYS].fkey[ D_FK_NO5] = T$FK_DL_LINE
	fkeys[ADD_FKEYS].fkey[ D_FK_NO6] = T$FK_DL_WORD
	fkeys[ADD_FKEYS].fkey[ D_FK_NO7] = T$FK_MV_WORD
	fkeys[ADD_FKEYS].fkey[ D_FK_NO8] = T$FK_CUST_ADD

	fkeys[HDR_FKEYS].fkey[D_FK_NO2] = T$FK_SKIP
	fkeys[HDR_FKEYS].fkey[D_FK_NO3] = T$FK_CANC
	fkeys[HDR_FKEYS].fkey[D_FK_NO4] = T$FK_DELIVER
	if(.not. pass_gen_data.plan_maint)
	begin
		fkeys[HDR_FKEYS].fkey[D_FK_NO5] = T$FK_CHG_INVTYP

		if(f_wg_md_disc.eq.D_CM5_WG_MD_YES_ADV_HDR)
			fkeys[HDR_FKEYS].fkey[D_FK_NO6] = T$FK_CHG_DISC
		fkeys[HDR_FKEYS].fkey[D_FK_NO7] = T$FK_PRV_TRD
	end
	;        fkeys[HDR_FKEYS].fkey[D_FK_NO8] = T$FK_SUPPORT

	fkeys[PRTINP_FKEYS].fkey[D_FK_NO4] = T$FK_OPTS
	fkeys[PRTINP_FKEYS].fkey[D_FK_NO5] = T$FK_ALT
	fkeys[PRTINP_FKEYS].fkey[D_FK_NO6] = T$FK_DELIVERY
	fkeys[PRTINP_FKEYS].fkey[D_FK_NO7] = T$FK_NXT
	fkeys[PRTINP_FKEYS].fkey[D_FK_NO8] = T$FK_PRV

	fkeys[PRTLST_FKEYS].fkey[D_FK_NO5] = T$FK_AP_OPTS
	fkeys[PRTLST_FKEYS].fkey[D_FK_NO6] = T$FK_PICK
	fkeys[PRTLST_FKEYS].fkey[D_FK_NO7] = T$FK_FIND
	fkeys[PRTLST_FKEYS].fkey[D_FK_NO8] = T$FK_CHG_DISC

	fkeys[SEQ_FKEYS].fkey[D_FK_NO2] = T$FK_INS

	fkeys[SEQ_FKEYS].fkey[D_FK_NO5] = T$FK_HIDE
	fkeys[SEQ_FKEYS].fkey[D_FK_NO5].scut_char = 'H'
	fkeys[SEQ_FKEYS].fkey[D_FK_NO6] = T$FK_HIDE_ALL
	fkeys[SEQ_FKEYS].fkey[D_FK_NO6].scut_char = 'A'
	fkeys[SEQ_FKEYS].fkey[D_FK_NO7] = T$FK_MOVEUP
	fkeys[SEQ_FKEYS].fkey[D_FK_NO8] = T$FK_MOVEDN

	fkeys[CMNT_INP_FKEYS].fkey[D_FK_NO7] = T$FK_NXT
	fkeys[CMNT_INP_FKEYS].fkey[D_FK_NO8] = T$FK_PRV

	fkeys[WGD_FKEYS].fkey[D_FK_NO5] = T$FK_WGD_ENQ
	fkeys[WGD_FKEYS].fkey[D_FK_NO6] = T$FK_TFR_ATT
	fkeys[WGD_FKEYS].fkey[D_FK_NO6].scut_char = 'f'
	fkeys[WGD_FKEYS].fkey[D_FK_NO7] = T$FK_NEW_TFR
	if(wg_security .ne. ACC_NO_COST_DISP)
		fkeys[WGD_FKEYS].fkey[D_FK_NO8] = T$FK_GRN

	fkeys[WGD_INP_FKEYS].fkey[D_FK_NO3] = T$FK_SER_AMD
	fkeys[WGD_INP_FKEYS].fkey[D_FK_NO3].scut_char = 'r'
	fkeys[WGD_INP_FKEYS].fkey[D_FK_NO4] = T$FK_SPC_WGD
	fkeys[WGD_INP_FKEYS].fkey[D_FK_NO5] = T$FK_CALC_SALES
	if(pass_gen_data.pm_create_cont_ivt) then
	begin
		fkeys[WGD_INP_FKEYS].fkey[D_FK_NO6] = T$FK_PMCNT
		fkeys[WGD_INP_FKEYS].fkey[D_FK_NO6].disabled_flg=0
	end
	else
	begin
		if(f_wg_md_disc)
			fkeys[WGD_INP_FKEYS].fkey[D_FK_NO6] = T$FK_CHG_DISC
	end
	if(wg_security .ne. ACC_NO_COST_DISP)
	begin
		fkeys[WGD_INP_FKEYS].fkey[D_FK_NO7] = T$FK_BON_NOM
		fkeys[WGD_INP_FKEYS].fkey[D_FK_NO8] = T$FK_PDI_REF
	end

	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO2] = T$FK_PRTS
	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO3] = T$FK_DELIVER
	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4] = T$FK_INV
	if(whgine_passed.f_del_note_only.eq.false)
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5] = T$FK_AUTO_ADV
	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO6] = T$FK_OVR_SAL
	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO6].scut_char = 'T'
	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO7] = T$FK_OVR_DSC
	fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8] = T$FK_FC_CURR

	fkeys[TRD_FKEYS].fkey[D_FK_NO6] = T$FK_WSTK_NO
	fkeys[TRD_FKEYS].fkey[D_FK_NO6].disabled_flg = TRUE
	fkeys[TRD_FKEYS].fkey[D_FK_NO7] = T$FK_PDI_CREATE

	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO4] = T$FK_SER_AMD
	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO4].scut_char = 'r'
	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO5] = T$FK_SPC_WGD
	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO6] = T$FK_COPY_WG
	; WG7465 - REPLACE J_OVER WITH J_NEW_MOD 	IE. O'ride with New Mod
	; WG7465        fkeys[TRD_INP_FKEYS].fkey[D_FK_NO7] = T$FK_OVERRIDE
	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO7] = T$FK_NEW_MOD	; WG7465
	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO7].disabled_flg = TRUE
	fkeys[TRD_INP_FKEYS].fkey[D_FK_NO8] = T$FK_PDI_INSTR

	fkeys[INP_ATD_FKEYS].fkey[D_FK_NO2] = T$FK_SKIP
	fkeys[INP_ATD_FKEYS].fkey[D_FK_NO3] = T$FK_FIRST
	fkeys[INP_ATD_FKEYS].fkey[D_FK_NO4] = T$FK_CANC
	fkeys[INP_ATD_FKEYS].fkey[D_FK_NO5] = T$FK_CALC_SALES
	fkeys[INP_ATD_FKEYS].fkey[D_FK_NO6] = T$FK_SPC_WGD

	fkeys[INV_CMNT_FKEYS].fkey[D_FK_NO3] = T$FK_AMD

	if(pass_gen_data.plan_maint) then
	begin
		fkeys[NSTK_INP_FKEYS].fkey[D_FK_NO3] = T$FK_CLK_PM
		fkeys[NSTK_INP_FKEYS].fkey[D_FK_NO4] = T$FK_SPC_PM
	end
	else
	begin
		fkeys[NSTK_INP_FKEYS].fkey[D_FK_NO4] = T$FK_SPC_WGD
		if(f_wg_md_disc)
			fkeys[NSTK_INP_FKEYS].fkey[D_FK_NO6] = T$FK_CHG_DISC
	end
	fkeys[NSTK_INP_FKEYS].fkey[D_FK_NO7] = T$FK_NXT
	fkeys[NSTK_INP_FKEYS].fkey[D_FK_NO8] = T$FK_PRV

	fkeys[W_TRK_FKEY].fkey[D_FK_NO5] = T$FK_TRK_PRT

	fkeys[FIN_FKEYS].fkey[ D_FK_NO2] = T$FK_SKIP
	fkeys[FIN_FKEYS].fkey[ D_FK_NO3] = T$FK_FIRST
	fkeys[FIN_FKEYS].fkey[ D_FK_NO4] = T$FK_CANC
	fkeys[FIN_FKEYS].fkey[ D_FK_NO5] = T$FK_FIN_DET

	; IF EIRE, DO NOT OFFER INVOICE OR CREDIT
	if(cms_country.ne.EIRE_VAT)
	begin
		fkeys[FIN_FKEYS].fkey[ D_FK_NO6] = T$FK_DEP_INV
		fkeys[FIN_FKEYS].fkey[ D_FK_NO7] = T$FK_DEP_CRD
	end
	fkeys[FIN_FKEYS].fkey[ D_FK_NO8] = T$FK_IMP_STY

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; get access modes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
	get_access,
	clear deletion_allowed, access_31_set
	xcall file( pass_chn_data.chn(ACC_FILE), access, user_init, 'RD', err, 1 )
	if( err ) then
		clear wsj_access
	else
	begin
		for loop from 1 thru 10
		begin
			; Find highest level less than 31
			if( acc_acc_codes(loop) .GT. wsj_access .AND. acc_acc_codes(loop) .LE. 30 )
				wsj_access = acc_acc_codes(loop)
			if( acc_acc_codes(loop) .eq. D_ACCESS_25 )
				deletion_allowed = TRUE
			if( acc_acc_codes(loop) .EQ. D_ACCESS_31 )
				access_31_set = TRUE
		end
		disp_balance = acc_disp_balance
	end
	hort_allowed = acc_part_amd .gt. 0

	xcall u_close( pass_chn_data.chn(ACC_FILE) )

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; set access modes ;;;;;;;;;;;;;;;;;;;;;;;;;;
;
	set_access,
	add_part_passed.edit_mode = D_VIEW_MODE
	add_part_passed.no_orders = true
	add_part_passed.inv_allowed = false

	if pass_gen_data.adv_mode .eq. D_VEW_MODE
		return

	case wsj_access of
	begincase
		D_ACCESS_26:
		begin
			add_part_passed.edit_mode = D_EDIT_PRI_RNG
		end
		D_ACCESS_27:
		begin
			add_part_passed.edit_mode = D_EDIT_MODE
		end
		D_ACCESS_28:
		begin
			add_part_passed.edit_mode = D_EDIT_PRI_RNG
		end
		D_ACCESS_29:
		begin
			add_part_passed.edit_mode = D_EDIT_MODE
		end
		D_ACCESS_30:
		begin
			add_part_passed.edit_mode = D_EDIT_MODE
			add_part_passed.inv_allowed = true
		end
	endcase

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_windows,
	cost_head=T$COST
	if(cms_currency)
	begin
		xcall s_bld(base_desc,,T$BRACKETS,cms_base_cur)
		cost_head(%trim(cost_head)+1:5)=base_desc
	end
	cost_head = %f_rjust(cost_head)

	xcall ibc_ldinp( key_vi_id, g_utlib, 'whgine_key',,,,,, fkeys[IAD_FKEYS])
	if(pass_gen_data.plan_maint)
	begin
		xcall u_ldwnd(selwd_id,g_utlib,'whgine_pm_iorc',D_NOPLC)
		xcall i_fldsel(key_vi_id,'vi_iorc',selwd_id,1,2)
	end

	clear wvi_user, wvi_user_mh
	wvi_plan_maint=pass_gen_data.plan_maint
	xcall i_user(key_vi_id, 'vi_job',,wvi_user )

	ivt_user.dsp_fldnam = 'vi_narr'
	if(pass_gen_data.plan_maint) then
		ivt_user.usr_chk = -7
	else
		ivt_user.usr_chk = 2
	xcall i_user(key_vi_id, 'vi_inv_typ',, ivt_user)
	if(pass_gen_data.plan_maint) then
	begin
		xcall ibc_ldinp( inp_vi_id, g_utlib, 'whgine_pm_hdr',D_CENTER_NOPLC,,,,,,D_NO_DEF_BTNS )
	end
	else
	begin
		xcall ibc_ldinp( inp_vi_id, g_utlib, 'whgine_hdr',D_CENTER_NOPLC,,,,,,D_NO_DEF_BTNS )
		if(wg_security .eq. ACC_NO_COST_DISP)
		begin
			xcall i_setdel(inp_vi_id, 'tot_set', 'inv_prof_v, inv_prof_p')
			xcall i_setdel(inp_vi_id, 'adv_set', 'inv_prof_v')
		end
		cmf_user.dsp_fldnam = 'vi_finnam'
		xcall i_user(inp_vi_id, 'vi_fcusacc',, cmf_user)
	end

	.ifdef D_GUI
		xcall w_proc( WP_RESIZE, inp_vi_id, 20, 78 )
	.endc
	cmf_user.dsp_fldnam = 'vi_cusnam'
	xcall i_user(inp_vi_id, 'vi_cusacc',, cmf_user)

	xcall ibc_ldinp(inp_hdr_id, g_utlib, 'whgine_hdr_tab', D_NOPLC,,,,TRUE,
	&               fkeys[HDR_FKEYS])
	xcall ibc_ldinp(hdr_cust_id, g_utlib, 'whgine_hdr_cust', D_NOPLC,,,,TRUE,,
	&               D_NO_DEF_BTNS)
	;        xcall w_brdr(inp_hdr_id, WB_TITLE, 'Header')
	xcall w_brdr(inp_hdr_id, WB_TITLE, 'Hdr')
	if cms_wg_sb_in_use .or.pass_gen_data.plan_maint
	begin
		xcall i_setdel(inp_hdr_id, 'tab_set', 'VI_NOT_SBILL')
		if pass_gen_data.plan_maint
		begin
			xcall i_setdel(inp_hdr_id, 'disp_set', 'VI_NOT_SBILL')
			xcall i_prompt(inp_hdr_id, 'VI_NOT_SBILL', '')
		end
	end
	; IF WG COMMISSION NOT IN USE THEN REMOVE COMMISSION BUYER SPLIT FIELD
	if(pass_gen_data.plan_maint.or..not.(cms_wg_comm.eq.TRUE.and.cm5_wc_split.eq.D_CM5_WC_SPLIT_MARKET_VALUE)) then
	begin
		f_wg_mv_comm=false
		xcall i_prompt(inp_hdr_id, 'VI_COMM_BUY_SP','')
		xcall i_setdel(inp_hdr_id, 'tab_set',  'VI_COMM_BUY_SP')
		xcall i_setdel(inp_hdr_id, 'disp_set', 'VI_COMM_BUY_SP')
	end
	else
	begin
		f_wg_mv_comm=true
	end
	if(.not. pass_gen_data.plan_maint) then
	begin
		xcall i_prompt(inp_hdr_id, 'VI_I_PM_CONTRACT','')
		xcall i_setdel(inp_hdr_id, 'tab_set',  'VI_I_PM_CONTRACT')
		xcall i_setdel(inp_hdr_id, 'disp_set', 'VI_I_PM_CONTRACT')
	end
	else
	begin
		xcall i_user(inp_hdr_id, 'vi_i_pm_contract',pmh_user )
		clear pmh_user, pmh_user_mh
		xcall i_user(inp_hdr_id, 'vi_i_pm_contract',,pmh_user )
		xcall pmh_user_clr(inp_hdr_id,'vi_i_pm_contract')
	end
	cmf_user.dsp_fldnam = 'vi_cusnam'
	cmf_user.chk_postcode = 1
	cmf_user.chk_new = 1
	xcall i_user(inp_hdr_id, 'vi_cust',, cmf_user)
	cmf_user.dsp_fldnam = 'vi_finnam'
	cmf_user.chk_allow_blank = 1
	cmf_user.ign_locks = TRUE
	xcall i_user(inp_hdr_id, 'vi_fcus',, cmf_user)

	xcall ibc_ldinp(inp_fin_id, g_utlib, 'whgine_fin_tab', D_NOPLC,,,,,
	&               fkeys[FIN_FKEYS])
	smf_user.chk_postcode = TRUE
	xcall i_user(inp_fin_id,'fin_px_fin_supp',,smf_user)
	xcall i_snapshot(D_COPY, inp_fin_id, fin_snap)

	if(.not.pass_gen_data.plan_maint.and.cm4_wg_end_user_dets)
	begin
		clear inp_oip_id
		xcall wgd_oip_ldinp(inp_oip_id,,fkeys[OIP_FKEYS], gold_com, gold_ax)
		; do not allow change of customer on oip screen in this routine
		; as it will be difficult to validate (currency, invoice type etc)
		xcall i_snapshot(D_COPY, inp_oip_id, oip_snap)
	end

	if(pass_gen_data.plan_maint) then
		h_seq_linp_name='whgine_pm_lst'
	else
		h_seq_linp_name='whgine_lst'

	xcall i_ldinp(seq_lnp_id, g_utlib, h_seq_linp_name, D_NOPLC)
	if(.not.pass_gen_data.plan_maint.and.
	&       wg_security .eq. ACC_NO_COST_DISP)
		xcall i_setdel(seq_lnp_id, 'full_set', 'lst_tot_cost')

	; sequence
	xcall lbc_create(seq_lst_id, seq_lnp_id, whgine_lst, g_utlib,
	&                'whgine_lst_cls',,, D_NOPLC,,,,, fkeys[SEQ_FKEYS])

	if(pass_gen_data.plan_maint) then
		xcall list_header(seq_lst_id, seq_lnp_id, T$SEQ_HDR_PM )
	else
		xcall list_header(seq_lst_id, seq_lnp_id, T$SEQ_HDR )

	; Wholegood list
	xcall i_ldinp(wgd_linp_id, g_utlib, 'whgine_wgdlst', D_NOPLC)
	if(wg_security .eq. ACC_NO_COST_DISP)
		xcall i_setdel(wgd_linp_id, 'full_set', 'vj_dsp_cost')

	;        xcall w_brdr(wgd_linp_id, WB_TITLE, '{WHOLEGD}')
	xcall w_brdr(wgd_linp_id, WB_TITLE, '{W}')

	xcall ibc_ldinp(pass_gen_data.inp_vj_id, g_utlib, 'whgine_iwgd', D_NOPLC,,,,,
	&               fkeys[WGD_INP_FKEYS])
	if(whgine_passed.vx_chn) then
		xcall i_fldmod(pass_gen_data.inp_vj_id,'VJ_MODEL',,, D_FLD_DRILL, 'vw_drill')
	else
		xcall i_fldmod(pass_gen_data.inp_vj_id,'VJ_MODEL',,, D_FLD_DRILL, '')

	if(%f_check_chrg_opt(D_CHGOPT_WG_COMM, true))
	begin
		xcall i_prompt(pass_gen_data.inp_vj_id, 'vj_vm_extra_comm',' ')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_inpset1', 'vj_vm_extra_comm')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset', 'vj_vm_extra_comm')
	end
	if(wg_security .eq. ACC_NO_COST_DISP) then
	begin
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset', 'vj_bc_ecos')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset', 'vj_bc_cost')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset', 'vj_fc_ecos')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset', 'vj_fc_cost')
	end
	else
	begin
		xcall i_prompt(pass_gen_data.inp_vj_id,'vj_bc_ecos'     ,'Est. Cost:')
		xcall i_prompt(pass_gen_data.inp_vj_id,'vj_bc_cost'     ,'Cost Price:')
	end

	if(f_wg_md_disc)
	begin
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_inpset1', 'vj_fc_disc')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_inpset1', 'vj_fc_vi_disc')
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_inpset1', 'vj_fc_sett')
	end

	xcall i_snapshot(D_COPY, pass_gen_data.inp_vj_id, wgd_snap)

	clear vm_user, ^i(vm_user.vm_user_mh)
	vm_user.chk_option = D_NOT_SOLD
	xcall i_user( pass_gen_data.inp_vj_id, 'vj_tstk',,vm_user )
	clear vw_user
	vw_user.allow_new = true
	vw_user.dsp_fldnam = 'VJ_MODEL'
	xcall i_user( pass_gen_data.inp_vj_id, 'vj_code',, vw_user )
	wgd_lst_id = %listiad_create(wgd_linp_id, 'whgine_wgd_cls',
	&       whgine_vj,,, 'IADNP', fkeys[WGD_FKEYS])

	xcall list_header(wgd_lst_id, wgd_linp_id,
	&                 'T|Stk No|Model|.Qty|.Cost|.Disc|.Sett|.Retail|' )

	xcall ibc_ldinp(pass_gen_data.inp_atd_id, g_utlib, 'whgine_atd', D_NOPLC, search,,,,
	&               fkeys[WGD_INP_FKEYS])
	if(wg_security .eq. ACC_NO_COST_DISP)
	begin
		xcall i_setdel(pass_gen_data.inp_atd_id, 'wgd_fullset', 'vj_fc_ecos, vj_fc_cost',
		&              'vj_atd_t_ecost, vj_atd_t_cost')
		xcall i_prompt(pass_gen_data.inp_atd_id,'vj_fc_ecos','')
		xcall i_prompt(pass_gen_data.inp_atd_id,'vj_fc_cost','')
		xcall i_prompt(pass_gen_data.inp_atd_id,'vj_atd_t_ecost','')
		xcall i_prompt(pass_gen_data.inp_atd_id,'vj_atd_t_cost','')
	end

	xcall ibc_ldinp(vb_atd_id, g_utlib, 'whgine_vb_atd', D_NOPLC, search,,,,
	&               fkeys[TRD_INP_FKEYS])

	; 200-00-818105. note that the error reported was crash where if the user
	; was set to NOT display costs, the routine attempted to setdel
	; attachment cost fields.  The field names were wrong and referred to
	; main wgd attachments instead of trade in ones.  But the thing with trade
	; ins is that the trade in price is the cost and the user need to be able
	; to enter this.  Therefore, treating the attachment costs the same.
	; I have chosen to comment this out having first corrected the fields
	; included  in the setdel.  Furthermore, it seemed silly to not display
	; the fields on the attachment screen but then show them on the trade in list.
; 200-00-818105. 	if(wg_security == ACC_NO_COST_DISP)
; 200-00-818105. 	begin
; 200-00-818105. 		xcall i_setdel(vb_atd_id, 'wgd_fullset',
; 200-00-818105. 		&			  'vb_atd_ecos_curr, vb_atd_cost_curr',
; 200-00-818105. 		&			  'vb_tip_bc, vb_net_bc',
; 200-00-818105. 		&			  'vb_atd_t_ecost,  vb_atd_t_cost',
; 200-00-818105. 		&             'vj_atd_t_ecost, vj_atd_t_cost')
; 200-00-818105. 	end
	xcall i_snapshot(D_COPY, pass_gen_data.inp_atd_id, atd_snap)

	if(pass_gen_data.plan_maint) then
	begin
		; Non stock list
		xcall i_ldinp(nstk_linp_id, g_utlib, 'whgine_nslst_pm', D_NOPLC)

		xcall w_brdr(nstk_linp_id, WB_TITLE, 'Equipment')

		xcall ibc_ldinp(inp_nstk_id, g_utlib, 'whgine_i_pm_ent', D_NOPLC,,,
		&               ,, fkeys[NSTK_INP_FKEYS])
		xcall ibc_ldinp(inp_nstk_clk_id, g_utlib, 'whgine_pm_clk', D_NOPLC,,,
		&               ,,,D_NO_DEF_BTNS )
		xcall SetParent(inp_nstk_id, inp_nstk_clk_id)
		whgine_passed.h_cm5_pm_est_clock=cm5_pm_est_clock
	end
	else
	begin
		; Non stock list
		xcall i_ldinp(nstk_linp_id, g_utlib, 'whgine_nstklst', D_NOPLC)

		xcall w_brdr(nstk_linp_id, WB_TITLE, 'Non Stk')

		xcall ibc_ldinp(inp_nstk_id, g_utlib, 'whgine_instk', D_NOPLC,,,
		&               ,, fkeys[NSTK_INP_FKEYS])
		if(whgine_passed.vx_chn) then
			xcall i_fldmod(inp_nstk_id,'VJ_MODEL',,, D_FLD_DRILL, 'vw_drill')
		else
			xcall i_fldmod(inp_nstk_id,'VJ_MODEL',,, D_FLD_DRILL, '')

		xcall ibc_disable(inp_nstk_id, 'vj_type_alw',
		&           'vj_grpdes, vj_makdes')

	end

	if(.not. pass_gen_data.plan_maint)
	begin
		if cms_gnavsk
			xcall ibc_disable(inp_nstk_id, 'vj_tstk')

		if(wg_security .eq. ACC_NO_COST_DISP) then
		begin
			xcall i_setdel(nstk_linp_id,'full_set', 'vj_fc_cost')

			xcall i_setdel(inp_nstk_id, 'nstk_fullset', 'vj_bc_ecos')
			xcall i_setdel(inp_nstk_id, 'nstk_fullset', 'vj_bc_cost')
			xcall i_setdel(inp_nstk_id, 'nstk_fullset', 'vj_fc_ecos')
			xcall i_setdel(inp_nstk_id, 'nstk_fullset', 'vj_fc_cost')
		end
		else
		begin
			xcall i_prompt(inp_nstk_id,'vj_bc_ecos'     ,'Est. Cost:')
			xcall i_prompt(inp_nstk_id,'vj_bc_cost'     ,'Cost Price:')
		end
		if(f_wg_md_disc)
		begin
			xcall i_setdel(inp_nstk_id, 'nstk_inpset3', 'vj_fc_disc')
			xcall i_setdel(inp_nstk_id, 'nstk_inpset3', 'vj_fc_vi_disc')
			xcall i_setdel(inp_nstk_id, 'nstk_inpset3', 'vj_fc_sett')
		end
	end
	xcall i_snapshot(D_COPY, inp_nstk_id, nstk_snap)
	clear vw_user
	vw_user.allow_new = true
	xcall i_user(inp_nstk_id, 'vj_code',, vw_user)

	clear vm_user, vm_user.vm_user_mh
	vm_user.chk_option = D_NOT_SOLD
	if(.not. pass_gen_data.plan_maint)
	begin
		xcall i_user( inp_nstk_id, 'vj_tstk',,vm_user )
		clear vg_user
		vg_user.usr_depot = gold_com.cur_depot
		vg_user.dsp_fldnam = 'vj_grpdes'
		xcall i_user( inp_nstk_id, 'vj_grp',,vg_user )

		clear user_data
		user_data.dsp_fldnam = 'vj_makdes'
		xcall i_user( inp_nstk_id, 'vj_mak',,user_data )
	end
	nstk_lst_id = %listiad_create(nstk_linp_id, 'whgine_nstk_cls',
	&       whgine_vj,,, 'IADNP', fkeys[NSTK_FKEYS])

	if(pass_gen_data.plan_maint) then
		xcall list_header(nstk_lst_id, nstk_linp_id, 'Eqp No|Model||.Disc|.Sett|.Retail' )
	else
		xcall list_header(nstk_lst_id, nstk_linp_id, 'Stk No|Model|.Cost|.Disc|.Sett|.Retail' )

	; Comment list
	xcall i_ldinp(cmnt_linp_id, g_utlib, 'whgine_cmnt', D_NOPLC)

	xcall ibc_ldinp(cmnt_iwnd_id, g_utlib, 'whgine_icmnt', D_NOPLC,,,,,
	&               fkeys[CMNT_INP_FKEYS])
	cmnt_lst_id = %listiad_create(cmnt_linp_id, 'whgine_cmnt_cls',
	&       whgine_cmnt_lst,,, 'IADNP', fkeys[CMNT_FKEYS])

	xcall list_header(cmnt_lst_id, cmnt_linp_id, 'Comment|' )

	; SETS CERTAIN ADD_PART_PASSED FIELDS NECESSARY
	; FOR ADD_PART_CREATE TO WORK CORRECTLY
	call set_access

	; parts
	view_bin = true
	prt_lst_id = %add_part_create(gold_com, gold_ax, add_part_passed,
	&       'whgine_prt_cls',,, fkeys[PRTLST_FKEYS], fkeys[PRTINP_FKEYS])

	; invoice
	xcall ibc_ldinp(inp_bal_id, g_utlib, 'whgine_invt', D_NOPLC,,,,,
	&               fkeys[INV_TAB_FKEYS], D_NO_DEF_BTNS)

	if(wg_security .eq. ACC_NO_COST_DISP.or. pass_gen_data.plan_maint)
	begin
		xcall i_setdel(inp_bal_id, 'full_set',
		&   'ADV_T_COST,ADV_T_MRG,ADV_T_MRG_PCNT',
		&   'PRT_T_COST,PRT_T_MRG,PRT_T_MRG_PCNT',
		&   'ADV_TOT_COST, ADV_TOT_MRG, ADV_TOT_MRG_PCNT')
		if(.not. pass_gen_data.plan_maint)
			xcall i_setdel(inp_bal_id, 'full_set',
			&   'SB_T_COST_FC,SB_T_MRG,SB_T_MRG_PCNT')
	end
	if(pass_gen_data.plan_maint)
	begin
		xcall ibc_prompt(inp_bal_id,'ADV_T_COST',' ')
		xcall ibc_prompt(inp_bal_id,'ADV_T_MRG',' ')
		xcall ibc_prompt(inp_bal_id,'ADV_T_MRG_PCNT',' ')

		xcall ibc_prompt(inp_bal_id,'ADV_LINE_COUNT','Eqp')

		xcall ibc_prompt(inp_bal_id,'SB_LINE_COUNT','')
		xcall i_setdel(inp_bal_id, 'full_set','SB_LINE_COUNT')
		xcall i_setdel(inp_bal_id, 'full_set','SB_T_RETAIL')
		xcall i_setdel(inp_bal_id, 'full_set','SB_T_DISC')
		xcall i_setdel(inp_bal_id, 'full_set','SB_T_COST_FC')
		xcall i_setdel(inp_bal_id, 'full_set','SB_T_MRG')
		xcall i_setdel(inp_bal_id, 'full_set','SB_T_MRG_PCNT')

		xcall ibc_prompt(inp_bal_id,'ADV_DEPOSIT_TOTAL','')
		xcall i_setdel(inp_bal_id, 'full_set','ADV_DEPOSIT_TOTAL')

		xcall ibc_prompt(inp_bal_id,'ADV_PX_FIN_SETT','')
		xcall i_setdel(inp_bal_id, 'full_set','ADV_PX_FIN_SETT')

		xcall ibc_prompt(inp_bal_id,'ADV_TO_PAY','')
		xcall i_setdel(inp_bal_id, 'full_set','ADV_TO_PAY')

		xcall ibc_prompt(inp_bal_id,'ADV_T_ORIG_RRP','Model RRP')
	end
	if (cms_sal_age) then
	begin
		xcall i_prompt(inp_bal_id,'MTH3_FC','Mth2+')
		xcall i_prompt(inp_bal_id,'MTH2_FC','Mth1')
		xcall i_prompt(inp_bal_id,'MTH1_FC','Cur')
		xcall i_prompt(inp_bal_id,'CUR_FC' ,'Fut')
	end
	else
	begin
		xcall i_prompt(inp_bal_id,'MTH3_FC','Mth3+')
		xcall i_prompt(inp_bal_id,'MTH2_FC','Mth2')
		xcall i_prompt(inp_bal_id,'MTH1_FC','Mth1')
		xcall i_prompt(inp_bal_id,'CUR_FC' ,'Cur')
	end
	; trade in list
	xcall i_ldinp(trd_linp_id, g_utlib, 'whgine_trdlst', D_NOPLC)

	xcall w_brdr(trd_linp_id, WB_TITLE, 'Trd In')

	xcall ibc_ldinp(pass_gen_data.inp_vb_id, g_utlib, 'whgine_itrd', D_NOPLC,,,,,
	&               fkeys[TRD_INP_FKEYS])
	if(whgine_passed.vx_chn) then
		xcall i_fldmod(pass_gen_data.inp_vb_id,'VB_TMOD',,, D_FLD_DRILL, 'vw_drill')
	else
		xcall i_fldmod(pass_gen_data.inp_vb_id,'VB_TMOD',,, D_FLD_DRILL, '')

	clear vm_user, vm_user.vm_user_mh
	vm_user.chk_option = D_ON_HIST
	vm_user.chk_allow_create = true
	xcall i_user( pass_gen_data.inp_vb_id, 'vb_tstk',,vm_user )
	clear vg_user
	vg_user.usr_depot = gold_com.cur_depot
	vg_user.dsp_fldnam = 'vb_grpdes'
	xcall i_user( pass_gen_data.inp_vb_id, 'vb_grp',,vg_user )
	clear user_data
	user_data.dsp_fldnam = 'vb_makdes'
	xcall i_user( pass_gen_data.inp_vb_id, 'vb_mak',,user_data )
	clear vw_user
	vw_user.allow_new = true
	xcall i_user( pass_gen_data.inp_vb_id, 'vb_code',, vw_user)
	xcall i_snapshot(D_COPY, pass_gen_data.inp_vb_id, trd_snap)

	trd_lst_id = %listiad_create(trd_linp_id, 'whgine_trd_cls',
	&       whgine_vb,,, 'IAD', fkeys[TRD_FKEYS])

	xcall list_header(trd_lst_id, trd_linp_id,
	&                 'T|Stk No|Model|.Qty|.Trade In|.OverAllow|.Nett Stk|.Retail' )


	; attachment list
	xcall ibc_ldinp( disp_att_lst_id, g_utlib, 'whgine_att_lst', D_NOPLC )

	xcall lbc_create(det_att_lst_id, disp_att_lst_id, whgine_att_lst,g_utlib,
	&         'whgine_att_cls', , , D_NOPLC, TRUE, 1, 1 )
	xcall AssignNewStandardWindowEvents(det_att_lst_id,true)
	if(cms_country.eq.SAUDI_ARABIA.or.cms_country.eq.NO_VAT) then
		xcall s_bld(disp_line,,T$ATT_LST_HEAD,' ',cost_head)
	else
		xcall s_bld(disp_line,,T$ATT_LST_HEAD,'VAT',cost_head)
	xcall list_header( det_att_lst_id,disp_att_lst_id,%atrim(disp_line))

	; invoice comment
	xcall ibc_ldwnd(inv_cmnt_id, g_utlib, '', D_NOPLC,
	&               , err,'ist_tab_cmnt', true, fkeys[INV_CMNT_FKEYS], D_NO_DEF_BTNS)
	xcall w_brdr( inv_cmnt_id, WB_TITLE, "Inv Cmnt" )

	; tabs
	gold_com.tabset_id = %ibctab_create('whgine_tab', TAB_HEIGHT, 78, '|',
	&                       '',, gold_com.tabhdr_id, tabmnu_ctrl)
	xcall SetParent(inp_vi_id, gold_com.tabset_id)
	xcall w_brdr(gold_com.tabset_id, WB_OFF)

	xcall ibctab_add(DTS_WINDOW, gold_com.tabset_id, inp_hdr_id,
	&                 'whgine_proc_hdr',,
	&                 'Header Details'
	&                 , 'H', gold_com.tabhdr_id,
	&                 tabmnu_ctrl)

	xcall ibctab_add(DTS_LIST, gold_com.tabset_id, seq_lst_id,
	&                 'whgine_proc_seq',,
	&                 'Sequence Tab showing all items - Move, Hide lines'
	&                 , 'e', gold_com.tabhdr_id,
	&                 tabmnu_ctrl)

	if(.not. pass_gen_data.plan_maint)
	begin
		xcall ibctab_add(DTS_LIST, gold_com.tabset_id, wgd_lst_id,
		&             'whgine_proc_wgd',,
		&             '{WHOLEGD} items with transfer options available'
		&             , 'W', gold_com.tabhdr_id,
		&             tabmnu_ctrl)

		xcall ibctab_add(DTS_LIST, gold_com.tabset_id, nstk_lst_id,
		&                 'whgine_proc_nstk',,
		&                 'Non Stocked {WHOLEGD} items'
		&                 , 'N', gold_com.tabhdr_id,
		&                 tabmnu_ctrl)
	end
	else
		xcall ibctab_add(DTS_LIST, gold_com.tabset_id, nstk_lst_id,
		&             'whgine_proc_nstk',,
		&             'Non Stocked {WHOLEGD} items'
		&             , 'u', gold_com.tabhdr_id,
		&             tabmnu_ctrl)
	xcall ibctab_add(DTS_LIST, gold_com.tabset_id, prt_lst_id,
	&                'whgine_proc_prt',,
	&                'Parts Tab'
	&                , 'a', gold_com.tabhdr_id,
	&                tabmnu_ctrl)

	xcall ibctab_add(DTS_WINDOW, gold_com.tabset_id, inp_bal_id,
	&                 'whgine_proc_inv',,
	&                 'Invoice Tab including printing options'
	&                 , 'I', gold_com.tabhdr_id,
	&                 tabmnu_ctrl)

	xcall ibctab_add(DTS_LIST, gold_com.tabset_id, cmnt_lst_id,
	&                 'whgine_proc_cmnt',,
	&                 'Comment Line Tab'
	&                 , 'L', gold_com.tabhdr_id,
	&                 tabmnu_ctrl)

	if(.not. pass_gen_data.plan_maint)
		xcall ibctab_add(DTS_LIST, gold_com.tabset_id, trd_lst_id,
		&                 'whgine_proc_trd',,
		&                 'Trade In Tab'
		&                 , 'T', gold_com.tabhdr_id,
		&                 tabmnu_ctrl)

	xcall ibctab_add(DTS_WINDOW, gold_com.tabset_id, inv_cmnt_id,
	&                 'whgine_proc_inv_cmnt',,
	&                 'Invoice Comment Tab'
	&                 , 'C', gold_com.tabhdr_id,
	&                 tabmnu_ctrl)

	if( cms_doc_store )
	begin
		init doc_search
		doc_lst_id = %GetDocList(fkeys[DOC_FKEYS], true , 'whgine_doc_cla', doc_search)
		xcall ibctab_add(DTS_LIST, gold_com.tabset_id, doc_lst_id,
		&            'whgine_proc_docs',,'Document Store Tab',
		&            'D', gold_com.tabhdr_id, tabmnu_ctrl)
	end

	if( %golddoc_get_docno('SMSTXT') )
	begin
		sms_lst_id = %GetSMSList( fkeys[SMS_FKEYS], true, 'whgine_sms_cla')
		xcall ibctab_add(DTS_LIST, gold_com.tabset_id, sms_lst_id,
		&		 'whgine_proc_sms',,T$SMS_TIP , 'x', gold_com.tabhdr_id, tabmnu_ctrl)
	end

	if(.not. pass_gen_data.plan_maint.and.%wgd_stg_check_in_use)
	begin
		reject = %wgd_stg_create(false, gold_com, gold_ax, whgine_passed.wgd_stg_proc_ids_grp,
		&                 fkeys[STG_LST_FKEYS], fkeys[STG_INP_FKEYS],'WHGINE_PROC_STG_PAY',tabmnu_ctrl)
	end

	if(.not. pass_gen_data.plan_maint.and.cm4_wg_end_user_dets)
		xcall ibctab_add(DTS_WINDOW, gold_com.tabset_id, inp_oip_id,
		&                 'whgine_proc_oip',,'Other Interested Parties data'
		&                 , 'O', gold_com.tabhdr_id,
		&                 tabmnu_ctrl)

	tabmnu_ctrl_cop=tabmnu_ctrl

	xcall SetParent(inp_hdr_id, hdr_cust_id)
	xcall ibc_window(D_PLACE, hdr_cust_id, 9, 39)

	if(cms_country.eq.SAUDI_ARABIA.or.cms_country.eq.NO_VAT)
	begin
		xcall i_prompt(inp_hdr_id,  'vi_vatable', ' ')
		xcall i_prompt(inp_hdr_id,  'vi_vatreg' , ' ')
		xcall i_setdel(inp_hdr_id, 'disp_set', 'vi_vatable, vi_vatreg')
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       the finance tab is conditional on the transaction being
        ;       invoice tx only - all other suppressed
	set_unset_finance_tab,

	tabmnu_ctrl=tabmnu_ctrl_cop
	if(.not. pass_gen_data.plan_maint)
	begin

		if(vi_iorc.le.D_VIIVCR_CREDIT.and.pass_chn_data.h_prog_code.ne.P_COD_SEL_BILL) then
		begin
			call add_finance_tab
		end
		else
		begin
			if(%ts_tabset(DTS_NUMTABS, gold_com.tabset_id).eq.fin_tab_id)
				xcall ts_tabset(DTS_REMOVE, gold_com.tabset_id, fin_tab_id)
		end
	end
	.ifndef D_GUI
		xcall mb_end(tabmnu_ctrl, tabmnu_id)
	.endc
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	add_finance_tab,
	xcall i_snapshot(D_LOAD, inp_fin_id, fin_snap)

	; ADDED EIRE REGARDING VAT ON DEPOSITS AS VAT ON DEPOSITS IS NOT
	; APPLICABLE TO THEM
	if(pass_chn_data.h_prog_code.eq.P_COD_MACH_NO_SPC_TI.or.
	&  cms_country.eq.EIRE_VAT) then
	begin
		xcall i_init( inp_fin_id )
		xcall i_setdel(inp_fin_id, 'disp_set',
		&            'fin_deposit_total,fin_deposit_vat,fin_dep_inv_no,fin_dep_inv_date')
		xcall i_setdel(inp_fin_id, 'tot_set',
		&          'fin_deposit_total,fin_deposit_vat')
		xcall i_setdel(inp_fin_id, 'tab_set',
		&          'fin_deposit_total')
		xcall i_prompt(inp_fin_id,'fin_deposit_vat','')
		xcall i_prompt(inp_fin_id,'fin_deposit_total','')
		xcall i_prompt(inp_fin_id,'fin_dep_inv_no','')
		xcall i_fldmod(inp_fin_id,'fin_deposit_amt',,,D_FLD_INFO,
		&              'Enter Deposit Amount inclusive of VAT if applicable')
	end
	else
	begin
		xcall i_prompt(inp_fin_id,'fin_deposit_vat','Deposit VAT Amount:')
		xcall i_prompt(inp_fin_id,'fin_deposit_total','Deposit Total:')
		xcall i_prompt(inp_fin_id,'fin_dep_inv_no','Inv.No:')
		xcall i_fldmod(inp_fin_id,'fin_deposit_amt',,,D_FLD_INFO,
		&              'Enter Deposit Amount')
	end

	if(%ts_tabset(DTS_NUMTABS, gold_com.tabset_id).ne.fin_tab_id)
	begin
		xcall ibctab_add(DTS_WINDOW, gold_com.tabset_id, inp_fin_id,
		&                 'whgine_proc_fin',,
		&                 'Finance Tab'
		&                 , 'F', gold_com.tabhdr_id,
		&                 tabmnu_ctrl)
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;                               Open Files
	open_files,
	filnam(VM_FILE) = vmfile
	filtyp(VM_FILE) = D_FNAM_UDS
	filmod(VM_FILE) = D_ISM_UPD

	filnam(HM_FILE) = hmfile
	filtyp(HM_FILE) = D_FNAM_UDS
	filmod(HM_FILE) = D_ISM_UPD

	filnam(VI_FILE) = vifile
	filtyp(VI_FILE) = D_FNAM_UDS
	filmod(VI_FILE) = D_ISM_UPD

	filnam(VJ_FILE) = vjfile
	filtyp(VJ_FILE) = D_FNAM_UDS
	filmod(VJ_FILE) = D_ISM_UPD

	filnam(VB_FILE) = vbfile
	filtyp(VB_FILE) = D_FNAM_UDS
	filmod(VB_FILE) = D_ISM_UPD

	filnam(VD_FILE) = vdfile
	filtyp(VD_FILE) = D_FNAM_UDS
	filmod(VD_FILE) = D_ISM_UPD

	filnam(PDF_FILE) = pdfile
	filmod(PDF_FILE) = D_ISM_UPD

	filnam(CAT_FILE) = catfil
	filtyp(CAT_FILE) = D_FNAM_NO_FRMT

	filnam(VK_FILE) = vkfile
	filtyp(VK_FILE) = D_FNAM_UDS

	filnam(VW_FILE) = vwfile
	filtyp(VW_FILE) = D_FNAM_UDS
	filmod(VW_FILE) = D_ISM_UPD

	filnam(VA_FILE) = vafile
	filtyp(VA_FILE) = D_FNAM_UDS

	filnam(HW_FILE) = hwfile
	filtyp(HW_FILE) = D_FNAM_UDS
	filmod(HW_FILE) = D_ISM_UPD

	filnam(VGF_FILE) = vgfile
	filnam(PRE_FILE) = pefile
	filnam(IVT_FILE) = itfile
	filnam(CMF_FILE) = cmfile
	filmod(CMF_FILE) = D_ISM_UPD

	filnam(PMF_FILE) = pmfile
	filnam(NMF_FILE) = nmfile

	filnam(DMF_FILE) = dmfil
	filmod(DMF_FILE) = D_FIL_IN

	filnam(SRP_FILE) = srpfile

	filnam(SMF_FILE) = smfile

	filnam(IVH_FILE) = ihfile

	filnam(CTF_FILE) = ctfile
	filmod(CTF_FILE) = D_ISM_UPD

	filnam(CTH_FILE) = cthfile

	filnam(VQ_FILE) = vqfile
	filtyp(VQ_FILE) = D_FNAM_UDS
	filmod(VQ_FILE) = D_ISM_UPD

	filnam(ACC_FILE) = acfile
	filtyp(ACC_FILE) = D_FNAM_NO_FRMT

	filnam(VS_FILE) = vsfile
	filtyp(VS_FILE) = D_FNAM_UDS

	filnam(PMH_FILE) = pmhfile
	filmod(PMH_FILE) = D_ISM_UPD
	filnam(PML_FILE) = pmlfile
	filmod(PML_FILE) = D_ISM_UPD
	filnam(PMD_FILE) = pmdfile
	filmod(PMD_FILE) = D_ISM_UPD
	filnam(PMG_FILE) = pmgfile
	filnam(PMC_FILE) = pmcfile
	filnam(PMM_FILE) = pmmfile

	filnam(VA_FILE) = vafile
	filtyp(VA_FILE) = D_FNAM_UDS
	filnam(IHH_FILE) = ihhfile
	filnam(WQL_FILE) = wqlfile
	filmod(WQL_FILE) = D_ISM_UPD

	xcall open_files( FILE_NUM, filnam, filmod, filtyp, pass_chn_data.chn, reject)

	if(.not.reject)
	begin
		dp_pdf_chn = pass_chn_data.chn(PDF_FILE)
		xcall vxfmnt_create_vxf_file(vx_chn)

		xcall file( g_com_chn, cm4rec, 4, 'RN', err,,,,,D_NO_LOCK)
		xcall file( g_com_chn, cm5rec, 5, 'RN', err,,,,,D_NO_LOCK)

		; If Hort TRUE open files
		if (cms_hort)
			call open_hort_files

		call get_access
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;;;;    Open Hort Files
	open_hort_files,
	filename = hidfile
	filename(8:3) = cn, 'XXX'
	xcall u_open( g_hid_chn, 'u:i', filename,, search, reject )
	if (reject)
	begin
		xcall s_bld( disp_line, , 'Error %d opening %a', reject, hidfile )
		xcall ibc_message( disp_line )
	end

	filename = hpdfile
	filename(8:3) = cn, 'XXX'
	xcall u_open( g_hpd_chn, 'u:i', filename,, search, reject )
	if (reject)
	begin
		xcall s_bld( disp_line, , 'Error %d opening %a', reject, hpdfile )
		xcall ibc_message( disp_line )
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	shutdown,
	if vj_line1_id
	begin
		xcall w_proc(WP_DELETE, vj_line1_id)
		xcall w_proc(WP_DELETE, vj_line2_id)
	end
	if vb_line1_id
	begin
		xcall w_proc(WP_DELETE, vb_line1_id)
		xcall w_proc(WP_DELETE, vb_line2_id)
	end
	; WG6825 - The routine was crashing under some circumstances as prt_lst_id
	; was set to 538976288.  The problem was that the add_part_create routine
	; had not yet been run.  Could only artificially recreate this by moving
	; one of the files specified in open files forcing the routine to
	; prematurely exit.
	if(prt_lst_id.and.prt_lst_id.le.999999)
		xcall add_part_destroy(add_part_passed)

	if(lst_chn)
		xcall fs_quit(lst_chn)
	if(pmv_chn)
		xcall fs_quit(pmv_chn)
	if(del_chn)
		xcall fs_quit(del_chn)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	check_trade_in_inv_type,
	clear sb_inv_type
	xcall file(pass_chn_data.chn(IVT_FILE),ivtrec,,'FS',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(IVT_FILE),ivtrec,,'RS',err)
		if(err) exitloop
		if(ivt_prog_code.ne.P_COD_SEL_BILL)
			nextloop
		sb_inv_type=ivt_type
		exitloop
	end
	if(.not.sb_inv_type)
	begin
		xcall ibc_message('Cannot Continue - Self Billing Invoice Type '
		&               +'Not Available')
		reject = TRUE
	end
	if(.not.reject.and.cms_country.eq.EIRE_VAT)
		call validate_eire_vat
	; establish default vat code for self billers for trade ins if the trade
	; in is not the main part of the advice
	if(.not.reject)
	begin
		sb_eire_vat_code=ivt_vat_code
		sb_eire_vat_zero=ivt_vat_zero
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       validate the advice number entered or control search
	validate_advice,
	call process_validation
	if(! done)
		xcall i_init(key_vi_id, 'adv_set', whgine_vi_grp,'vi_job')
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	process_validation,
	done = false
	if(.not.vi_job.and.pass_gen_data.adv_mode.eq.D_INS_MODE) then
	begin
		if(cms_gngvad) then
		begin
			vi_job=T$AUTO
			clear virec
			xcall i_dspfld(inp_vi_id,'vi_job',vi_job)
			done=TRUE
		end
		else
		begin
			xcall ibc_message('Please enter a new Advice Note Number')
		end
		return
	end
	if(.not.vi_job) then
		err=1
	else
		xcall file(pass_chn_data.chn(VI_FILE),virec,vi_job,'RD',err,,vi_rfa,,,D_NO_LOCK)
	if(err)
	begin
		if(pass_gen_data.adv_mode == D_INS_MODE)
		begin
			if(%i_checkdata(key_vi_id, 'adv_set', whgine_vi_grp) )
				done=TRUE
			clear virec
		end
		return
	end

	xcall file(pass_chn_data.chn(VI_FILE),virec,,'RD',err,,,f_lock_vi,vi_rfa)
	if(f_lock_vi || err)
		return

	; AFTER SUCCESSFUL READ
	done=TRUE               ; ASSUME OK INITIALLY UNTIL DISPROVEN

	if(whgine_passed.f_del_note_only.eq.false) then
	begin
		; IF THE ADVICE FOR ANOTHER DEPOT, ONLY LET THE USER VIEW
		if(vi_depot.ne.dt)
		begin
			disp_line='Invalid - This advice belongs to depot '+vi_depot+
			&               ' - View?'
			if(%f_yes_no(%atrim(disp_line)).eq.TRUE) then
				pass_gen_data.adv_mode=D_VEW_MODE
			else
				done=false
			return
		end
	end
	else
		pass_gen_data.adv_mode=D_VEW_MODE

	case pass_gen_data.adv_mode of
	begincase
		D_DEL_MODE:   begin                             ; DELETE MODE
			if(vistat.ge.D_ADV_INVOICED) then
			begin
				disp_line='Invalid to Delete as Advice is Invoiced - View?'
				if(%f_yes_no(%atrim(disp_line)).eq.TRUE) then
					pass_gen_data.adv_mode=D_VEW_MODE
				else
					done=false
			end
			else            ; check if any lines exist and if
			begin         ; so reject but allow amend
				xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vijob,'RD',err,,,,,D_NO_LOCK)
				if(err)
					xcall file(pass_chn_data.chn(VB_FILE),vbrec,vijob,'RD',err,,,,,D_NO_LOCK)
				if(.not.err)
				begin
					disp_line='Invalid - Lines Exists On This Advice - Amend?'
					if(%f_yes_no(%atrim(disp_line)).eq.TRUE) then
						pass_gen_data.adv_mode=D_AMD_MODE
					else
						done=false
				end
			end
		end
		D_AMD_MODE:   begin                             ; AMEND MODE
			if(vistat.ge.D_ADV_INVOICED)
			begin
				if(snd_job_no) then
				begin
					pass_gen_data.adv_mode=D_VEW_MODE
				end
				else
				begin
					if(%f_yes_no('Advice Already Invoiced - View?')
					&                             .eq.TRUE) then
						pass_gen_data.adv_mode=D_VEW_MODE
					else
						done=false
				end
			end
		end
		D_INS_MODE:   begin                             ; INSERT MODE
			disp_line='Advice Already Exists'
			if(vistat.ge.D_ADV_INVOICED) then
				disp_line(%trim(disp_line)+2:23)='and is Invoiced - View?'
			else
				disp_line(%trim(disp_line)+2:9)='- Amend?'

			if(%f_yes_no(%atrim(disp_line)).eq.TRUE) then
			begin
				if(vistat.ge.D_ADV_INVOICED) then
					pass_gen_data.adv_mode=D_VEW_MODE
				else
					pass_gen_data.adv_mode=D_AMD_MODE
			end
			else
				done=false
		end
	endcase

	if(pass_gen_data.adv_mode.eq.D_AMD_MODE)
	begin
		call check_currency
		call check_depot_transfer_required
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       display top line of screen showing mode
	display_mode,
	if pass_gen_data.adv_mode .eq. D_INS_MODE then
	begin
		xcall ibc_enable(key_vi_id, 'vi_job, vi_iorc, vi_inv_typ, vi_narr')
		if(cms_gngvad) then
			xcall i_fldmod(key_vi_id, 'vi_job',,, D_FLD_DRILL, ' ', D_FLD_CHANGE,
			&              'whgine_job_change', D_FLD_DFLT, T$AUTO)
		else
			xcall i_fldmod(key_vi_id, 'vi_job',,, D_FLD_DRILL, ' ', D_FLD_CHANGE,
			&                'whgine_job_change', D_OFF,  D_FLD_DFLT,
			&                D_ON, D_FLD_REQUIRED )
		xcall i_init(key_vi_id, 'adv_set', whgine_vi_grp,'vi_job')
	end
	else
	begin
		xcall ibc_enable(key_vi_id, 'vi_job')
		xcall ibc_disable(key_vi_id, 'vi_iorc, vi_inv_typ, vi_narr')
		xcall i_fldmod(key_vi_id, 'vi_job',,, D_FLD_DRILL, 'wvi_drill',
		&              D_FLD_CHANGE, 'whgine_jobamd_change', D_FLD_DFLT, ' ')
	end

	fkeys[IAD_FKEYS].fkey[D_FK_NO2].disabled_flg = pass_gen_data.adv_mode .eq. D_INS_MODE
	fkeys[IAD_FKEYS].fkey[D_FK_NO3].disabled_flg = pass_gen_data.adv_mode .eq. D_AMD_MODE
	fkeys[IAD_FKEYS].fkey[D_FK_NO4].disabled_flg = pass_gen_data.adv_mode .eq. D_DEL_MODE

	mode=pass_gen_data.adv_mode
	xcall wnd_title(modtyp(mode),key_vi_id)
	xcall wnd_title(modtyp(mode),inp_vi_id)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section checks the currency of the vi record compared
        ;       with that if the customer.  if there is a mismatch then
        ;       a message is displayed and a conversion takes place of
        ;       all the currency values applicable
	check_currency,
	if(vistat.gt.1) return

	xcall file(pass_chn_data.chn(CMF_FILE), cusrec, vicust, 'RD',err,,,,,Q_NO_LOCK)
	if(err)
	begin
		xcall ibc_message('Customer '+vicust+' not found')
		return
	end
	if(vi_sell_cur.eq.cmf_cur_cod) return
	if(.not.cms_currency) return

	xcall flash('Converting advice currency from '+vi_sell_cur
	&               +' to '+cmf_cur_cod+'...')
	sleep 2

	if(.not.vi_cur_cnv)
	begin
		xcall file(g_fcf_chn,fcf_rec,vi_sell_cur, 'RD',err)
		vi_cur_cnv=fcf_std_rate
	end

	xcall file(g_fcf_chn,fcf_rec,cmf_cur_cod, 'RD',err)

	xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vijob,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'RS',err,,vj_rfa,,,D_NO_LOCK)
		if(err.or.vijob.ne.vjjob) exitloop
		if(vjnstk.eq.D_VJ_COMMENT) nextloop

		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'RD',err,,,,vj_rfa)
		if(vjnstk.eq.D_VJ_WGD)
		begin
			gen_channel=pass_chn_data.chn(VM_FILE)
			xcall file(gen_channel, vmrec, vjtstk, 'RE', err)
			if(err)
			begin
				gen_channel=pass_chn_data.chn(HM_FILE)
				xcall file(gen_channel, vmrec, vjtstk, 'RE', err)
				if(err)
					clear gen_channel
			end

			if(gen_channel)
			begin
				vm_rrp(D_FC)=%f_curr_fc(vm_rrp(D_BC), fcf_std_rate)
				vm_sett(D_FC)=%f_curr_fc(vm_sett(D_BC), fcf_std_rate)
				vm_f_disc=%f_curr_fc(
				&                       %f_curr_bc(vm_f_disc, vi_cur_cnv),fcf_std_rate)

				vm_sell_cur=cmf_cur_cod
				vm_sell_cnv=fcf_std_rate
				xcall file(pass_chn_data.chn(VM_FILE),vmrec,,'WR',err)

				; if not parial credit or partial invoice
				; and history wholegood then update
				if(viivcr.ne.D_VIIVCR_PART_CRED.and..not.
				& (viivcr.eq.D_VIIVCR_PART_INV.and.
				&  gen_channel.eq. pass_chn_data.chn(HM_FILE)
				& .and.vistat .lt. D_ADV_INVOICED))
				begin
					xcall file(pass_chn_data.chn(VD_FILE),vdrec,vmstok,'FI',err,1)
					repeat
					begin
						xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',err)
						if(err.or.vdstok.ne.vmstok) exitloop
						h_rrp=vd_rrp[D_FC]
						vd_rrp(D_FC)=%f_curr_fc(vd_rrp(D_BC), fcf_std_rate)

						if(.not.vdvat)
						begin
							if(cms_country.eq.EIRE_VAT) then
								vdvat=pass_gen_data.h_vat_code
							else
								vdvat = cms_uk_def_vat
						end
						xcall f_vat_rate( vdvat, tmp_rate , TRUE)
						if( tmp_rate.and..not.vi_vatable)
						begin
							if(cms_country.eq.EIRE_VAT) then vdvat=ivt_vat_zero
							else vdvat=cms_uk_zero_vat
						end
						if(h_rrp.ne.vd_rrp[D_FC].or..not.vd_vi_rrp[D_FC])
						begin
							if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL   ) then
								vd_vi_rrp(D_BC)=vd_rrp(D_BC)
							else
								xcall whgine_vat_calc(vd_vi_rrp(D_BC), vdvat,
								&            vt_vat_code, vt_vrat, vd_rrp(D_BC),
								&            D_RET_VAT_EXC, D_RET_VAT_INC)
							vd_vi_rrp[D_FC]=%f_curr_fc(vd_vi_rrp[D_BC],fcf_std_rate)
						end
						xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'WR',err)
					end
				end
				unlock pass_chn_data.chn(VD_FILE)
			end
		end

		vj_f_rrp=%f_curr_fc(
		&                       %f_curr_bc(vj_f_rrp, vi_cur_cnv),fcf_std_rate)
		vj_f_vi_rrp=%f_curr_fc(
		&                       %f_curr_bc(vj_f_vi_rrp, vi_cur_cnv),fcf_std_rate)
		vj_f_sett=%f_curr_fc(
		&                       %f_curr_bc(vj_f_sett, vi_cur_cnv),fcf_std_rate)

		; if part type line, discount is a percentage until invoiced
		if(vjnstk.ne.D_VJ_PART)
		begin
			vj_f_disc=%f_curr_fc(%f_curr_bc(vj_f_disc, vi_cur_cnv),fcf_std_rate)
			if(.not.vj_f_disc)
				clear vj_f_vi_disc
			if(.not.vj_f_vi_disc.and.vj_f_disc)
			begin
				if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
					vj_f_vi_disc=vj_f_disc
				else
					xcall whgine_vat_calc(vj_f_vi_disc, vjnvat,
					&        vt_vat_code, vt_vrat, vj_f_disc,
					&        D_RET_VAT_EXC, D_RET_VAT_INC)
			end
			vj_f_vi_disc=%f_curr_fc(%f_curr_bc(vj_f_vi_disc, vi_cur_cnv),fcf_std_rate)
		end
		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'WR',err)
	end

	; now process any trade in lines if applicable
	xcall file(pass_chn_data.chn(VB_FILE),vbrec,vijob,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VB_FILE),vbrec,,'RS',err,,vj_rfa,,,D_NO_LOCK)
		if(err .or. vijob .ne. vbjob)
			exitloop
		if(vjnstk .eq. D_VJ_COMMENT)
			nextloop

		xcall file(pass_chn_data.chn(VB_FILE),vbrec,,'RD',err,,,,vj_rfa)

		gen_channel=pass_chn_data.chn(VM_FILE)
		xcall file(gen_channel, vmrec, vbtstk, 'RE', err)
		if(err)
		begin
			gen_channel=pass_chn_data.chn(HM_FILE)
			xcall file(gen_channel, vmrec, vbtstk, 'RE', err)
			if(err)
				clear gen_channel
		end
		if(gen_channel)
		begin
			vm_tip(D_FC)=%f_curr_fc(vm_tip(D_BC), fcf_std_rate)
			vm_est_cos(D_FC)=%f_curr_fc(vm_est_cos(D_BC), fcf_std_rate)
			vm_pur_cur=cmf_cur_cod
			vm_pur_cnv=fcf_std_rate
			xcall file(pass_chn_data.chn(VM_FILE),vmrec,,'WR',err)

			xcall file(pass_chn_data.chn(VD_FILE),vdrec,vmstok,'FI',err,1)
			repeat
			begin
				xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',err)
				if(err.or.vdstok.ne.vmstok) exitloop
				if(vd_fin_inv.or.vd_recv_date) nextloop
				if(vd_sup_cus) nextloop
				if(vd_pur_cur.ne.vi_sell_cur) nextloop

				if (.not. pass_gen_data.h_vatreg .or. .not. pass_gen_data.h_vatable)
				begin
					if (.not.vdvat)
					begin
						if (.not. pass_gen_data.h_vatable) then
							vdvat=pass_gen_data.sb_vat_zero
						else
							vdvat=pass_gen_data.sb_vat_code
					end
					xcall f_vat_rate(vdvat, tmp_rate, true)
					if (tmp_rate)
						vdvat=pass_gen_data.sb_vat_zero
				end


				vd_est_cos(D_FC)=%f_curr_fc(vd_est_cos(D_BC), fcf_std_rate)
				vd_cost(D_FC)=%f_curr_fc(vd_cost(D_BC), fcf_std_rate)
				vd_pur_cur=cmf_cur_cod
				xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'WR',err)
			end
			unlock pass_chn_data.chn(VD_FILE)
		end
		vb_trade_prc(D_FC)=
		&       %f_curr_fc(vb_trade_prc(D_BC), fcf_std_rate)

		xcall file(pass_chn_data.chn(VB_FILE),vbrec,,'WR',err)
	end
	vi_sell_cur=cmf_cur_cod
	vi_cur_cnv=fcf_std_rate
	xcall update_virec

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;   this section checks the depot for the wholegood on the advice matches
        ;   that of its header.  This should always be the case.  However, a new
        ;   bit of functionality for the Claas web wgd advice routines has been
        ;   added.  This allows the user to add wholegoods which are marked as
        ;   being at another depot. The idea is that the transfer is deferred
        ;   to a point outside of the web services.  This is the ideal location
        ;   for that since the user will eventually need to go through this
        ;   routine to progress the invoice.

	check_depot_transfer_required,

	; loop until all the wholegood records have been transferred or the
	; user skips it for or quits
	repeat
	begin
		f_some_idt_os=false

		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,virec.vijob,'FI',err)
		repeat
		begin
			xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'RS',err,,,,,D_NO_LOCK)
			if(err.or.vijob.ne.vjjob) return

			if(vjrec.vjnstk.ne.D_VJ_WGD) nextloop

			gen_channel=pass_chn_data.chn(VM_FILE)
			xcall file(gen_channel, vmrec, vjrec.vjtstk, 'RD', err,,,,,Q_NO_LOCK)
			if(err)
			begin
				gen_channel=pass_chn_data.chn(HM_FILE)
				xcall file(gen_channel, vmrec, vjrec.vjtstk, 'RD', err,,,,,Q_NO_LOCK)
				if(err)
					nextloop
			end
			if(vmrec.vm_depot.eq.virec.vi_depot)
				nextloop

			; if transfer depots not allowed from invoicing the

			f_some_idt_os=true
			; NOTE the use of pmfrec as a conveniently large enough data
			; area for the purpose of display message/yes no prompt
			pmfrec='{WHOLEGD} '+vmrec.vmstok+' is at depot '+vmrec.vm_depot
			&  +' and will need to be transferred\n'
			&  +'to depot '+virec.vi_depot+' before the advice can be completed.'

			if(cms_wgd_inv_idt.eq.true .and.cms_wg_idt_prt.le.D_WG_IDT_PRT_DN_R) then
				pmfrec=%atrim(pmfrec)+'\nTransfer {WHOLEGD} now?'
			else
			begin
				xcall ibc_message(%atrim(pmfrec))
				nextloop
			end

			case %f_yes_no(%atrim(pmfrec),,,true,true) of
			begincase
				D_YES:              begin
					xcall xsubr('VEHTRN', 'WHGINE', vmrec.vmstok, vmrec.vm_depot,
					&               gold_com.cur_depot, err)
					exitloop
				end
				D_NO:               nextloop
				D_USER_ABORT:       return
			endcase
		end
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this sections checks the eire vat codes for this invoice
        ;       type if applicable ie. country = eire
	validate_eire_vat,
	begin
		data lVatRate,	d5
		if (ivt_vat_code < 1)
			reject = true
		else
			reject = %f_vat_rate(ivt_vat_code, lVatRate, true)
		if (reject)
			xcall ibc_message('Default VAT code for invoice type '+ivt_type+
			&               ' has not been set')
		else
		begin
			if (ivt_vat_zero < 1)
			begin
				reject = true
				xcall ibc_message('Default Zero Rated VAT code for invoice type '
				&               +ivt_type+' has not been set')
			end
			else
			begin
				reject = %f_vat_rate(ivt_vat_zero, lVatRate, true)
				if (reject)
					xcall ibc_message('Default Zero Rated VAT code for invoice type '
					&               +ivt_type+' is invalid')
				else
					if (lVatRate != 0)
					begin
						xcall ibc_message('Default Zero Rated VAT code for invoice type '
						&               +ivt_type+' is non zero and therefore is invalid')
						reject = true
					end
			end
		end
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       depot name
	get_dep_name,
	xcall get_dep_code(vi_dep,depot_code,vi_dep_des,err)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; printing options available
	print_options,

	;       ADVICE NOTE     available when not planned maintenance advice
	;       DRAFT INVOICE   always available
	;       COPY INVOICE    only when already invoiced
	;       FINAL INVOICE   only when not invoiced
	;       PRO_FORMA INVOICE
	;       ORDER ACKNOWLEGEMENT available when not planned maintenance advice
	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )

	; set up data to build selection list depending on status of wholegood

	clear opt_array

	loop=0
	if !pass_gen_data.plan_maint
	begin
		if(whgine_passed.f_del_note_only.eq.true) exit
		incr loop
		opt_data(loop)='Advice Note'
		lSelectionType[loop] = true
	end
	if(whgine_passed.f_del_note_only.ne.true)
	begin
		incr loop
		opt_data(loop)='Draft '+tx_typ(vi_iorc+1)  ; draft + invoice or Credit
		lSelectionType[loop] = true
	end
	if !pass_gen_data.plan_maint
	begin
		incr loop
		opt_data(loop)='Delivery Note'             ; delivery note
		lSelectionType[loop] = true
	end
	if(whgine_passed.f_del_note_only.ne.true)
	begin
		incr loop
		lSelectionType[loop] = true
		if(vistat.ge.D_ADV_INVOICED) then
			opt_data(loop)='Copy '+tx_typ(vi_iorc+1)
		else
		begin
			if(.not.whgine_passed.f_vsp_exists)
			begin
				if(pass_gen_data.adv_mode.ne.D_VEW_MODE) opt_data(loop)='Final '+tx_typ(vi_iorc+1)
			end
		end
		if(opt_data(loop)) incr loop
		opt_data(loop)='Pro_Forma '+tx_typ(vi_iorc+1)
		lSelectionType[loop] = true
	end
	if !pass_gen_data.plan_maint
	begin
		if(whgine_passed.f_del_note_only.eq.true) exit
		incr loop
		opt_data(loop)='Order Acknowledgement'
		lSelectionType[loop] = true
	end

re_inp_opt,
	clear stat
	selection = %f_prnt_list(gold_com, gold_ax, loop, opt_data, , lSelectionType, 'WGD')
	if(.not.( g_select .AND. g_entnam .EQ. 'J_QUIT' ))
	begin
		using selection select
			("Ad"),  ; Advice Note Print
				stat=D_PRT_ADVICE
			("Dr"),  ; Draft Invoice
				stat=D_PRT_DRAFT
			("De"),  ; Delivery Note
				stat=D_DEL_NOTE
			("Co"),  ; copy invoice
				if(.not.(vistat.ge.D_ADV_INVOICED)) then
				begin
					xcall u_beep
					goto re_inp_opt
				end
				else
				begin
					stat=D_PRT_COPY
				end
			("Fi"),  ; final invoice
				if(vistat.ge.D_ADV_INVOICED.or.pass_gen_data.adv_mode.eq.D_VEW_MODE) then
				begin
					xcall u_beep
					goto re_inp_opt
				end
				else
				begin
					if(sb_line_count)
						xcall whgine_check_cmf_sb_exp_date(vi_not_sbill,
						&           cmf_sb_exp_date, vi_idat, err)
					if(err) goto re_inp_opt
					stat=D_PRT_INV_UPD
					call check_any_wsj
				end
			("Pr"), ; pro_forma invoice
			begin
				stat=D_PRT_PROFORMA
				call check_any_wsj
			end
			("Or"), ; pro_forma invoice
				stat=D_PRT_ORD_ACK
			("Cu"), ; customer forms
				xcall WHGINE_prnt_custom_form(gold_com, gold_ax, virec)
		endusing
		if(.not.stat) goto re_inp_opt
		call print_control
	end
	exit_prt_opts,
	xcall e_exit
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       check for any WIP wsjs
	check_any_wsj,
	; check if any outstanding jobs for the wgs on invoice

	xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vijob,'FI',err,,,,,D_NO_LOCK)
	repeat
	begin
		xcall file(pass_chn_data.chn(VJ_FILE),vjrec,,'RS',err,,,,,D_NO_LOCK)
		if(err.or.vjjob.ne.vijob) exitloop
		if(vjnstk.ne.D_VJ_WGD) nextloop

		clear ivhrec
		ivhk_typ_ser = 0
		ivhk_wgstk = vjtstk
		xcall file(pass_chn_data.chn(IVH_FILE),ivhrec,ivh_key,'FI',err,3)
		repeat
		begin
			xcall file(pass_chn_data.chn(IVH_FILE),ivhrec,,'RS',err)

			if(err.EQ. 1 .OR. ivh_wg_no .NE. vjtstk.or.ivh_typ_ser) exitloop
			if(ivh_status .EQ. D_STATUS_PRINTED .OR.
			&                 ivh_status .EQ. D_STATUS_DELETED) nextloop
			xcall ibc_message('Warning - Outstanding WSJ No '+ivh_job_no+
			&                       ' for {WHOLEGD} '+vjtstk)
		end
		vgcode = vjngrp
		vg_adepot = vi_depot
		xcall file(pass_chn_data.chn(VGF_FILE),vgrec,vgkey,'RD',err)
		if(err) clear vgrec
		; if group file says that pdi refurb to be done at time of
		; advice and we have not already found a live one, then look on
		; wsj history
		if(vgf_wsj_wg.eq.D_WSJ_WG_ADV)
		begin
			err=%whgine_check_pdi_jobs(gold_com, vjtstk, true)
			if(err.ne.99)
				xcall ibc_message('WARNING - PDI Refurb Job not raised for {WHOLEGD} '+vjtstk)
		end

	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_options_menu,
	clear reject

	; No lines available to select from the menu.  avoid error by disallowing entry
	if(.not.loop)
	begin
		xcall ibc_message (disp_line(1,%trim(disp_line)+1)+' Not Available', D_BELL)
		reject=TRUE
		return
	end

	xcall s_selbld(opt_id,"vehine_sel",loop,loop,opt_data)
	xcall u_logwnd(opt_id)
	gen_channel = opt_id
	xcall wnd_title(disp_line,gen_channel)
	xcall e_sect(T$ARROW_KEYS,D_INFO,D_LEFT,D_CLEAR)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;        controls entry into the invoice printing routine.

	print_control,

	; for trade ins only where self billers not in use, user may print draft
	; or select the update options only

	if(stat.gt.3.and..not.cms_wg_sb_in_use
	&       .and.vi_not_sb.eq.D_VI_NOT_SB_PUR_INV
	&       .and.pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL)
	begin
		xcall ibc_message('Option not available as the '
		&           +'Trade in Type has not been set to'
		&           +' "Print Self Biller".  '
		&           +'Use the Final '+tx_typ(vi_iorc + 1)
		&           +' Option to set the trade in status to received.'
		&           +'You may also use the Draft option for a hard copy.')

		return
	end
	if(stat.eq.1)
	begin
		call check_invoice_type
		if(err) return
		; for purchase invoice or deposit self biller, ensure that the
		; supplier a/c is set for the customer
		; NOTE THIS TEST IS TRUE WHETHER PURCHASE INVOICE OR PURCHASE
		; SELF BILL TYPE
		if(pass_chn_data.h_prog_code.ne.P_COD_MACH_NO_SPC_TI.and.
		&           vi_deposit_total.and.vi_dep_inv_no)
		begin
			if(viivcr) then
				xcall ibc_message('A deposit credit has been raised for this'
				&                +' advice.  You need to invoice this deposit '
				&                +'before producing the final invoice.')

			else
				xcall ibc_message('A deposit invoice has been raised for this'
				&                +' advice.  You need to credit this deposit '
				&                +'before producing the final invoice.')
			return
		end


		if(vi_not_sb)
		begin
			xcall file(pass_chn_data.chn(VB_FILE), vbrec, vijob, 'RD', err,,,,,D_NO_LOCK)
			if(vbjob.ne.vijob) exit
			if(.not.pass_chn_data.h_supacc) then
			begin
				xcall ibc_message('Invalid - Supplier A/c Not Set UP.'
				&    +'  Select Self Biller Option or Exit and Set Up '
				&    +'Supplier A/c for this Customer')
				err=true
			end
			else
			begin
				xcall file(pass_chn_data.chn(SMF_FILE), suprec, pass_chn_data.h_supacc, 'RD', err)
				if(err) then
					xcall ibc_message('Invalid - Supplier A/c '+%string(pass_chn_data.h_supacc)
					&             +' not found')
				else
					if(smf_cur_cod .ne. pass_gen_data.vi_currency)
					begin
						xcall ibc_message('Invalid - Advice currency is '
						&             +pass_gen_data.vi_currency+
						&             ' while Supplier currency is '
						&             +smf_cur_cod+
						&             '\nThe currencies must be the same.')
						err=true
					end
			end
			if(err) return
		end
		if(pass_chn_data.h_prog_code.eq.P_COD_MACH_NO_SPC_TI.and..not.vi_deposit_amt)
		begin
			xcall ibc_message('Warning - Invoice type program code selected is\n'
			&                 +T$P_COD_MACH_NO_SPC_TI
			&    +' but there are no deposit details - see Finance section.')
		end

		; if there is px finance settlement value and this is not the
		; special sb deposit invoice type then invalidate
		if(vi_px_fin_sett.and..not.sb_line_count.and.
		&  vi_not_sbill.ne.D_VI_NOT_SB_PUR_SB)
		begin
			xcall ibc_message('Invalid - There is a P/X Finance Settlement value '
			&                 +'(see Finance section) and no trade in items entered.'
			&                 +'\nYou will need to clear this value (or enter trade ins) '
			&                 +'before you can complete this advice.'
			&                 +'\nThis can be done by entering the Finance section.')
			return
		end

		h_date=viidat                       ; store comparison
		xcall get_445_inv_date(viidat)
		if(viidat.lt.%ndate)
		begin
			yes_no_ans=D_YES
			; Special for Doe - Needs access 37 for old dates
			if (cms_user_id == 10687 && f_idat_in_sal_per_only && 
			&	(viidat < %f_first_day8(D_POST_SAL) || viidat > %f_last_day8(D_POST_SAL)))
			begin
				xcall ibc_message('Dated in Previous Sales Period - Amend Header', D_ERROR)
				xcall i_init(inp_hdr_id, 'tab_set', whgine_hdr, 'vi_idat')
			end
			else
				xcall yes_no('Invoice date earlier than today - Amend Header?', yes_no_ans, 10)
			if(yes_no_ans.eq.D_YES) then
			begin
				g_rtn=WR_HEADER
				return
			end
			else
			begin
				if(cms_country.eq.SAUDI_ARABIA)
				begin
					xcall ibc_message('Cannot continue with invoice printing '
					&                               +'- Invoice Date must not be less than today.')
					return
				end
			end
		end

		; if a credit - check any sb for internal jobs that may affect cost
		if(viivcr.eq.D_VIIVCR_CREDIT)
		begin
			yes_no_ans=D_YES
			call check_self_bill_internal_jobs
			if(yes_no_ans.ne.D_YES) return
		end

		call check_depot_transfer_required
		if(f_some_idt_os) return

		yes_no_ans=D_NO
		xcall yes_no('Please Confirm Final Invoice And Update Required?'
		&                               ,yes_no_ans,10)
		if(yes_no_ans.ne.D_YES) return

		; check if vat margin does not have main cost assigned (user can still continue but all costs will be used to calculate vat
		clear reject
		if (%WHGINE_chk_main_cost(gold_com, vijob, whgine_passed, true))
		begin
			reject = true
			return
		end

		if (! pass_gen_data.plan_maint && %whgine_check_39_status(whgine_passed, whgine_hdr))
			return

		; if settlement daya have not been set but there is some settlement
		; discount, this is invalid
		if (! vi_sett && %whgine_check_settlement(whgine_passed, whgine_hdr))
			return

		if(viidat.ne.h_date)        ; only if different do we need upd
			xcall update_virec

		; if MASCUS link in use delete any MASCUS records
		; as if sold is no longer needed on database
		if (cms_mascus_link)
			xcall whmasdelete(vmstok)
	end
	if(vistat < D_ADV_INVOICED && viivcr == D_VIIVCR_CREDIT
	&  && pass_gen_data.adv_mode.ne.D_VEW_MODE
	&  && (vi_crst == D_IVT_CRST_SETTLE || vi_crst == D_IVT_CRST_CREDIT)
	&  && virec.visett)
	begin
		if(vi_cr_sett_yn.ne.'N') then yes_no_ans=D_YES
		else yes_no_ans=D_NO
		xcall yes_no('Was the invoice paid within settlement terms?',yes_no_ans,10)
		if (vi_crst == D_IVT_CRST_CREDIT)
			yes_no_ans = 1 - yes_no_ans
		if(yes_no_ans.ne.D_YES) then vi_cr_sett_yn='N'
		else clear vi_cr_sett_yn
		pass_gen_data.h_cr_sett_yn=vi_cr_sett_yn
		xcall update_virec

	end
	if(stat.eq.1.and.
	&  pass_chn_data.h_prog_code .ne. P_COD_SEL_BILL.and.
	&  pass_gen_data.pm_create_cont_ivt.and.
	&  viivcr.eq.D_VIIVCR_INVOICE)
	begin
		call create_plan_maint_contract
		if(yes_no_ans.ne.D_YES)
			return
		xcall file(pass_chn_data.chn(VJ_FILE), vjrec, virec.vijob,'FI', err)
		repeat
		begin
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec,,'RS', err,,vm_rfa,,,D_NO_LOCK)
			if(err.or.vjrec.vjjob.ne.virec.vijob)
				exitloop
			if(vjrec.vjnstk.ne.D_VJ_WGD)
				nextloop
			if %whgine_check_pm_details(vjrec.vjtstk, true,vjrec.vj_wg_pm_group,,true)
			begin
				yes_no_ans=D_NO
				return
			end
		end
	end
	snd_job_no=vijob        ; PRIMARY KEY FOR INVOICE
	snd_stat=stat
	snd_prog='WHGINE'

	unlock pass_chn_data.chn(VI_FILE)
	unlock pass_chn_data.chn(VM_FILE)
	unlock pass_chn_data.chn(VB_FILE)

	; need to re-establish locks ???????
	hld_vistat = vistat
	; perform the required printing
	xcall whgprt(sndmsg)
	call open_hort_files            ; closed in WHGPRT
	xcall file(pass_chn_data.chn(VI_FILE), virec, vijob, 'RD', err)
	if(vistat .ne. hld_vistat) then
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL
		&  .and.vi_not_sbill.eq.D_VI_NOT_SB_PUR_INV)
			xcall ibc_message('NOTE : Self Bill Purchase items now received '
			&  +'and awaiting supplier cost posting entry for supplier a/c '
			&  +'number '+%string(pass_chn_data.h_supacc))

		snd_job_no = vijob      ; in case its been changed by vehprt
		g_rtn = WR_GET_ADV
	end
	else
		clear snd_job_no
	; note that the line below was added after being removed
	; from whgine_upd where the problem was that this line was causing
	; add_part to disable the ins, amd and del functions because of
	; it.  Its removal though had an impact after the  print routine has
	; been done but while still in the same advice having not exited.  The
	; problem was that add_part ins, amd, del funcs were still intially
	; available so that you could change even though already invoiced.
	if(snd_stat.eq.D_PRT_INV_UPD.and.hld_vistat.ne.vistat)
		add_part_passed.edit_mode = D_VIEW_MODE

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	new option june 2010
	;	automatic creation of a plan maintenance contract
	create_plan_maint_contract,
	yes_no_ans = true
	; next, check any lines are applicable for contract creation
	xcall file(pass_chn_data.chn(VJ_FILE), vjrec, virec.vijob,'FI', err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VJ_FILE), vjrec,,'RS', err,,vm_rfa,,,D_NO_LOCK)
		if(err.or.vjrec.vjjob.ne.virec.vijob) exitloop
		if(vjrec.vjnstk.ne.D_VJ_WGD) nextloop
		xcall whgine_get_group(vjrec.vjngrp)
		; if group says allow pm create - then has contract line been
		; set up with some detail
		;	    if(pass_gen_data.f_vg_pm_link.and.vgf_planned_maint_link.eq.true.and.
		;	    &	vjrec.wg_pm_model.and.vjrec.wg_pm_charge_code)
		; if contract no already set, do not do
		if(pass_gen_data.f_vg_pm_link.and..not.vjrec.vj_wg_pm_group.wg_pm_contract)
		begin
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec,,'RD', err,,,,vm_rfa)
			xcall whgine_init_vj_inp_from_vjrec(whgine_vj,whgine_passed, invoice_totals)
			;whgine_vj.vj_inp_pm_group = vjrec.vj_wg_pm_group
			err=%whgine_pm_contract_entry(gold_com, gold_ax, whgine_vj, whgine_hdr,
			&	D_CRT_PM_PROC, whgine_passed)

			vjrec.vj_wg_pm_group = whgine_vj.vj_inp_pm_group
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec,,'WR', err)
		end
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;      this section checks through any historic jobs for the wholegood
        ;       trade in lines.  If any of these are for a internal job
        ;       affecting cost then a warning message will be displayed.
	check_self_bill_internal_jobs,

	xcall file(pass_chn_data.chn(VB_FILE),vbrec,vijob,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VB_FILE),vbrec,,'RS',err,,,,,D_NO_LOCK)
		if(err .or. vbjob .ne. vijob) exitloop

		xcall whgine_check_sb_int_jobs(yes_no_ans, vbtstk)
		if(yes_no_ans.ne.D_YES) return
	end

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       Ross farms reported a problem where having done an
        ;       auto credit deal where there was main wholegood and
        ;       a self bill line, they deleted the main line from the
        ;       advice and then selected the invoice/credit update
        ;       opotion.  The problem with this is that now the deal
        ;       does not have the correct invoice type since there is
        ;       no main item only a self bill.
	check_invoice_type,
	xcall file(pass_chn_data.chn(IVT_FILE), ivtrec, vi_inv_typ,'RD',err)
	pass_chn_data.h_prog_code=ivt_prog_code
	if(ivt_prog_code.ne.P_COD_SEL_BILL)
	begin
		xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vijob, 'RD', err
		&          ,,,,,D_NO_LOCK)
		if(err.eq.1.or.vjjob.ne.vijob) clear vjrec

		if(.not.vjrec)
		begin
			xcall file(pass_chn_data.chn(VB_FILE), vbrec, vijob, 'RD', err
			&          ,,,,,D_NO_LOCK)
			if(err.eq.1.or.vbjob.ne.vijob) clear vbrec

			if(vbrec) call input_sb_inv_type
		end
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       show a message indicating that the invoice type is not
        ;       consistent with the content of the advice.
        ;       and allow the user to change the invoice type to self
        ;       bill offering default self bill type.
	input_sb_inv_type,

	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )
	clear sb_it_id

	xcall ibc_ldinp(sb_it_id, g_utlib, 'vehine_sb_only',,,,,,
	&               fkeys[BLNK_FKEYS] )
	xcall file(pass_chn_data.chn(IVT_FILE), ivtrec,, 'FS', err)
	repeat
	begin
		xcall file(pass_chn_data.chn(IVT_FILE), ivtrec,, 'RS', err)
		if(err) stop
		;             begin
		;               xcall u_message('No Self Billing Invoice Type '
		;               & +'records exist on file - Cannot Continue')
		;               goto sb_it_out
		;             end
		if(ivt_prog_code.ne.P_COD_SEL_BILL) nextloop
		sb_only_ityp=ivt_type
		exitloop
	end

	xcall i_display(sb_it_id, 'inp_set', vehine_sb_only)
	repeat
	begin
		xcall i_next(sb_it_id,'inp_set','*FRST*')
		xcall ibc_input(sb_it_id,'inp_set',vehine_sb_only,
		&               gold_inp_id,,,D_NOTERM,,
		&            fkeys[BLNK_FKEYS], gold_com, gold_ax, fkeys[BLNK_FKEYS] )

		if( g_select .and. g_entnam .eq. 'J_QUIT' )
			goto sb_it_out

		if(.not.sb_only_ityp) nextloop
		xcall file(pass_chn_data.chn(IVT_FILE), ivtrec, sb_only_ityp,'RD',err)
		if(.not.err.and.ivt_prog_code.eq.P_COD_SEL_BILL)
			exitloop
		xcall ibc_message('Invalid - Self Billing Type only required')
	end
	vi_ityp=ivt_type
	g_rtn=WR_SHOW_DETS
	sb_it_out,
	err=TRUE        ; this will force user into header entry and
                        ; at the same time update screen fields etc
	xcall e_exit
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
	delivery_address,
	; a complication to the delivery address process is that the
	; delivery address is now used to store the customer address
	; at the time of invoice.  As the delivery address can be changed
	; even after the invoice has been printed, need to check if the
	; address within the space is the delivery address or otherwise.
	if(.not.wgd_deladd[].and..not.vi_cmf_add_in_dela)
	begin
		wgd_deladd[] = cmf_del_address[]
		wgd_del_postcode=cmf_del_postcode
	end
	if(vi_cmf_add_in_dela)
	begin
		clear wgd_deladd[]
	end
	begin
		data addr_mode, d1
		if(whgine_passed.f_del_note_only ) then
			addr_mode=1    ;view only
		else
			addr_mode=0
		xcall wgd_del_add(gold_com, gold_ax, lWgd_del_add, addr_mode, 'Delivery Address', del_cust)
		if(vi_cmf_add_in_dela.and.wgd_deladd[])
			clear vi_cmf_add_in_dela

		hdr_moded = true
	end

	return
.end

.subroutine whgine_proc_hdr

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group= 'whgine_vb'
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_vj' repository, group= 'whgine_nstk'
	.include 'doclst_pass' repository, group = 'doclst_pass'
	.include 'doc_search' repository, group='doc_search'
	.include 'smslst_pass' repository, group = 'smslst_pass'
	.include 'wgd_deladd' repository, group='aWgd_del_add'
endparams

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:SMFREC.REC'
	.include 'SRC:CTFREC.REC'
	.include 'SRC:PUNREC.REC'

	external function
		julian,         d
		f_file,         d
		f_yes_no,       d
		f_alpha7_date,  a

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	record whgine_chng_inv
		cur_inv_typ,    a2
		cur_inv_desc,   a20
		new_inv_typ,    a2
		new_inv_desc,   a20

		.include 'vm_search' repository, structure = 'vm_search'

	record gen
		chr,            a1
		reject,         d2
		loop,           d2
		rep_prompt,     a9
		f_chk_address,  d1
		f_no_defaults,  d1
		yes_no_ans,     d1
		add_line4,      a32
		.include 'vwrec' repository, group='vwrec'

		.include 'whgine_hdr' repository, group = 'hld_hdr', nofields
		.include 'ivt_user' repository, group='ivt_user'
		.include 'vm_user' repository, group='vm_user'
		group ctf_key1
			ctf_key1_cdocr,	a6
			ctf_key1_date,	d8
		endgroup

	.align
	record ids

		chg_inv_id,     i4
		prv_tin_id,     I4
		quitting,       i4
		err,            i4
		f_offer_support,i4
		search,		i4
		reserve_mn_id,	i4

.proc
	clear gen, ^i(ids)
	xcall whgine_set_vi_ignore_ivacc(vi_ignore_ivacc)

	xcall ibctab_highlight(tabset_id, true, tabhdr_id)

	xcall i_frames(hdr_cust_id, 'disp_set')
	xcall i_display(hdr_cust_id, 'disp_set', whgine_vi_grp)


	if pass_gen_data.adv_mode .eq. D_VEW_MODE then
	begin
		xcall ibc_set_fkeys(fkeys[HDR_FKEYS], true)
		fkeys[HDR_FKEYS].fkey[D_FK_NO4].disabled_flg = false
		fkeys[HDR_FKEYS].fkey[D_FK_NO5].disabled_flg = true
		xcall ibc_disable(D_ALL, a_wndid)
		xcall ibc_enable(a_wndid, 'vi_req_dt')
	end
	else
	begin
		xcall ibc_enable(D_ALL, a_wndid)
		if(pass_gen_data.plan_maint)
		begin
			; if there are some lines on the advice then do not allow
			; the contract number to be changed as this could then make the
			; the lines invalid for the contract
			if(adv_line_count.and.vi_i_pm_contract) then
				xcall ibc_disable(inp_hdr_id, 'VI_I_PM_CONTRACT')
			else
				xcall ibc_enable(inp_hdr_id, 'VI_I_PM_CONTRACT')
			if(.not. vi_i_pm_contract)
				xcall i_init(a_wndid, 'tab_set', whgine_hdr, 'vi_i_pm_contract')
		end

		xcall ibc_set_fkeys(fkeys[HDR_FKEYS], false)
		if .not. vi_cust
			xcall i_init(a_wndid, 'tab_set', whgine_hdr, 'vi_cust')
		if .not. vi_rep
			xcall i_init(a_wndid, 'tab_set', whgine_hdr, 'vi_rep')
	end

	xcall whgine_set_prv_tin_fkey(whgine_hdr, fkeys[HDR_FKEYS])
	if pass_gen_data.adv_mode .eq. D_AMD_MODE
	begin
		call check_support_applicable
		if(f_offer_support.eq.true)
		begin
			xcall m_ldcol(reserve_mn_id, g_utlib, 'whgine_rsv_mn', , search)
			xcall ibc_message('WARNING - This advice seems to be partially completed.'
			&	+'  While some indicators suggest the invoice is completed, the'
			&	+' status remains uninvoiced.  This would suggest that a problem'
			&	+' has arisen in the Invoice Update routine.'
			&	+'  Please report this problem to Ibcos'
			&	+' and then select the reserved support function.')
		end
	end

	if pass_gen_data.adv_mode .ne. D_AMD_MODE then
		xcall i_next(a_wndid, 'tab_set', '*FRST*')
	else
		xcall i_next(a_wndid, 'tab_set', 'VI_CORD')

	hld_hdr = whgine_hdr
	repeat
	begin
		xcall ibc_input( a_wndid, 'tab_set', whgine_hdr,
		&            gold_com.inp_col_id, gold_com.sel_col_id,,
		&            D_NOTERM,, fkeys[HDR_FKEYS], gold_com, gold_ax,
		&            fkeys[HDR_FKEYS], whgine_passed)
		if g_select then
		begin
			case g_entnam of
			begincase
				'J_QUIT':     begin
					if(hld_hdr .ne. whgine_hdr .and.
					&  .not.%i_checkdata(a_wndid, 'tab_set', whgine_hdr, TRUE))
					begin
						if(%f_yes_no('Abandon Entry?').ne.true) nextloop
						; fool routine into thinking no changes done
						hld_hdr = whgine_hdr
						xcall m_signal('J_QUIT')
					end
					exitloop

				end
			'AD_PWORD':	begin
							if (%acc_date_passwd(a_wndid, 'vi_idat', vi_idat))
								xcall i_init(a_wndid, 'tab_set', whgine_hdr, 'vi_idat')
							xcall i_next(a_wndid, 'tab_set', 'vi_idat')
							nextloop
						end
				'J_CHECK':    begin
					call validate_customer
					if reject
					begin
						xcall i_init(a_wndid, 'tab_set', whgine_hdr,
						&        'vi_cust')
						xcall i_next(a_wndid, 'tab_set', 'vi_cust')
						nextloop
					end
					xcall i_snapshot(D_LOAD, pass_gen_data.inp_atd_id, atd_snap)

					if(vistat.lt.D_ADV_INVOICED.and..not.h_cm4_cred_wg) then
						xcall cust_check(vi_cust, reject,,,, true, true,
						& ,adv_t_vat+adv_t_retail,,aged_bals_grp, crlim_pass_ent)
					else
						xcall cust_check(vi_cust, reject,,,, true, true,
						& ,,,aged_bals_grp, crlim_pass_ent)

					cmf_acc_no = vi_cust
					xcall whgine_get_customer_dets
					vi_cusnam = cmf_name
					xcall i_putfld(inp_hdr_id, 'disp_set', whgine_hdr, 'vi_cusadd1',
					&                  cmf_address1, gold_com)
					xcall i_putfld(inp_hdr_id, 'disp_set', whgine_hdr, 'vi_cusadd2',
					&                  cmf_address2, gold_com)
					xcall i_putfld(inp_hdr_id, 'disp_set', whgine_hdr, 'vi_cusadd3',
					&                  cmf_address3, gold_com)
					if (cmf_address4) then
						xcall s_bld(add_line4,,'%a%a %a',cmf_address4,',',cmf_post_cd)
					else
						add_line4 = cmf_post_cd
					xcall i_putfld(inp_hdr_id,'disp_set',whgine_hdr,'vi_cusadd4',
					&                  add_line4,gold_com)
					if(cms_country.ne.SAUDI_ARABIA.and.cms_country.ne.NO_VAT)
					begin
						xcall i_putfld(a_wndid, 'disp_set', whgine_hdr, 'vi_vatreg',
						&              cmf_vat_no, gold_com)
						xcall i_putfld(a_wndid, 'disp_set', whgine_hdr, 'vi_vatable',
						&              cmf_vat, gold_com)
					end
					if(vi_rep)
						xcall i_putfld(a_wndid, 'disp_set', whgine_hdr, 'vi_rep',
						&              vi_rep, gold_com)

					xcall whgine_vi_cord_set_reqd(cmf_force_ord, whgine_hdr, a_wndid, gold_com)

					xcall whgine_set_invoice_to_account(a_wndid,
					&       cmf_inv_acc, pass_chn_data.chn(CMF_FILE), whgine_hdr)

					xcall i_display(inp_vi_id, 'adv_set', whgine_hdr,,,,,,,,,,
					&                   gold_com, gold_ax)
					if .not. vi_rep
						xcall i_init(a_wndid, 'tab_set', whgine_hdr, 'vi_rep')
					set vi_sell_cur, gold_com.currency_code, inv_curr,
					&       pass_gen_data.vi_currency = cmf_cur_cod

					; WG7283 - CURRENCY FOR CUST AND FCUS MUST MATCH
					if(vi_fcus)
					begin
						xcall file(pass_chn_data.chn(CMF_FILE), cusrec, vi_fcus, 'RD', err)
						if(err) then
						begin
							clear cusrec
							xcall ibc_message('Invalid finance company - will clear')
						end
						else
							if(cmf_cur_cod.ne.inv_curr)
							begin
								xcall ibc_message('Invalid - The finance company currency is '+cmf_cur_cod
								&               + ' while the customer account currency is '+inv_curr
								&               +' - the currencies must match - will clear finance company')
								clear cusrec
							end
					end
					else
						clear cusrec
					xcall whgine_set_finance_co_fields(inp_hdr_id, whgine_hdr, gold_com, whgine_passed)
					if pass_gen_data.vi_currency .eq. cms_base_cur
						xcall i_setdel(pass_gen_data.inp_atd_id, 'wgd_fullset',
						&     'vj_bc_rrp, vj_bc_vi_rrp, vj_atd_rrp_bcur,vj_atd_rrp_bcur_o,vj_atd_t_brrp')

					if cms_menu_11      ; check for o/s events
						xcall pun_check(gold_com, gold_ax, PUN_TYPE_CUST_ACC,
						&        cmf_acc_no)

					; if cash sale account allow customer name and address to be amended
					if( cmf_inv_mthd == CMF_INV_MTHD_CASH )
					begin
						xcall ibc_enable( a_wndid, 'vi_cusnam, vi_cusadd1, vi_cusadd2, vi_cusadd3, vi_cusadd4' )
					end
					else
					begin
						xcall ibc_disable( a_wndid, 'vi_cusnam, vi_cusadd1, vi_cusadd2, vi_cusadd3, vi_cusadd4' )
					end
					
					clear g_entnam
					xcall i_next(a_wndid, 'tab_set', '*NEXT*')
				end
				'J_FCUS':         begin
					xcall i_display(inp_vi_id, 'adv_set', whgine_hdr,,,,,,,,,,
					&           gold_com, gold_ax)
					xcall i_next(a_wndid, 'tab_set', '*NEXT*')
				end

				'TS_TAB':         if %i_checkdata(a_wndid, 'tab_set', whgine_hdr)
					exitloop
				'INV_TYP'    :    call change_invoice_type
				'J_CHG_DISC' :    call enter_default_multi_discounts
				'J_PRV_TRD'  :    call enter_previous_trade_ins
				'J_SUPPORT'  :    begin
					call support_update
					if(f_offer_support.eq.99)
					begin
						hld_hdr = whgine_hdr
						xcall m_signal('J_QUIT')
						exitloop
					end
				end
			endcase
			else
				exitloop
		end
		else
			if %i_checkdata(a_wndid, 'tab_set', whgine_hdr)
			begin
				xcall m_signal("SEQ_TAB")
				exitloop
			end
	end
	if hld_hdr .ne. whgine_hdr
		set hdr_moded, items_moded = true
	viivcr = vi_iorc
	vi_cr_chrg = vi_cr_chrg_inp
	vi_crst = vi_crst_inp
	xcall ibctab_highlight(tabset_id, false)
	if(reserve_mn_id)
		xcall m_column(D_DELETE,reserve_mn_id)
	; PPD flag set if dated >= PPD start and UK dealer and customer has vat applied
	; and settlement discount applicable & settlement days`
	if (cmsrec.cms_country == UK_VAT && pass_chn_data.h_prog_code != P_COD_SEL_BILL &&
	& vi_vatable == true &&
	& vi_sett && vi_crst_inp == D_IVT_CRST_SETTLE &&
	& vi_crst_inp && virec.viidat >= D_PPD_START_DATE)
		pass_gen_data.lPPDInUse = true
	else
		pass_gen_data.lPPDInUse = false
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	this section deals with a problem that seems to happen
	;	from time to time where a wg invoice has been generated
	;	correctly, but the status, vat array and invoice totals
	;	are not updated
	support_update,
	call check_support_applicable
	if(f_offer_support.ne.true)
	begin
		xcall ibc_message('Advice Status Update not done.  The following must be true to pass its validation:-\n'
		&   +'In amend mode, Status must be uninvoiced but invoice number set, the totinv & totvat fields not set'
		&	+', vat array not set.  Additionally, the routine will warn but allow if ctf not found.')
		return
	end
	ctf_key1_cdocr=virec.viinvo
	ctf_key1_date=virec.viidat
	xcall file(pass_chn_data.chn(CTF_FILE),ctfrec,ctf_key1,'RD',err,1,,,,D_NO_LOCK)
	if(err)
	begin
		xcall file(pass_chn_data.chn(CTH_FILE),ctfrec,ctf_key1,'RD',err,1,,,,D_NO_LOCK)
	end

	if(err)
	begin
		; the docref plus inv date combination has not found a match. But it is
		; poossible that the ctf hasbeen written and because the advice is still
		; in amend mode, the user has been able to change the date.
		ctf_key1_date=virec.viidat
		xcall file(pass_chn_data.chn(CTF_FILE),ctfrec,virec.viinvo,'RD',err,1,,,,D_NO_LOCK)
		if(err.ne.EOF_ERR.and.ctfrec.ctf_doc_ref.eq.ctf_key1_cdocr.and.ctfrec.ctf_dispute.eq.'Z'
		&	.and.virec.vicust.eq.ctfrec.ctf_cust_acc) then
		begin
			xcall ibc_message('ERROR - CTF record found but the invoice held on CTF is'
			&	+' not the same as that on this advice.  Change the invoice date'
			&	+' on the advice header screen to '+%f_alpha7_date(ctfrec.ctf_tran_dat)
			&	+', then update and retry.')
			return
		end
		if(%f_yes_no('WARNING - CTF Not found for invoice no '+ctf_key1_cdocr
		&	+' '+%f_alpha7_date(ctf_key1_date)+' - Update anyway?').ne.true)
			return
	end
	else
	begin
		if(%f_yes_no('Please confirm update advice header?').ne.true) return
	end
	xcall file(pass_chn_data.chn(VI_FILE), virec, vijob, 'RD',err)
	if(err)
	begin
		xcall ibc_message('Unexpected read error on VI_FILE - Record Not updated')
		return
	end

	virec.vistat=2
	virec.vi_vat_code[] = vt_vat_code[]
	virec.vi_vrat[] = vt_vrat[]
	virec.vi_f_totinv=inv_val
	virec.vi_f_totvat=inv_vat
	xcall update_virec
	xcall ibc_message('Advice has been updated successfully')
	f_offer_support=99
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	check_support_applicable,
	f_offer_support=false

	if pass_gen_data.adv_mode .ne. D_AMD_MODE return

	if(virec.vistat.gt.1) return

	if(.not.virec.viinvo) return

	if(virec.vi_f_totinv) return
	if(virec.vi_f_totvat) return

	if(virec.vi_vat_code[1]) return

	f_offer_support=true

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       process to allow Previous related trade ins to be inserted.
        ;       the details of these will be printed on the invoice as
        ;       deposit notes but with no monetary value affecting the invoice
	enter_previous_trade_ins,

	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )
	clear prv_tin_id

	xcall ibc_ldinp(prv_tin_id, g_utlib, 'whgine_prv_tin',,,,,,
	&               fkeys[INP_FKEYS])

	clear vm_user, ^i(vm_user.vm_user_mh)
	xcall i_user(prv_tin_id,'FIN_PR_TI_STK01',, vm_user)

	vm_user.chk_type=
	vm_user.chk_search=
	vm_user.chk_option=D_ALL_WG
	vm_user.chk_depot=
	vm_user.chk_allow_create=false
	vm_user.chk_attach=false
	vm_user.usr_all=false
	vm_user.dsp_fldnam=
	if(.not. vm_user.vm_user_mh)
		vm_user.vm_user_mh=%mem_proc(DM_ALLOC+DM_STATIC,^size(vm_search))
	clear ^m(vm_search, vm_user.vm_user_mh)

	^m(vm_search.vms_supplier, vm_user_mh )=vi_cust(3,6)
	^m(vm_search.vms_recd_fr, vm_user_mh )=19900101
	^m(vm_search.vms_recd_to, vm_user_mh )=%ndate

	for loop from 1 thru 5
	begin
		xcall i_user(prv_tin_id,'FIN_PR_TI_STK'+%string(loop,'XX'),, vm_user)
	end

	xcall i_display(prv_tin_id,'dsp_set',whgine_hdr)
	if(pass_gen_data.adv_mode.eq.D_VEW_MODE) then
		xcall ibc_chr(chr, prv_tin_id)
	else
		call input_prv_tins
	xcall vm_user_clr(prv_tin_id,'FIN_PR_TI_STK01')
	clear ^i(fkeys[INP_FKEYS].fkmnu_id)

	xcall e_exit
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	input_prv_tins,

	xcall i_next(prv_tin_id,'inp_set','*FRST*')
	; Input question answers
	repeat
	begin
		; input key data..
		xcall ibc_input( prv_tin_id, 'inp_set' ,whgine_hdr,
		&                gold_com.inp_col_id, gold_com.sel_col_id,,
		&                D_NOTERM,, fkeys[INP_FKEYS], gold_com, gold_ax,
		&                fkeys[INP_FKEYS], whgine_passed)
		if(g_select .AND. g_entnam.eq.'J_QUIT')
		begin
			quitting = TRUE
		end
		exitloop
	end
	; SHUFFLE UP THE ARRAY UP OR COMPLETE ENTRY IF SPACE ENTERED
	reject=1
	for reject from 1 thru 5
	begin
		if(.not.fin_pr_ti_stk(reject))
		begin
			for loop from reject+1 thru 5
			begin
				if(fin_pr_ti_stk(loop))
				begin
					fin_pr_ti_stk(reject)=fin_pr_ti_stk(loop)
					clear fin_pr_ti_stk(loop)
					exitloop
				end
			end
		end
	end

	xcall whgine_set_prv_tin_fkey(whgine_hdr, fkeys[HDR_FKEYS])
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	enter_default_multi_discounts,

	clear vwrec
	vwrec.vw_md_group=vi_def_md_group
	xcall wg_md_disc(vwrec,h_cm5_wg_md_adv_def, , pass_gen_data.vi_exch_rate,
	&            gold_com, gold_ax,(pass_gen_data.adv_mode .eq. D_VEW_MODE),,f_wg_md_disc,
	&            'Default Multiple Discounts',a_wndid)
	vi_def_md_group=vwrec.vw_md_group

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       process to allow invoice type to be changed
	change_invoice_type,

	if(pass_gen_data.adv_mode.eq.D_VEW_MODE)
	begin
		xcall ibc_message('Invalid - you are currently in view mode only')
		return
	end
	xcall e_enter


	xcall ibc_column( D_REMOVE, D_LOCAL )

	xcall ibc_ldinp(chg_inv_id, g_utlib, 'whgine_chng_inv')

	ivt_user.dsp_fldnam = 'new_inv_desc'
	if(pass_gen_data.plan_maint) then
		ivt_user.usr_chk = -7
	else
		ivt_user.usr_chk = 2
	xcall i_user(chg_inv_id, 'new_inv_typ',, ivt_user)
	redo_inv_typ_input,
	set cur_inv_typ, new_inv_typ=vi_inv_typ
	set cur_inv_desc, new_inv_desc=ivt_desc
	xcall i_display(chg_inv_id,'dsp_set',whgine_chng_inv)

	xcall i_next(chg_inv_id,'inp_set','*FRST*')

	; Input question answers
	repeat
	begin
		; input key data..
		xcall ibc_input( chg_inv_id, 'inp_set' ,whgine_chng_inv, gold_inp_id,
		&                gold_sel_id ,, D_NOTERM )
		if(g_select .AND. g_entnam.eq.'J_QUIT') then
		begin
			quitting = TRUE
			exitloop
		end
		else
			exitloop
	end

	if( .not. quitting .and. new_inv_typ.ne.cur_inv_typ) then
	begin
		xcall file(pass_chn_data.chn(IVT_FILE), ivtrec, new_inv_typ, 'RD', err)
		call validate_customer
		if(reject) goto redo_inv_typ_input

		; update process
		vi_inv_typ=new_inv_typ
		xcall i_putfld(inp_vi_id, 'adv_set', whgine_hdr, 'vi_inv_typ',
		&              vi_inv_typ, gold_com)
		; ONLY CHANGE THE NARRATIVE IF THE CURRENT NARRATIVE IS DIFFERENT TO
		; STANDARD
		if(cur_inv_desc.eq.vi_narr)
		begin
			vi_narr=ivt_desc
			xcall i_dspfld(inp_hdr_id, 'vi_narr', vi_narr)

			xcall i_putfld(inp_vi_id, 'adv_set', whgine_hdr, 'vi_narr',
			&                  vi_narr, gold_com)
		end

	end
	; restore invoice typ recxord (or set to new)
	xcall file(pass_chn_data.chn(IVT_FILE), ivtrec, vi_inv_typ, 'RD', err)

	xcall e_exit

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       validate customer details
	validate_customer,
	clear reject
	cmf_acc_no=vi_cust [RIGHT]
	xcall whgine_get_customer_dets

	vi_cust=cmf_acc_no
	if(vi_cust.lt.ivt_from_cus.or.vi_cust.gt.ivtrec.ivt_to_cus.and.
	&  cms_user_id.ne.19998)
	begin
		xcall ibc_message('Valid Range for this invoice type is '+
		&                 ivt_from_cus+' to '+ivtrec.ivt_to_cus,D_BELL)
		reject = TRUE
	end
	if(.not.reject.and.cms_sep_depot.and.
	&  cms_country.ne.SAUDI_ARABIA.and.
	&  vi_cust(1,1).and.dt.and.vi_cust(1,1).ne.dt)
	begin
		xcall ibc_message('Customer Account not in Range for Depot Accounting')
		reject=TRUE
	end
	if(.not.reject)
	begin
		call check_stop
		if(.not.reject)
		begin
			; special for J Brock & Son - if purchase self bill type, always
			; set related supplier a/c to 1999
			if(cms_user_id.eq.10647.and.vi_not_sbill.eq.D_VI_NOT_SB_PUR_SB) then
				pass_chn_data.h_supacc=1999
			else
				pass_chn_data.h_supacc=cmf_pur_acc
			; note, if internal holding customer = finance co entered, then take the
			; vat details from that account and not the actual customer.
			if(.not.(cms_wg_cus_hold.and.cms_wg_cus_hold.eq.vi_fcus))
			begin
				set pass_gen_data.h_vatreg, vi_vatreg=cmf_vat_no
				set pass_gen_data.h_vatable, vi_vatable=cmf_vat
			end

			vi_cusnam=cmf_name
			for loop=1 until 4 do
			vi_cusadd(loop)=cmf_address(loop)

			xcall s_bld( rep_prompt,,T$REP_PROMPT, cmf_rep )
			xcall i_prompt(inp_vi_id,'vi_rep',rep_prompt)
			if(.not.vi_rep) vi_rep=cmf_rep

			xcall whgine_set_invoice_to_account(inp_hdr_id,
			&       cmf_inv_acc, pass_chn_data.chn(CMF_FILE), whgine_hdr)


		end
	end

	if(.not.reject)
	begin
		if(pass_gen_data.adv_mode.ne.D_INS_MODE.and.pass_gen_data.vi_currency.and.
		&                       cmf_cur_cod.ne.pass_gen_data.vi_currency)
		begin
			xcall ibc_message('Invalid - Cannot Change to Customer with '
			&                       +'different currency')
			reject = TRUE
		end
	end

	if(cms_user_id.eq.10060.and.cmf_out_typ.eq.'Y') then
		pass_gen_data.no_sett = TRUE
	else
		clear pass_gen_data.no_sett

	if(pass_gen_data.adv_mode.ne.D_INS_MODE.and.h_acc.ne.vi_cust
	&               .and.(videla[].or.cmf_del_address[].or.
	&               (vi_ivacc.and..not.vi_ignore_ivacc))) then
		f_chk_address=TRUE
	else
		f_chk_address=false

	; if settlement possible, prepare to set default details
	if(.not.pass_gen_data.no_sett.and..not.reject)
	begin
		if(h_acc.ne.vi_cust.or.h_invtyp.ne.ivt_type) then
			f_no_defaults=false
		else
			f_no_defaults=TRUE


		xcall set_sett_crd(vi_crst_inp, vi_cr_chrg_inp,vi_ddat,vi_sett
		&                       ,,vi_idat,,TRUE,f_no_defaults)
		if vi_crst_inp .eq. D_IVT_CRST_CREDIT then
			xcall i_prompt(inp_hdr_id, 'vi_cr_chrg_inp', T$CRED_PRMPT)
		else
			xcall i_prompt(inp_hdr_id, 'vi_cr_chrg_inp', T$SETT_PRMPT)

		;WG7472 - AP 02/02/2010 - The routine was not applying sett date when no discount rate
		;WG7472            if(f_no_defaults.eq.false.and..not.vi_cr_chrg_inp.and.vi_ddat.ne.
		;WG7472&               vi_idat)
		;WG7472              begin
		;WG7472                vi_ddat=vi_idat
		;WG7472                vi_sett=0
		;WG7472              end
		; if days credit =999 display actual days credit given
		if(vi_sett.eq.999)
			vi_sett=%julian(vi_ddat)-%julian(vi_idat)
		h_acc=vi_cust
		h_invtyp=vi_ityp
		xcall i_display(a_wndid,'date_set', whgine_hdr,
		&               ,,,,,,,,,gold_com, gold_ax )

		g_setsts=TRUE
	end

	; Special for Ernest Doe & Sons Ltd / T H Whites and Ben Burgess - if in
	; insert mode, while default rep code may be
	; set,initialise the rep field anyway to force entry of this
	if(.not.reject.and.
	&  (cms_user_id.eq.10687 .or. cms_user_id.eq.10116 .or.
	&   cms_user_id.eq.10408).and. pass_gen_data.adv_mode.eq.D_INS_MODE)
		clear vi_rep

	if(reject.eq.TRUE) clear vi_addcus
	if(.not.reject)
	begin
		set inv_curr, pass_gen_data.vi_currency = cmf_cur_cod
		xcall reset_currency(gold_com, whgine_passed)
		pass_gen_data.vi_exch_rate=fcf_std_rate

		if(pass_gen_data.adv_mode.eq.D_INS_MODE.and.cmf_pur_acc.and..not.cms_wg_sb_in_use
		&  .and..not. vi_not_sbill.and..not. pass_gen_data.plan_maint)
		begin
			vi_not_sbill= D_VI_NOT_SB_PUR_INV
			xcall i_dspfld(a_wndid,'vi_not_sbill', vi_not_sbill)
		end
		if(.not.(cms_country.eq.SAUDI_ARABIA.or.cms_country.eq.NO_VAT))
		begin
			if(.not. pass_gen_data.h_vatable) then
				xcall ibc_message(
				&                       'Warning - VAT is not applicable for this customer')
			else
				if(pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL)
				begin
					if(.not.vi_vatreg.and.(cms_country.eq.UK_VAT.or.cms_country.eq.EIRE_VAT))
					begin
						xcall ibc_message('Warning - '
						&           +'No Vat Registration Number For This Customer. '
						&           +'VAT Will Not Be Applied to Trade Ins.')
					end

				end
		end
		xcall whgine_vi_cord_set_reqd(cmf_force_ord, whgine_hdr, a_wndid, gold_com)

	end
	if(.not.reject.and.f_chk_address)
	begin
		if(%f_yes_no('Delivery address present - Do you want to reset'
		&               ' this?').eq.TRUE)
			call set_default_delivery_address
	end

	return

	set_default_delivery_address,
	clear wgd_deladd[],wgd_del_postcode

	if((vi_ivacc.and..not.vi_ignore_ivacc).or.cmf_del_address[])
	begin
		if(cmf_del_address[])
		begin
			cmf_address[]=cmf_del_address[]
			cmf_post_cd=cmf_del_postcode
		end
		xcall whgine_set_deladd_from_cmf(aWgd_del_add, cusrec)
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       if the customer is on stop and pass_gen_data.adv_mode.ne.D_VEW_MODE
;       then need to get the stop password allowing to continue
;       if this is not supplied, allow operator to continue but in
;       view mode only, unless pass_gen_data.adv_mode.eq.D_INS_MODE in which case must
;       reject
	check_stop,

	; check if viewing only,in which case may skip password entry

	clear reject

	if(pass_gen_data.adv_mode.eq.D_VEW_MODE) return

	if(stop_customer.eq.vi_cust) return

	stop_customer=vi_cust

	reject=%whgine_cust_check(whgine_hdr, whgine_passed, whgine_inv_tab,
	&       crlim_pass_ent)

	if(reject.ne.D_CUS_FND) then
	begin
		clear stop_customer
		reject=TRUE
		if(pass_gen_data.adv_mode.ne.D_INS_MODE)
		begin
			yes_no_ans=D_YES
			xcall yes_no('Continue this advice in view mode only?',
			&            yes_no_ans, 9)
			if(yes_no_ans.eq.D_YES)
			begin
				reject=false
				pass_gen_data.adv_mode=D_VEW_MODE
			end
		end
	end
	else
	begin
		reject=false
	end
	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_prv_tin_fkey
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'fkeys' repository, group='fkeys_hdr'

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	record general
		loop,           i4
		reject,         i4
		h_fk_disp,      a7
.proc
	fkeys_hdr.fkey[D_FK_NO7].disabled_flg =
	&       (pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL.or.vi_not_sbill.ne.D_VI_NOT_SB_PRT_SB)
	if(.not.(pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL.or.vi_not_sbill.ne.D_VI_NOT_SB_PRT_SB))
		call set_trd_fkey_desc
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       sets the text on the  function key depending on number
        ;       of previous trade ins entered
	set_trd_fkey_desc,
	clear reject
	h_fk_disp=fkeys_hdr.fkey[D_FK_NO7].fk_disp
	for loop from 1 thru 5
	begin
		if(fin_pr_ti_stk(loop)) incr reject
	end
	xcall s_bld(fkeys_hdr.fkey[D_FK_NO7].fk_disp,,'P.Trad%a',
	&           %string(reject,'Z'))
	if(h_fk_disp.ne.fkeys_hdr.fkey[D_FK_NO7].fk_disp)
	begin
		fkeys_hdr.fkey[D_FK_NO7].btn_disp=
		&   fkeys_hdr.fkey[D_FK_NO7].fk_disp
		fkeys_hdr.fkey[D_FK_NO7].btn_txt_chngd=true
	end
	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_proc_fin
	a_wndid ,n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'

	.define T$STND_NOT_FND, 'Standard comment not found'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:SMFREC.REC'
	external function
		f_file,         d

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	record gen
		chr,            a1
		reject,         d2
		h_fldnam,       a20
		standard_no,    d4
		tmp_desc,       [10] a32
		main_wgd,       a8
		.include 'whgine_fin' repository, group = 'hld_fin', nofields

	record ScratchPadWorkers
		group StandardStory
			Type,	d2
			Code,	d4
		endgroup
		lLines,	@System.collections.ArrayList
		lString,	string
		lLoop,	i4
	endrecord


	.align
	record ids
		imp_id,                 i4
		imp_done,               i4
		imp_quitting,           i4
		err,                    i4
		loop,                   i4
		loop2,                  i4
		search,                 i4
		reprint_reqd,           i4
		req,                    i4
		at_bottom,              i4
		force_change,           i4
.proc
	clear gen, ^i(ids)

	; there seems to be an issue with some of the totals coming into
	; this routine (especially trade ins) . This is needed to calc total
	; finance value.  Therefore, take opportunity to recalc here

	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed,
	&                            whgine_hdr, whgine_inv_tab,
	&                            add_part_passed, invoice_totals)
	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed,
	&                               whgine_hdr, whgine_inv_tab)

	xcall ibctab_highlight(tabset_id, true, tabhdr_id)

	; get main wholegood - if there is not one present then do not allow
	err=%whgine_get_main_wgd(main_wgd, gold_com,gold_ax,whgine_passed)
	;        call get_main_wgd

	; if the trade in type selected is not DEPOSIT SELF BILL
	; and there are no TRADE INS then disable the
	; settlement details section
	hld_fin = whgine_fin_grp
	if(.not.sb_line_count.and.vi_not_sbill.ne.D_VI_NOT_SB_PUR_SB) then
	begin
		xcall ibc_disable(a_wndid,'FIN_PX_FIN_SETT')
		xcall ibc_disable(a_wndid,'FIN_PX_FIN_SUPP')
		xcall ibc_disable(a_wndid,'FIN_PX_FIN_DESC')
		if(fin_px_fin_sett) clear fin_px_fin_sett
		if(fin_px_fin_supp) clear fin_px_fin_supp, fin_supp_nick
		if(fin_px_fin_desc) clear fin_px_fin_desc
	end
	else
	begin
		xcall ibc_enable(a_wndid,'FIN_PX_FIN_SETT')
		xcall ibc_enable(a_wndid,'FIN_PX_FIN_SUPP')
		xcall ibc_enable(a_wndid,'FIN_PX_FIN_DESC')
		if(fin_px_fin_sett) then
			xcall i_fldmod(a_wndid, 'FIN_PX_FIN_SUPP',,,D_ON,D_FLD_REQUIRED)
		else
			xcall i_fldmod(a_wndid, 'FIN_PX_FIN_SUPP',,,D_OFF,D_FLD_REQUIRED)
	end

	; if the input record has changed from that stored already
	if hld_fin .ne. whgine_fin_grp
		force_change=true

	xcall whgine_set_px_sett_totals(a_wndid,
	&                               whgine_inv_tab, whgine_hdr)
	call validate_supplier

	xcall i_display(a_wndid,'disp_set', whgine_hdr,,,,,,,,,, gold_com, gold_ax)
	xcall i_dspfld(a_wndid,'fin_px_acc_same',fin_px_acc_same)
	xcall i_frames(a_wndid)

	hld_fin = whgine_fin_grp
	repeat
	begin
		call set_deposit_fkeys_non_input
		xcall ibc_fkeys(a_wndid, fkeys[FIN_FKEYS])
		xcall ibc_chr(chr, a_wndid,,,,, fkeys[FIN_FKEYS])

		if g_select then
		begin
			case g_entnam of
			begincase
				'J_QUIT':         begin
					xcall m_signal('HDR_TAB')
					exitloop
				end
				'J_FIN_DET':      begin
					if(fin_dep_inv_no) then
					begin
						xcall ibc_message('Invalid - You may not amend these'
						&                 +' details once a deposit invoice has'
						&                 +' been raised - If you need to change'
						&                 +' any of the details you must credit'
						&                 +' the deposit first.')
					end
					else
						call amend_finance_details
				end
				'TS_TAB':         exitloop
				'J_DEP_INV':      begin
					if(.not.main_wgd.and..not.fin_dep_inv_no) then
					begin
						xcall ibc_message('You need to add a main {WHOLEGD} before'
						&                 +' you can raise a deposit invoice')
					end
					else
					begin
						if(.not.fin_deposit_amt) then
							xcall ibc_message('Invalid - there is no deposit value to invoice')
						else
						begin
							if(pass_gen_data.adv_mode.eq.D_INS_MODE) then
							begin
								xcall m_signal('FINUPDREQD')
								exitloop
							end
							else
							begin
								reprint_reqd =  (fin_dep_inv_no.ne.' ')
								call deposit_control
								; if not a reprint - allow routine to exit to do
								; update and refresh the screen
								if(.not.reprint_reqd) exitloop
							end
						end
					end
				end
				'J_DEP_CRD':      begin
					if(.not.fin_dep_inv_no) then
						xcall ibc_message('Invalid - this has not been invoiced')
					else
					begin
						reprint_reqd = false
						; clear deposit invoice date so credit takes today's date.
						clear fin_dep_inv_date
						call deposit_control
						exitloop
					end
				end
			endcase
		end

	end
	if(pass_gen_data.adv_mode .ne. D_VEW_MODE .and.
	&       (hld_fin .ne. whgine_fin_grp .or. force_change.eq.true))
	begin
		set hdr_moded, items_moded = true
		xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed,
		&                           whgine_hdr, whgine_inv_tab)
	end
	xcall ibctab_highlight(tabset_id, false)
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       control deposit selection
	deposit_control,
	xcall whgine_deposit_invoice(gold_com, gold_ax, reprint_reqd,
	&                            main_wgd,  whgine_hdr)
	if(reprint_reqd .eq. false)
		xcall m_signal('FINUPDPRT')
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	amend_finance_details,
	; if deposit has already been invoiced then disable then
	; disable invoice function and enable credit
	if(fin_deposit_status) then
	begin
		xcall ibc_disable(a_wndid,'fin_deposit_amt')
	end
	else
	begin
		xcall ibc_enable(a_wndid,'fin_deposit_amt')
	end
	call set_deposit_fkeys_input
	xcall i_next(a_wndid, 'tab_set', '*FRST*')
	repeat
	begin
		xcall ibc_input( a_wndid, 'tab_set', whgine_hdr,
		&            gold_com.inp_col_id, gold_com.sel_col_id,,
		&            D_NOTERM,, fkeys[FIN_FKEYS], gold_com, gold_ax,
		&            fkeys[FIN_FKEYS], whgine_passed, whgine_inv_tab, invoice_totals)
		if g_select then
		begin
			case g_entnam of
			begincase
				'J_QUIT':         begin
					call check_fin_data
					if(.not.err) exitloop
				end
				'J_IMP_STY':      begin
					call import_story
				end
			endcase
			else
			begin
				call check_fin_data
				if(.not.err) exitloop
			end
		end
		else
		begin
			call check_fin_data
			if(.not.err)
			begin
				xcall m_signal("HDR_TAB")
				exitloop
			end
		end
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	check_fin_data,
	err=true
	if %i_checkdata(a_wndid, 'tab_set', whgine_hdr)
	begin
		if(fin_px_fin_sett.and.(.not.fin_px_fin_supp.or..not.fin_supp_nick)) then
			xcall i_next(a_wndid, 'tab_set', 'FIN_PX_FIN_SUP')
		else
			err=false
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section is used to set the function key strip
        ;       for non input ie. for selecting amend and disposit inv/cred only
	set_deposit_fkeys_non_input,

	; INPUT KEYS
	fkeys[FIN_FKEYS].fkey[ D_FK_NO2].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO3].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO4].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO8].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO5].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO6].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO7].disabled_flg=true

	; if stage/split payments, then do not allow entryt of any deposit details
	if(whgine_passed.f_vsp_exists) return

	; SELECTION KEYS
	if(pass_gen_data.adv_mode .ne. D_VEW_MODE )
	begin
		fkeys[FIN_FKEYS].fkey[ D_FK_NO5].disabled_flg=false
		fkeys[FIN_FKEYS].fkey[ D_FK_NO6].disabled_flg=false
		fkeys[FIN_FKEYS].fkey[ D_FK_NO7].disabled_flg=false
	end

	if(pass_chn_data.h_prog_code.ne.P_COD_MACH_NO_SPC_TI) then
	begin
		if(fin_dep_inv_no) then
		begin
			if(vi_iorc) then
			begin
				fkeys[FIN_FKEYS].fkey[D_FK_NO6].fk_disp='Rpt Crd'
				fkeys[FIN_FKEYS].fkey[D_FK_NO7].fk_disp='Dep Inv'
			end
			else
			begin
				fkeys[FIN_FKEYS].fkey[D_FK_NO6].fk_disp='Rpt Inv'
				fkeys[FIN_FKEYS].fkey[D_FK_NO7].fk_disp='Dep Crd'
			end
			if(pass_gen_data.adv_mode .ne. D_VEW_MODE )
				fkeys[FIN_FKEYS].fkey[D_FK_NO7].disabled_flg = false
			; allow reprint even if view mode
			fkeys[FIN_FKEYS].fkey[D_FK_NO6].disabled_flg = false
		end
		else
		begin
			if(pass_gen_data.adv_mode .ne. D_VEW_MODE )
			begin
				if(vi_iorc) then
					fkeys[FIN_FKEYS].fkey[D_FK_NO6].fk_disp='Dep Crd'
				else
					fkeys[FIN_FKEYS].fkey[D_FK_NO6].fk_disp='Dep Inv'
				fkeys[FIN_FKEYS].fkey[D_FK_NO7].disabled_flg = true
			end
		end
	end
	else
	begin
		fkeys[FIN_FKEYS].fkey[D_FK_NO6].disabled_flg = true
		fkeys[FIN_FKEYS].fkey[D_FK_NO7].disabled_flg = true
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this sets the deposit function keys to for input and disables
        ;       the non input function keys
	set_deposit_fkeys_input,

	; INPUT KEYS
	fkeys[FIN_FKEYS].fkey[ D_FK_NO2].disabled_flg=false
	fkeys[FIN_FKEYS].fkey[ D_FK_NO3].disabled_flg=false
	fkeys[FIN_FKEYS].fkey[ D_FK_NO4].disabled_flg=false
	fkeys[FIN_FKEYS].fkey[ D_FK_NO8].disabled_flg=false

	; SELECTION KEYS
	fkeys[FIN_FKEYS].fkey[ D_FK_NO5].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO6].disabled_flg=true
	fkeys[FIN_FKEYS].fkey[ D_FK_NO7].disabled_flg=true

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section controls the importation of a standard story into
        ;       the comments fields
	import_story,
	if(g_fldnam.ne.'FIN_DEPOSIT_DESC'.and.
	&  g_fldnam.ne.'FIN_PX_FIN_DESC')
	begin
		xcall ibc_message('This function is only available when you are on the'
		&                 +' description fields')
		return
	end

	if((g_fldnam.eq.'FIN_DEPOSIT_DESC'.and.fin_deposit_desc).or.
	&  (g_fldnam.eq.'FIN_PX_FIN_DESC'.and.fin_px_fin_desc))
	begin
		xcall ibc_message('This function is only available when the'
		&                 +' description field is currently blank')
		return

	end

	h_fldnam=g_fldnam
	call import_standard_story
	xcall i_next(a_wndid,'tab_set',h_fldnam)
	return

	;;;;;;;;;;;;;;;;;;;; Bring in standard lines ;;;;;;;;;;;;;;;;;;;;;;;;;;
	import_standard_story,
	csp_comtype = CMNT_WG_DEP_FIN_STY
	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )

	xcall ibc_ldinp( imp_id, g_utlib, 'ist_cmnt_i', , search )

	clear imp_quitting,imp_done
	do
	begin
		xcall i_init( imp_id )
		xcall ibc_input( imp_id, , standard_no, gold_inp_id ,,,D_NOTERM)

		if( g_select .AND. g_entnam .EQ. 'J_QUIT' ) then
			imp_quitting = TRUE
		else
		begin
			reject = false
			if( .NOT. reject )
			begin
				StandardStory.Type = CMNT_WG_DEP_FIN_STY
				StandardStory.Code = standard_no
				if !%ScratchPadCheck(CMNT_STANDARD_STORY,StandardStory)
					xcall ibc_message( T$STND_NOT_FND, D_BELL )
				else
					imp_done = TRUE
			end
		end
	end
	until( imp_done .OR. imp_quitting )

	if(.NOT.imp_quitting)
	begin
		call standard_comment_insert
	end

	xcall e_exit

	return
	;;;;;;;;;;;;;;;;; Copy comments in from another record ;;;;;;;;;;;;;;;
	standard_comment_insert,
	begin
		lLines = new ArrayList()
		xcall ScratchPadPrintLines(CMNT_STANDARD_STORY,StandardStory,lLines,32,0)
		if lLines != ^null
		begin
			if lLines.Count > 10
				xcall ibc_message('Warning - not all the standard comment lines'
				&     +' for the selection can be imported as there are more'
				&     +' than 10 lines.')
			clear tmp_desc[]
			foreach lString in lLines
			begin
				tmp_desc[lLoop] = lString
				incr lLoop
				if lLoop > 10
					exitloop
			end
		end
	end

	if(h_fldnam.eq.'FIN_DEPOSIT_DESC') then
	begin
		fin_deposit_desc[]=tmp_desc[]
	end
	else
	begin
		fin_px_fin_desc[]=tmp_desc[]
	end
	xcall i_putfld(a_wndid, 'tab_set', whgine_hdr, h_fldnam,
	&              tmp_desc, gold_com)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       validate supplier details
	validate_supplier,
	clear reject
	fin_px_fin_supp=fin_px_fin_supp [RIGHT]
	onerror inval_sup_numeric
	smf_supp_acc=fin_px_fin_supp
	offerror
	if(.not.smf_supp_acc) then
		clear suprec
	else
	begin
		xcall file(pass_chn_data.chn(SMF_FILE),suprec,smf_supp_acc,'RD',err)
		if(err) then
		begin
			smf_nickname='Not Found'
			inval_sup_numeric,
			offerror
			reject=true
			clear suprec
		end
	end
	fin_supp_nick=smf_nickname
	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_get_main_wgd, ^val
	main_wgd,           a
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'

	record general
		.include 'whgine_lst' repository, group='whgine_lst'
	record ifours
		err,            i4
		req,            i4
		linp_id,        i4
.proc
	clear general, ^i(ifours)
	clear main_wgd
	xcall l_status(seq_lst_id, D_LINPID, linp_id)
	xcall l_data(seq_lst_id,D_LFIRST,linp_id,whgine_lst,,err)
	while .not. err
	begin
		if lst_ntype .eq. D_VJ_WGD .and. lst_stkno
		begin
			main_wgd=lst_stkno
			exitloop
		end
		xcall l_data(seq_lst_id,D_LNEXT,linp_id,whgine_lst,,err)
	end
	xcall l_process( seq_lst_id, req = D_LRESTORE, whgine_lst,, gold_com,
	&            gold_ax,, whgine_passed)

	freturn err

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.subroutine whgine_proc_stg_pay
	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal
	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	record gen
		.include 'vbrec' repository, group='vbrec'
		err,            d3
	record ifours
		num_trd_items,	i4
.proc
	clear gen, ^i(ifours)
	xcall l_status(trd_lst_id,  D_LLASTITM, num_trd_items)
	if(.not.num_trd_items)
	begin
		xcall file(pass_chn_data.chn(VB_FILE),vbrec,whgine_hdr.vi_job,'RD',err,,,,,D_NO_LOCK)
		if(vbrec.vbjob.ne.whgine_hdr.vi_job) then
			clear num_trd_items
		else
			num_trd_items = true
	end
	if(.not.num_trd_items)
		err=%whgine_get_main_wgd(whgine_passed.wgd_stg_proc_ids_grp.main_wgd_no, gold_com,gold_ax,whgine_passed)
	if(pass_gen_data.h_status.lt.D_ADV_INVOICED
	&    .and.pass_gen_data.adv_mode .ne. D_VEW_MODE
	&    .and.vi_iorc.eq.D_VIIVCR_INVOICE
	&    .and. whgine_passed.wgd_stg_proc_ids_grp.main_wgd_no
	&    .and..not.num_trd_items
	&    .and..not.(fin_deposit_amt.or.fin_deposit_desc.or.fin_px_fin_sett)) then
		whgine_passed.wgd_stg_proc_ids_grp.f_ok_stg_allowed=true
	else
		whgine_passed.wgd_stg_proc_ids_grp.f_ok_stg_allowed=false

	xcall ibctab_highlight(tabset_id, true, tabhdr_id)

	whgine_passed.wgd_stg_proc_ids_grp.tot_wgd_inv = whgine_hdr.inv_nett
	whgine_passed.wgd_stg_proc_ids_grp.wgd_advice_no = whgine_hdr.vi_job
	xcall wgd_stg_pay_proc(whgine_passed.wgd_stg_proc_ids_grp,
	&    fkeys[STG_INP_FKEYS],  fkeys[STG_LST_FKEYS], gold_com, gold_ax)

	if(g_select.and.g_entnam.eq.D_VSP_FIN_INV)
	begin
		xcall m_signal('J_INV')
	end
	xcall ibctab_highlight(tabset_id, false)
	if(fkeys[STG_LST_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[STG_LST_FKEYS].fkmnu_id)

	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.subroutine whgine_proc_oip
	a_wndid ,n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'


	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VMREC.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	record gen
		.include 'vmrec' repository, group = 'old_vmrec'
		main_wgd,       a8

	.align
	record ids
		gen_chn,                i4
		err,                    i4
		f_lock,                 i4
.proc
	clear gen, ^i(ids)

	xcall ibctab_highlight(gold_com.TabSet_id,TRUE,gold_com.tabhdr_id)

	err=%whgine_get_main_wgd(main_wgd, gold_com,gold_ax,whgine_passed)

	if(main_wgd) then
	begin
		gen_chn=pass_chn_data.chn(VM_FILE)
		xcall file(gen_chn, vmrec, main_wgd, 'RD', err,,,,,D_NO_LOCK)
		if(err) gen_chn=pass_chn_data.chn(HM_FILE)
		if(err) xcall file(gen_chn, vmrec, main_wgd, 'RD', err,,,,,D_NO_LOCK)
		if(err)
			clear vmrec, main_wgd
	end
	else
		clear vmrec

	if( vmrec.vmcust.ne.whgine_hdr.vi_cusacc)
		vmrec.vmcust=whgine_hdr.vi_cusacc
	old_vmrec=vmrec
	if(pass_gen_data.adv_mode .eq. D_VEW_MODE.or..not.main_wgd)then
		xcall wgd_oip(vmrec, vmrec.vmstok, false, true,  false,,gold_com.tabhdr_id,a_wndid,,fkeys[OIP_FKEYS])
	else
		xcall wgd_oip(vmrec, vmrec.vmstok, false, false, false,,gold_com.tabhdr_id,a_wndid,,fkeys[OIP_FKEYS])
	if(old_vmrec.ne.vmrec.and.vmrec.vmstok)
	begin
		xcall file(gen_chn, old_vmrec, main_wgd, 'RD', err,,,f_lock)
		if(err)
			xcall ibc_message('Unexpected read error for {W} '+%atrim(main_wgd)
			&        +' - Record not updated')
		if(f_lock) exit
		old_vmrec.vm_end_user_cus=vmrec.vm_end_user_cus
		; note at time of writing - vmcust was disabled
		if(old_vmrec.vmcust.ne.vmrec.vmcust)
		begin
			xcall vm_cust_trk_update(vmrec.vmstok, Old_Vmrec.vmcust, Vmrec.vmcust, gold_com)
		end
		old_vmrec.vmcust=vmrec.vmcust
		old_vmrec.vm_funding_cust=vmrec.vm_funding_cust
		; if successful, will write away changes
		xcall file(gen_chn, old_vmrec, , 'WR', err)
	end

	xcall ibctab_highlight(gold_com.TabSet_id,FALSE)

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_proc_seq

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group= 'whgine_vb'
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_vj' repository, group= 'whgine_nstk'

	.include 'DBLDIR:activex.def'
	.include 'SRC:OPSCOM.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal


	record gen
		err,            d3
		tmp_stock,      a8
		seq_sel,        a1
		hide_sel,       a1
		hide_typ,       d1
		hide_det,       d1
		group opt_array
			opt_data,      6a24
		endgroup
		loop,           d2
		h_hide,         d1
		line_no,        d3

	record ifours
		req,            i4
		linp_id,        i4
		seq_sel_id,     i4
		hide_sel_id,    i4
		axctl_id,       i4

.proc
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	xcall u_update(false)
	xcall l_status(a_wndid, D_LINPID, linp_id, D_LAXCTRL, axctl_id)
	xcall ax_call(axctl_id, "GridRepaint")
	seq_fkeys_active = true
	fkeys[SEQ_FKEYS].fkey[D_FK_NO2].disabled_flg = pass_gen_data.adv_mode .eq. D_VEW_MODE
	req = D_LNOP
	xcall e_state(D_OFF, D_RETURNBTN)
	repeat
	begin
		xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed, whgine_hdr,
		&                         whgine_inv_tab, add_part_passed, invoice_totals)
		xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed, whgine_hdr,
		&                         whgine_inv_tab)
		xcall l_process(a_wndid, req = D_LRESTORE, whgine_lst,,
		&           gold_com, gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

		xcall set_seq_fkeys(gold_com, gold_ax, fkeys[SEQ_FKEYS],
		&                   seq_lst_id, whgine_lst, whgine_passed)
		xcall lbc_select(seq_lst_id, req, whgine_lst,,,,,,,,,,,,,
		&                fkeys[SEQ_FKEYS], gold_com, gold_ax,
		&                fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
		if g_select then
		begin
			using g_entnam select
				('J_INS','LST_INSERT'),
				begin
					clear seq_inserting
					call seq_insert
					if seq_inserting
						exitloop
				end
				('J_QUIT'),       exitloop
				('D_LMOVEUP'),    begin
					xcall l_process(seq_lst_id,req=D_LMOVEUP,whgine_lst,,
					&               gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
					items_moded = true
					lst_moded = TRUE
					for loop from 1 thru 5
						reseq_req[loop] = true
					if (whgine_lst.lst_ntype.eq.D_VJ_TRADE)
					begin
						xcall l_process(trd_lst_id,req=D_LMOVEUP,whgine_vb,,gold_com,gold_ax,
						&               fkeys[TRD_FKEYS],whgine_passed,fkeys,whgine_lst,
						&               whgine_hdr, whgine_inv_tab,add_part_passed, invoice_totals)
						xcall l_status(trd_lst_id,D_LCURITM,line_no)
						if (line_no.eq.1)
							clear lst_hide, vb_hide_ln
						xcall l_process(seq_lst_id,req=D_LNOP,whgine_lst,,
						&                   gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
						call set_hide_on_detail_line
					end
				end

				('D_LMOVEDN'),    begin
					lst_moded = TRUE
					xcall l_process(seq_lst_id,req=D_LMOVEDN,whgine_lst,,
					&               gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
					items_moded = true
					for loop from 1 thru 5
						reseq_req[loop] = true
					xcall l_process(seq_lst_id,req=D_LUP,whgine_lst,,
					&               gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
					if (whgine_lst.lst_ntype.eq.D_VJ_TRADE)
					begin
						xcall l_process(trd_lst_id,req=D_LMOVEDN,whgine_vb,,gold_com,gold_ax,
						&               fkeys[TRD_FKEYS],whgine_passed,fkeys,whgine_lst,
						&               whgine_hdr, whgine_inv_tab,add_part_passed, invoice_totals)
						xcall l_process(trd_lst_id,req=D_LTOP,whgine_vb,,gold_com,gold_ax,
						&               fkeys[TRD_FKEYS],whgine_passed,fkeys,whgine_lst,
						&               whgine_hdr, whgine_inv_tab,add_part_passed, invoice_totals)

						clear lst_hide, vb_hide_ln
						lst_moded = TRUE
						xcall l_process(seq_lst_id,req=D_LNOP,whgine_lst,,
						&                   gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
						call set_hide_on_detail_line
					end
					xcall l_process(seq_lst_id,req=D_LDOWN,whgine_lst,,
					&               gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
				end
				('J_HIDE_ALL'),   call hide_all
				('J_HIDE'),       call hide_unhide
				(),               exitloop
			endusing
		end
		else
		begin
			; note replace lst_tstk with tmp_stock
			do_find = true
			tmp_stock=lst_tstk
			case lst_ntype of
			begincase
				D_VJ_WGD:         begin
					xcall m_signal('WGD_TAB')
					xcall l_findspec(wgd_lst_id, tmp_stock, 2,,,,, D_LFND_CURR,
					&                D_LFND_WRAP)
				end
				D_VJ_NSTK:        begin
					xcall m_signal('NSTK_TAB')
					xcall l_findspec(nstk_lst_id, tmp_stock, 1,,,,, D_LFND_CURR,
					&                D_LFND_WRAP)
				end
				D_VJ_PART:        begin
					xcall m_signal('PART_TAB')
					xcall l_findspec(prt_lst_id, tmp_stock, 318, 8,,,,
					&                D_LFND_CURR, D_LFND_WRAP)
				end
				D_VJ_COMMENT:     begin
					xcall m_signal('CMNT_TAB')
					xcall l_findspec(cmnt_lst_id, tmp_stock(5:4),
					&           97,,,,, D_LFND_CURR, D_LFND_WRAP)
					xcall l_process(cmnt_lst_id, REQ, whgine_cmnt_lst,, gold_com, gold_ax,
					&           fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)
				end
				D_VJ_TRADE:       begin
					xcall m_signal('TRD_TAB')
					xcall l_findspec(trd_lst_id, tmp_stock, 1,,,,, D_LFND_CURR,
					&                D_LFND_WRAP)
				end
			endcase
			exitloop
		end
	end
	clear seq_fkeys_active
	xcall e_state(D_ON, D_RETURNBTN)
	xcall ibctab_highlight(tabset_id, false)
	xcall ibc_column(D_REMOVE, fkeys[SEQ_FKEYS].fkmnu_id)

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	seq_insert,
	;       MAIN WG
	;       TRADE IN
	;       NON STOCKED
	;       PART
	;       COMMENT

	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )

	; set up data to build selection list depending on status of wholegood
	clear opt_array, loop
	pass_chn_data.line_mode=D_INS_MODE

	if(pass_gen_data.plan_maint) then
		call set_plan_maint_options
	else
		call set_wgd_sbill_options
	if(.not.loop)
	begin
		xcall e_exit
		xcall ibc_message('Lines may not be added yet')
		return
	end

	; Test if there is only one add option and if so then do not need to show
	; the selection window. Instead, dive straight into the option

	if(loop.eq.1)
		seq_sel = opt_data(1)
	else
	begin
		xcall s_selbld(seq_sel_id,"whgine_sel",loop,loop,opt_data)
		xcall u_logwnd(seq_sel_id)
		xcall w_brdr(seq_sel_id, WB_TITLE, ' Select Option ',
		&            WB_TPOS, WBT_TOP, WBT_CENTER)
		xcall ibc_window( D_PLACE, seq_sel_id, 13, 30 )
		xcall ibc_select(seq_sel_id, 1, seq_sel, gold_sel_id)
	end
	xcall ibc_window(D_DELETE, seq_sel_id)
	if g_entnam .eq. 'J_QUIT'
	begin
		xcall e_exit
		return
	end
	case seq_sel of
	begincase
		'M':      begin
			; IF PARTIAL INVOICE - DO NOT ROLL INPUT - USER CAN ONLY HAVE 1 WGD ITEM
			if(pass_gen_data.h_ivcr.eq.D_VIIVCR_PART_INV)
			begin
				xcall l_status(wgd_lst_id, D_LLASTITM, line_no)
				if (line_no.gt.0)
				begin
					xcall ibc_message('Invalid - You can only add a single,'
					&	+' already invoiced {WHOLEGD} item with a Partial Invoice.'
					&	+'  Other line types are unrestricted.')
					xcall e_exit
					return
				end
			end
			seq_inserting = true
			xcall m_signal('WGD_TAB')
		end
		'P':      begin
			seq_inserting = true
			xcall m_signal('PART_TAB')
		end
		'N':      begin
			seq_inserting = true
			xcall m_signal('NSTK_TAB')
		end
		'C':      begin
			seq_inserting = true
			xcall m_signal('CMNT_TAB')
		end
		'T':      begin
			seq_inserting = true
			xcall m_signal('TRD_TAB')
		end
	endcase
	trd_cmnt_flg = lst_trd_cmnt
	xcall e_exit
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_plan_maint_options,
	if(pass_chn_data.h_prog_code.ne.P_PM_CONTRACT)
		XCALL IBC_MESSAGE('INVALID PROGRAM CODE FOR THIS OPTION')

	if(.not.(vi_iorc.eq.D_VIIVCR_PART_CRED.and..not.line_count))
	begin
		incr loop
		opt_data(loop)='Normal PM Equip Line '

		incr loop
		opt_data(loop)='Part'

		if(vi_iorc .ne. D_VIIVCR_PART_CRED)
		begin
			incr loop
			opt_data(loop) = 'Comment'
		end
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_wgd_sbill_options,
	if(pass_chn_data.h_prog_code.ne.P_COD_SEL_BILL.and. .not. lst_trd_cmnt)         ; self bill only
	begin
		incr loop
		opt_data(loop)='Main {WHOLEGD}'
	end
	if .not. f_quick_entry
	begin
		if((line_count.or. pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL)
		&  .and.vi_iorc.ne.D_VIIVCR_PART_CRED
		&  .and.pass_chn_data.h_prog_code.ne.P_COD_MACH_NO_SPC_TI)
		begin
			if whgine_passed.f_vsp_exists exit
			incr loop
			opt_data(loop)='Trade In'
		end
		; self bill only
		if(pass_chn_data.h_prog_code.ne.P_COD_SEL_BILL
		&  .and..not.(vi_iorc.eq.D_VIIVCR_PART_CRED.and..not.line_count))
		begin
			if .not. lst_trd_cmnt
			begin
				incr loop
				opt_data(loop)='Non Stocked {WHOLEGD}'

				incr loop
				opt_data(loop)='Part'
			end
		end
		if(vi_iorc .ne. D_VIIVCR_PART_CRED)
		begin
			incr loop
			opt_data(loop) = 'Comment'
		end

		; just enter one type
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	hide_unhide,
	hide_det = lst_ntype .ne. D_VJ_COMMENT
	call get_hide_sel
	if (hide_typ .ne. -1)
	begin
		h_hide = lst_hide_alw
		lst_hide_alw = hide_typ
		set lst_moded, items_moded = true
		xcall i_display(linp_id,,whgine_lst)
		xcall l_process(seq_lst_id,req=D_LNOP,whgine_lst,,
		&               gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
		if (whgine_lst.lst_ntype.eq.D_VJ_TRADE)
		begin
			xcall l_remove(trd_lst_id)
			xcall l_findspec(trd_lst_id, lst_tstk, 1, , , , , D_LFND_CURR,
			&                D_LFND_WRAP,D_LFND_DISPLAY)
			req = D_LFIND
			xcall l_process(trd_lst_id,req,whgine_vb,,gold_com,gold_ax,
			&               fkeys[TRD_FKEYS],whgine_passed,fkeys,whgine_lst,
			&               whgine_hdr,whgine_inv_tab,add_part_passed, invoice_totals)
			req = D_LNOP
			xcall l_status(trd_lst_id,D_LCURITM,line_no)
			if (line_no.eq.1.and.lst_hide)
			begin
				xcall ibc_message('Cannot Hide First Trade In Line')
				lst_hide = FALSE
				xcall l_process(seq_lst_id,req=D_LNOP,whgine_lst,,
				&           gold_com,gold_ax,fkeys[SEQ_FKEYS],whgine_passed, invoice_totals)
			end
		end
		if (h_hide.ne.lst_hide_alw)
			call set_hide_on_detail_line
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	hide_all,
	; mark current position
	hide_det = 2
	call get_hide_sel
	if (hide_typ .eq. -1)
		return
	xcall l_data(a_wndid,D_LFIRST,linp_id,whgine_lst,,err)
	while .not. err
	begin
		h_hide = lst_hide_alw
		set lst_hide, lst_hide_att = hide_typ
		set lst_moded, items_moded = true
		xcall i_display(linp_id,,whgine_lst)
		if (h_hide.ne.lst_hide_alw)
			call set_hide_on_detail_line
		xcall l_data(a_wndid,D_LWRITE,linp_id,whgine_lst,,err)
		xcall l_data(a_wndid,D_LNEXT,linp_id,whgine_lst,,err)
	end
	call check_trd_in
	xcall l_process(a_wndid, req = D_LRESTORE, whgine_lst,,
	&               gold_com, gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
	check_trd_in,

	xcall l_data(a_wndid,D_LFIRST,linp_id,whgine_lst,,err)
	while .not. err
	begin
		if (whgine_lst.lst_ntype.eq.D_VJ_TRADE)
		begin
			xcall l_remove(trd_lst_id)
			xcall l_findspec(trd_lst_id, lst_tstk, 1, , , , , D_LFND_CURR,
			&                D_LFND_WRAP,D_LFND_DISPLAY)
			req = D_LFIND
			xcall l_process(trd_lst_id,req,whgine_vb,,gold_com,gold_ax,
			&               fkeys[TRD_FKEYS],whgine_passed,fkeys,whgine_lst,
			&               whgine_hdr,whgine_inv_tab,add_part_passed, invoice_totals)
			req = D_LNOP
			xcall l_status(trd_lst_id,D_LCURITM,line_no)
			if (line_no.eq.1.and.lst_hide)
			begin
				xcall ibc_message('Cannot Hide First Trade In Line')
				lst_hide = FALSE
				xcall l_data(a_wndid,D_LWRITE,linp_id,whgine_lst,,err)
				req = D_LNOP
				vb_hide_ln = lst_hide
				xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
				&               fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
				&               whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)
			end
		end
		xcall l_data(a_wndid,D_LNEXT,linp_id,whgine_lst,,err)
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	set_hide_on_detail_line,
	case lst_ntype of
	begincase
		D_VJ_WGD:     begin
			xcall l_remove(wgd_lst_id)
			xcall l_findspec(wgd_lst_id, lst_tstk, 2,,,,, D_LFND_CURR,
			&                    D_LFND_WRAP, D_LFND_DISPLAY)
			req = D_LFIND
			xcall l_process(wgd_lst_id, req, whgine_vj,, gold_com, gold_ax,
			&               fkeys[WGD_FKEYS], whgine_passed, fkeys, whgine_lst,
			&               whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)
			req = D_LNOP
			whgine_vj.vj_hide_ln=lst_hide
			xcall l_process(wgd_lst_id, req, whgine_vj,, gold_com, gold_ax,
			&               fkeys[WGD_FKEYS], whgine_passed, fkeys, whgine_lst,
			&               whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)
		end
		D_VJ_NSTK:    begin
			xcall l_remove(nstk_lst_id)
			xcall l_findspec(nstk_lst_id, lst_tstk, 1,,,,, D_LFND_CURR,
			&                    D_LFND_WRAP, D_LFND_DISPLAY)
			req = D_LFIND
			xcall l_process(nstk_lst_id, req, whgine_nstk,, gold_com, gold_ax,
			&               fkeys[NSTK_FKEYS], whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
			&       whgine_hdr, add_part_passed, invoice_totals)
			req = D_LNOP
			whgine_nstk.vj_hide_ln=lst_hide
			xcall l_process(nstk_lst_id, req, whgine_nstk,, gold_com, gold_ax,
			&               fkeys[NSTK_FKEYS], whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
			&       whgine_hdr, add_part_passed, invoice_totals)
		end
		D_VJ_PART:    begin
			xcall l_remove(prt_lst_id)
			xcall l_findspec(prt_lst_id, lst_tstk, 318, 8,,,,
			&                    D_LFND_CURR, D_LFND_WRAP)
			req = D_LFIND
			xcall l_process(prt_lst_id, req, part_data,,gold_com, gold_ax,
			&              fkeys[PRTLST_FKEYS], add_part_passed, invoice_totals,
			&              pass_chn_data.chn, whgine_passed, fkeys, whgine_lst,
			&              whgine_inv_tab, whgine_hdr)
			req = D_LNOP
			part_adv_seq=lst_hide
			xcall l_process(prt_lst_id, req, part_data,,gold_com, gold_ax,
			&              fkeys[PRTLST_FKEYS], add_part_passed, invoice_totals,
			&              pass_chn_data.chn, whgine_passed, fkeys, whgine_lst,
			&              whgine_inv_tab, whgine_hdr)
		end
		D_VJ_COMMENT: begin
			xcall l_remove(cmnt_lst_id)
			xcall l_findspec(cmnt_lst_id, lst_tstk(5:4),
			&               97,,,,, D_LFND_CURR, D_LFND_WRAP)
			req = D_LFIND
			xcall l_process(cmnt_lst_id, req, whgine_cmnt_lst,, gold_com, gold_ax,
			&               fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)
			req = D_LNOP
			cmnt_hide = lst_hide
			xcall l_process(cmnt_lst_id, req, whgine_cmnt_lst,, gold_com, gold_ax,
			&               fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)
		end
		D_VJ_TRADE:   begin
			xcall l_remove(trd_lst_id)
			xcall l_findspec(trd_lst_id, lst_tstk, 1, , , , , D_LFND_CURR,
			&                    D_LFND_WRAP, D_LFND_DISPLAY)
			req = D_LFIND

			xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
			&               fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
			&               whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)
			req = D_LNOP
			vb_hide_ln = lst_hide
			xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
			&               fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
			&               whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)
		end
	endcase
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	get_hide_sel,
	if hide_det .eq. 1
		xcall u_ldwnd(hide_sel_id, g_utlib, 'hidedet_sel')
	else
		xcall u_ldwnd(hide_sel_id, g_utlib, 'hide_sel')
	if hide_det .eq. 2
		xcall w_brdr(hide_sel_id, WB_TON, WB_TITLE, ' Hide All Items ? ')
	xcall ibc_select(hide_sel_id, 1, hide_sel, gold_sel_id)
	xcall ibc_window(D_DELETE, hide_sel_id)
	if g_entnam .eq. 'J_QUIT'
		hide_typ = -1
	case hide_sel of
	begincase
		'N':      hide_typ = 0
		'Y':      hide_typ = 1
		'D':      hide_typ = 2
	endcase

	return
.end

.subroutine whgine_proc_inv

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:FCFREC.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	record gen
		chr,            a1
		.include 'whgine_inv_tab' repository, group= 'copy_whgine_inv_tab', nofields
.proc
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	xcall u_update(false)

	gold_com.cur_flag = pass_gen_data.curr_dsp

	xcall whgine_get_customer_dets

	adv_cust = cmf_acc_no

	if( cmf_inv_mthd == CMF_INV_MTHD_CASH && vi_cusnam)
	begin
		adv_cusnam = vi_cusnam
		adv_cusadd[] = vi_cusadd[]
		clear adv_postcd
	end
	else
	begin
		adv_cusnam = cmf_name
		adv_cusadd[] = cmf_address[]
		adv_postcd = cmf_post_cd
	end
	adv_phone = cmf_tel_no
	adv_mobile = cmf_alt_teln
	adv_fax = cmf_fax
	adv_crlim = cmf_f_cred_lmt

	if pass_gen_data.adv_mode .eq. D_VEW_MODE then
	begin
		if .not. vi_iorc then
			set fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5].fk_disp,
			&    fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5].btn_disp = 'AutoCrd'
		else
			set fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5].fk_disp,
			&    fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5].btn_disp = 'AutoInv'
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO3].disabled_flg = true
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].disabled_flg = true
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5].disabled_flg = vi_dep .ne.
		&           gold_com.cur_depot.or.
		&           vi_iorc.eq.D_VIIVCR_PART_CRED.or.
		&           vi_iorc.eq.D_VIIVCR_PART_INV
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO6].disabled_flg = true
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].disabled_flg =
		&       pass_gen_data.vi_currency .eq. cms_base_cur
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO7].disabled_flg = true
	end
	else
	begin
		if(vi_iorc.eq.D_VIIVCR_INVOICE.or.
		&  vi_iorc.eq.D_VIIVCR_PART_INV) then
			set fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].fk_disp,
			&    fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].btn_disp = 'Invoice'
		else
			set fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].fk_disp,
			&    fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].btn_disp = 'Credit'
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO3].disabled_flg = false
		if(whgine_passed.f_vsp_exists) then
			fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].disabled_flg = true
		else
			fkeys[INV_TAB_FKEYS].fkey[D_FK_NO4].disabled_flg = false
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO5].disabled_flg = true
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO6].disabled_flg = false
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO7].disabled_flg = false
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].disabled_flg =
		&       pass_gen_data.vi_currency .eq. cms_base_cur
		fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].disabled_flg = false
	end

	if pass_gen_data.vi_currency .ne. cms_base_cur then
	begin
		if .not. pass_gen_data.curr_dsp then
			fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = cms_base_cur
		else
			fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = pass_gen_data.vi_currency
	end
	else
	begin
		if( cms_euro_code .and. cms_euro_code.nes.cms_base_cur )
			fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = cms_euro_code
	end

	xcall ibc_fkeys(a_wndid, fkeys[INV_TAB_FKEYS])
	if(wg_security .ne. ACC_NO_COST_DISP.and..not. pass_gen_data.plan_maint
	&   .and.whgine_passed.f_acc_wg_exclude.ne.0)
	begin
		if(whgine_passed.f_acc_wg_exclude.eq.2)
		begin
			clear adv_t_cost
			clear adv_t_mrg
			clear adv_tot_mrg
			clear adv_t_mrg_pcnt
			clear prt_t_cost
			clear prt_t_mrg
			clear prt_t_mrg_pcnt
			clear adv_tot_cost
			clear adv_tot_mrg
			clear adv_tot_mrg_pcnt
			clear sb_t_cost_fc
			clear sb_t_mrg
			clear sb_t_mrg_pcnt
		end
		copy_whgine_inv_tab=whgine_inv_tab
		if(whgine_passed.f_acc_wg_exclude.eq.2) then
		begin
			xcall i_fldmod(a_wndid, 'ADV_T_COST'      ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_T_MRG'       ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_T_MRG_PCNT'  ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'PRT_T_COST'      ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'PRT_T_MRG'       ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'PRT_T_MRG_PCNT'  ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_TOT_COST'    ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_TOT_MRG'     ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_TOT_MRG_PCNT',,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'SB_T_COST_FC'    ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'SB_T_MRG'        ,,,D_ON, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'SB_T_MRG_PCNT'   ,,,D_ON, D_FLD_BZRO )
		end
		else
		begin
			xcall i_fldmod(a_wndid, 'ADV_T_COST'      ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_T_MRG'       ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_T_MRG_PCNT'  ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'PRT_T_COST'      ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'PRT_T_MRG'       ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'PRT_T_MRG_PCNT'  ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_TOT_COST'    ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_TOT_MRG'     ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'ADV_TOT_MRG_PCNT',,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'SB_T_COST_FC'    ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'SB_T_MRG'        ,,,D_OFF, D_FLD_BZRO )
			xcall i_fldmod(a_wndid, 'SB_T_MRG_PCNT'   ,,,D_OFF, D_FLD_BZRO )
		end
		whgine_inv_tab=copy_whgine_inv_tab
	end
	xcall i_display(a_wndid,, whgine_inv_tab,,,,,,,,,, gold_com, gold_ax,
	&               whgine_passed)

	xcall i_frames(a_wndid)
	repeat
	begin
		xcall ibc_chr(chr, a_wndid,,,,, fkeys[INV_TAB_FKEYS])
		if g_select
		begin
			case g_entnam of
			begincase
				'J_QUIT':         exitloop
				'J_CURR_FC':      begin
					pass_gen_data.curr_dsp = .not. pass_gen_data.curr_dsp
					if .not. pass_gen_data.curr_dsp then
					begin
						if pass_gen_data.vi_currency .eq. cms_base_cur .and. cms_euro_code then
							fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = cms_euro_code
						else
							fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = cms_base_cur
						xcall disp_curr(pass_gen_data.vi_currency)
					end
					else
					begin
						if pass_gen_data.vi_currency .eq. cms_base_cur .and. cms_euro_code then
						begin
							fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = pass_gen_data.vi_currency
							xcall disp_curr(cms_euro_code)
						end
						else
						begin
							fkeys[INV_TAB_FKEYS].fkey[D_FK_NO8].btn_disp = pass_gen_data.vi_currency
							xcall disp_curr(cms_base_cur)
							; note - there wasa problem with the display when
							; currency fc but wanted base
							fcf_std_rate=pass_gen_data.vi_exch_rate
						end
					end
					xcall i_display(a_wndid,, whgine_inv_tab,,,,,,,,,, gold_com,
					&               gold_ax, whgine_passed)
					xcall ibc_fkeys(a_wndid, fkeys[INV_TAB_FKEYS])

				end
			endcase
			else
				exitloop
		end
	end
	gold_com.cur_flag = 0
	xcall ibctab_highlight(tabset_id, false)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Process SMS Message tab
;
.subroutine whgine_proc_sms, reentrant

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group= 'whgine_vb'
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_vj' repository, group= 'whgine_nstk'
	.include 'doclst_pass' repository, group = 'doclst_pass'
	.include 'doc_search' repository, group='doc_search'
	.include 'smslst_pass' repository, group = 'smslst_pass'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	record tmp
		hold_scut_avail,	d1

.proc
	xcall ibctab_highlight(gold_com.tabset_id, true, gold_com.tabhdr_id)

	scut_avail = %get_shortcut
	hold_scut_avail = scut_avail
	xcall shortcut_off

	xcall sms_list( gold_com, gold_ax, a_wndid, fkeys[SMS_FKEYS], smslst_pass )

	scut_avail = hold_scut_avail
	if (scut_avail)
		xcall shortcut_on

	xcall ibctab_highlight(gold_com.tabset_id, false)
	xreturn
.end

.subroutine whgine_proc_cmnt

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3
		rtn_to_seq,     d1
		edit_opts,      a6

	record ifours
		req,            i4

.proc
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	edit_opts = 'IADNP'
	if pass_gen_data.adv_mode .eq. D_VEW_MODE then
		edit_opts = 'IADV'
	else
	begin
		if seq_inserting
		begin
			roll_input = D_INS_MODE
			rtn_to_seq = true
			edit_opts = 'IADNPE'
		end
		if do_find
		begin
			rtn_to_seq = true
			roll_input = D_AMD_MODE
			edit_opts = 'IADNPE'
		end
	end
	if reseq_req[D_VJ_COMMENT+1]
	begin
		xcall lbc_restart(a_wndid)
		reseq_req[D_VJ_COMMENT+1] = false
		xcall l_queue( a_wndid, D_LBOTTOM, D_LTOP )
	end

	if do_find
		req = D_LFIND
	else
		req = D_LNOP
	xcall l_process(cmnt_lst_id, req, whgine_cmnt_lst,, gold_com, gold_ax,
	&               fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)

	repeat
	begin
		err = %listiad_proc(cmnt_lst_id, cmnt_linp_id, whgine_cmnt_lst,
		&       cmnt_iwnd_id,,,,, 'whgine_cmnt_upd',,, roll_input,, edit_opts,
		&       fkeys[CMNT_FKEYS], fkeys[CMNT_INP_FKEYS], gold_com,
		&       gold_ax, whgine_passed, fkeys, whgine_lst, invoice_totals)
		if err .eq. D_LIST_TERMINATED
			exitloop
		if g_select
		begin
			case g_entnam of
			begincase
				'J_QUIT':           exitloop
			endcase
			else
				exitloop
		end
	end
	xcall ibctab_highlight(tabset_id, false)
	if rtn_to_seq
		xcall m_signal('SEQ_TAB')
	clear do_find, seq_inserting, rtn_to_seq, roll_input
	; ap130207 - get rid of menu columns loaded buy above
	if(fkeys[CMNT_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[CMNT_FKEYS].fkmnu_id)

	xreturn
.end

.subroutine whgine_proc_wgd

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group= 'whgine_vb'
	.include 'whgine_vj' repository, group= 'whgine_vj'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal


	record gen
		.include 'vm_user' repository, group='vm_user'
		reject,         d1
		err,            d3
		disp_line,      a90
		rtn_to_seq,     d1
		edit_opts,      a6
		stkno,          a8
		attach_no,      a8

	record ifours
		req,            i4

.proc
	clear gen, ^i(ifours)
	edit_opts = 'IAD'
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)

	; only want to allow the transfer option if this is not a credit.
	; but - if a partial invoice, then do not allow the transfer option
	; if the current wholegood is in history

	fkeys[WGD_FKEYS].fkey[D_FK_NO5].disabled_flg =
	&    (pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL)

	fkeys[WGD_FKEYS].fkey[D_FK_NO6].disabled_flg =
	&       (pass_gen_data.adv_mode .eq. D_VEW_MODE.or.
	&       viivcr.eq.D_VIIVCR_CREDIT.and.viivcr.eq.D_VIIVCR_PART_CRED)

	fkeys[WGD_FKEYS].fkey[D_FK_NO7].disabled_flg =
	&       (pass_gen_data.adv_mode .eq. D_VEW_MODE.or.
	&       viivcr.eq.D_VIIVCR_CREDIT.or.viivcr.eq.D_VIIVCR_PART_CRED
	&       .or. pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL)
	if pass_gen_data.adv_mode .eq. D_VEW_MODE .or. pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL then
	begin
		edit_opts = 'IADV'
		fkeys[WGD_INP_FKEYS].fkey[D_FK_NO5].disabled_flg = true
	end
	else
	begin
		fkeys[WGD_INP_FKEYS].fkey[D_FK_NO5].disabled_flg = true
		if seq_inserting
		begin
			roll_input = D_INS_MODE
			rtn_to_seq = true
			edit_opts = 'IADE'
		end
		if do_find
		begin
			rtn_to_seq = true
			roll_input = D_AMD_MODE
			edit_opts = 'IADE'
		end
	end

	if reseq_req[D_VJ_WGD+1]
	begin
		xcall lbc_restart(a_wndid)
		reseq_req[D_VJ_WGD+1] = false
		xcall l_queue( a_wndid, D_LBOTTOM, D_LTOP )
	end

	if do_find then
		req = D_LFIND
	else
		req = D_LNOP

	xcall l_process(wgd_lst_id, req, whgine_vj,, gold_com, gold_ax,
	&               fkeys[WGD_FKEYS], whgine_passed, fkeys, whgine_lst,
	&               whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)

	call display_vj_screen

	if(f_quick_entry) then
	begin
		clear disp_line
		err=1
		if(last_quick_wg)
		begin
			disp_line='Last {W} '+last_quick_wg+' ('+%atrim(last_quick_desc)+')'
			err=%trim(disp_line)+2
		end
		disp_line(err:15)='Quick {WHOLEGD}'
	end
	else
		disp_line='Main {WHOLEGD}'

	repeat
	begin
		err = %listiad_proc(wgd_lst_id, wgd_linp_id, whgine_vj,
		&       0, 'wgd_inpset1',,, 'whgine_wgd_init', 'whgine_wgd_upd',
		&       'whgine_wgd_mnu', 'whgine_wgd_prc', roll_input, disp_line,
		&       edit_opts, fkeys[WGD_FKEYS], fkeys[WGD_INP_FKEYS], gold_com,
		&       gold_ax, whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
		&       whgine_hdr, add_part_passed, invoice_totals)
		if err .eq. D_LIST_TERMINATED .and. g_entnam .ne. 'J_NEW_TFR'
			exitloop
		if g_select
		begin
			case g_entnam of
			begincase
				'J_QUIT':           exitloop
				'J_TFR_ATT':      begin
					xcall m_signal(g_entnam)
					exitloop
				end
				'J_VEHGRN':       begin
					xcall m_signal(g_entnam)
					err = D_LIST_TERMINATED
					exitloop
				end
				'J_NEW_TFR':      begin
					clear stkno, attach_no
					xcall xsubr('VEHAMT', 'WHGINE', gold_com.cur_depot, stkno,
					&           attach_no,, reject, true)
					if .not. reject
					begin
						clear vjrec     ;????

						roll_input = D_INS_MODE
						new_tfr_no = stkno
					end
				end
			endcase
			else
				exitloop
		end
	end
	xcall ibctab_highlight(tabset_id, false)
	if rtn_to_seq
		xcall m_signal('SEQ_TAB')
	clear do_find, seq_inserting, rtn_to_seq, roll_input

	; ap130207 - get rid of menu columns loaded buy above
	if(fkeys[WGD_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[WGD_FKEYS].fkmnu_id)

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       display full vj screen ie. for main wg and non stocked wg
	display_vj_screen,

	xcall i_snapshot(D_LOAD, pass_gen_data.inp_vj_id, wgd_snap)
	if pass_gen_data.vi_currency .eq. cms_base_cur
	begin
		xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset',
		&   'vj_d_bc_mrrp,vj_bc_rrp,vj_bc_vi_rrp,vj_bc_disc,vj_bc_vi_disc,vj_bc_sett')
		if wg_security .ne. ACC_NO_COST_DISP
			xcall i_setdel(pass_gen_data.inp_vj_id, 'wgd_fullset',
			&            'vj_bc_ecos,vj_bc_cost')
	end

	xcall i_display(pass_gen_data.inp_vj_id, 'wgd_fullset', whgine_vj,,,,,,,,,, gold_com )

	if(wg_security .ne. ACC_NO_COST_DISP) then
	begin
		xcall i_dspfld(pass_gen_data.inp_vj_id,'vj_fc_ecos',vj_fc_ecos, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vj_id,'vj_fc_cost',vj_fc_cost, gold_com)
		if(pass_gen_data.vi_currency.ne.cms_base_cur)
		begin
			xcall i_dspfld(pass_gen_data.inp_vj_id,'vj_bc_ecos',vj_bc_ecos, gold_com)
			xcall i_dspfld(pass_gen_data.inp_vj_id,'vj_bc_cost',vj_bc_cost, gold_com)
		end
	end
	xcall evaluate_vj_hide_attach(whgine_vj, whgine_passed)
	xcall whgine_vj_curr_vals(gold_com, whgine_vj, pass_gen_data.inp_vj_id, whgine_passed, invoice_totals)
	return

.end

.subroutine whgine_proc_nstk

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group= 'whgine_vb'
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_vj' repository, group= 'whgine_nstk'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		.include 'vm_user' repository, group='vm_user'
		err,            d3
		rtn_to_seq,     d1
		input_set,      a12
		nstk_iad_opts,  a5
		list_title,     a40
	record ifours
		req,            i4

.proc
	clear gen, ^i(ifours)
	nstk_iad_opts = 'IADNP'
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	if pass_gen_data.adv_mode .eq. D_VEW_MODE .or. pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL .or.
	&       vi_iorc .eq. D_VIIVCR_PART_CRED then
		nstk_iad_opts = 'IADV'
	else
	begin
		if seq_inserting
		begin
			roll_input = D_INS_MODE
			rtn_to_seq = true
			nstk_iad_opts = 'IADE'
		end
		if do_find
		begin
			rtn_to_seq = true
			roll_input = D_AMD_MODE
			nstk_iad_opts = 'IADE'
		end
	end
	if reseq_req[D_VJ_NSTK+1]
	begin
		xcall lbc_restart(a_wndid)
		reseq_req[D_VJ_NSTK+1] = false
		xcall l_queue( a_wndid, D_LBOTTOM, D_LTOP )
	end

	if do_find then
		req = D_LFIND
	else
		req = D_LNOP
	; AP120106 - BUG - IF AUTO STOCK NOS NOT IN USE, THE ROUTINE WAS CRASHING
	; BECAUSE THE nstk_inpset1 DID NOT CONTAIN FIELD VJ_GRP AND POSSIBLY OTHERS.
	; TO OVERCOME THIS PROBLEM, SIMPLY AVOIDED USE  OF OFFENDING INPUT SET.
	input_set = 'nstk_inpset3'

	xcall whgine_display_nstk_screen(gold_com, gold_ax, whgine_nstk, whgine_passed, invoice_totals)

	xcall l_process(nstk_lst_id, req, whgine_nstk,, gold_com, gold_ax,
	&               fkeys[NSTK_FKEYS], whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
	&       whgine_hdr, add_part_passed, invoice_totals)

	if(pass_gen_data.plan_maint) then
	begin
		if(vi_i_plant_wgd)
			list_title='Plant Equipment PM Contract Line'
		else
			list_title='{WHOLEGD} Equipment PM Contract Line'
	end
	else
		list_title='Non Stocked {WHOLEGD}'
	req = D_LNOP
	repeat
	begin
		err = %listiad_proc(nstk_lst_id, nstk_linp_id, whgine_nstk,
		&       inp_nstk_id, input_set,,,'whgine_nstk_ini', 'whgine_nstk_upd',
		&       'whgine_nstk_mnu',, roll_input, list_title,
		&       nstk_iad_opts, fkeys[NSTK_FKEYS], fkeys[NSTK_INP_FKEYS],
		&       gold_com, gold_ax,
		&       whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
		&                 whgine_hdr, add_part_passed, invoice_totals)

		if err .eq. D_LIST_TERMINATED
			exitloop
		if g_select
		begin
			case g_entnam of
			begincase
				'J_QUIT':           exitloop
			endcase
			else
				exitloop
		end
	end
	xcall ibctab_highlight(tabset_id, false)
	if rtn_to_seq
		xcall m_signal('SEQ_TAB')
	clear do_find, seq_inserting, rtn_to_seq, roll_input

	; ap130207 - get rid of menu columns loaded buy above
	if(fkeys[NSTK_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[NSTK_FKEYS].fkmnu_id)

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.end
.subroutine whgine_display_nstk_screen
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'whgine_vj' repository, group= 'whgine_nstk'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	endparams

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:PMHREC.REC'
	.include 'SRC:PMLREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		err,            i4

.proc
	xcall i_snapshot(D_LOAD, inp_nstk_id, nstk_snap)
	if pass_gen_data.vi_currency .eq. cms_base_cur
	begin
		if(.not. pass_gen_data.plan_maint)
			xcall i_setdel(inp_nstk_id, 'nstk_fullset',
			&            'vj_d_bc_mrrp,vj_bc_vi_rrp,vj_bc_vi_disc',,,)
		xcall i_setdel(inp_nstk_id, 'nstk_fullset',
		&              'vj_bc_rrp,vj_bc_disc,vj_bc_sett')
		if wg_security .ne. ACC_NO_COST_DISP .and..not.pass_gen_data.plan_maint
			xcall i_setdel(inp_nstk_id, 'nstk_fullset',
			&              'vj_bc_ecos,vj_bc_cost')
	end

	xcall i_display(inp_nstk_id, 'nstk_fullset', whgine_nstk,,,,,,,,,,
	&               gold_com )

	if(wg_security .ne. ACC_NO_COST_DISP.and..not. pass_gen_data.plan_maint)
	begin
		xcall i_dspfld(inp_nstk_id,'vj_fc_ecos', whgine_nstk.vj_fc_ecos,
		&              gold_com)
		xcall i_dspfld(inp_nstk_id,'vj_fc_cost', whgine_nstk.vj_fc_cost,
		&              gold_com)
		if(pass_gen_data.vi_currency.ne.cms_base_cur)
		begin
			xcall i_dspfld(inp_nstk_id,'vj_bc_ecos', whgine_nstk.vj_bc_ecos,
			&              gold_com)
			xcall i_dspfld(inp_nstk_id,'vj_bc_cost',
			&              whgine_nstk.vj_bc_cost, gold_com)
		end
	end
	if(pass_gen_data.plan_maint)
	begin
		if(.not.wg_pm_site_add_no.or..not.wg_pm_contract) then
			clear pmhrec
		else
		begin
			pmh_contract=wg_pm_contract
			pmh_site_add_no=wg_pm_site_add_no
			xcall file(pass_chn_data.chn(PMH_FILE), pmhrec, pmh_key0, 'RD', err,,,,,D_NO_LOCK)
			if(err)
				clear pmhrec
			if(.not.(pmh_site_address[].and.
			&  pmh_site_address[1].ne.T$MAIN_LOC))
				clear pmh_site_address
		end

		xcall i_dspfld(inp_nstk_id,'dsp_pm_site_add',pmh_site_add_1)
		if(wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
		begin
			xcall whgine_read_pmh_pml(wg_pm_contract, whgine_nstk, pass_chn_data.chn(PMH_FILE), pass_chn_data.chn(PML_FILE), pmhrec, pmlrec)
			xcall ibc_window( D_PLACE, inp_nstk_clk_id, 6, 1)
			xcall i_display(inp_nstk_clk_id,, whgine_nstk,,,,,,,,,,gold_com ,gold_ax, pmhrec,pmlrec)
		end
		else
			xcall ibc_window( D_REMOVE, inp_nstk_clk_id)

	end
	xcall whgine_vj_curr_vals(gold_com, whgine_nstk, inp_nstk_id, whgine_passed, invoice_totals)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_seq_lst_load ;       Load list of items this advice
	a_listid,       n
	a_request,      n
	.include 'whgine_lst' repository, group='whgine_lst'
	a_inpid,        n
	a_disabled,     n
	a_itemindex,    n

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	external function
		f_format_money, a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:VMREC.REC'
	.include 'SRC:VQREC.REC'
	.include 'SRC:VICOM.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record
		err,            i4

.proc

	case a_request of
	begincase
		;D_LLOADBOT:
		call load_list_item

		;D_LLOADTOP:
		a_request = D_LEOF
	endcase

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       load list items
	load_list_item,
	if a_itemindex .eq. 1
	begin
		clear vq_key, pass_chn_data.f_some_recs, pass_chn_data.f_vj_eof
		vq_job = vijob
		xcall file(pass_chn_data.chn(VQ_FILE), vqrec, vq_key, 'FI', err,,,,, D_NO_LOCK)
	end

	xcall file(pass_chn_data.chn(VQ_FILE), vqrec, vq_key, 'RS', err,,,,, D_NO_LOCK)
	if err .or. vq_job .ne. vijob
		a_request = D_LEOF
	else
	begin
		clear whgine_lst
		using vq_type select
			(0 thru 3),
			begin
				vjjob = vq_job
				vjtstk = vq_stok
				xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok,'RD',err, 1,,,,D_NO_LOCK)
				pass_chn_data.current_item_type = 'VJ'
				xcall whgine_fill_list(gold_com, whgine_lst, vjrec, whgine_passed, invoice_totals)
			end
			(4),          begin
				pass_chn_data.f_vj_eof = true
				trd_cmnt_flg = true
				vbjob = vq_job
				vbtstk = vq_stok
				xcall file(pass_chn_data.chn(VB_FILE), vbrec, vbstok,'RD',err, 1,,,,D_NO_LOCK)
				pass_chn_data.current_item_type = 'VB'
				xcall whgine_fill_list(gold_com, whgine_lst, vbrec, whgine_passed, invoice_totals)
			end
		endusing
		xcall set_qty_dp(a_inpid, lst_qty_dp)
		xcall i_display( a_inpid,'full_set',whgine_lst)
	end

	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       fills the list record depending on data passed but does not
        ;       display the item
.subroutine whgine_fill_list

	.include 'gold_com' repository, group='gold_com'
	.include 'whgine_lst' repository, group='whgine_lst'
	pass_data,      a
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	external function
		f_format_money, a
		f_curr_fc,      d
		f_curr_bc,      d
		f_calc_val,     d

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:HWREC.REC'
	.include 'SRC:HIDREC.REC'

	.include 'SRC:HORT.CMN'
	.include 'SRC:POS_PARTS.CMN'


	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4

		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal


	record gen
		err,            d3
		c_journal,      d10
		c_bonus,        d10
		loop,           d4
		no_cost_dsp,    d1

.proc
	case pass_chn_data.current_item_type of
	begincase
		'VJ':       vjrec=pass_data
		'VB':       vbrec=pass_data
		'VD':       vdrec=pass_data
	endcase

	case pass_chn_data.current_item_type of
	begincase

		'VJ':       begin
			case vjnstk of
			begincase
				D_VJ_WGD:         begin
					list_type=T$MAIN_WG
					lst_ntype = D_VJ_WGD
					; when a main wholegood is applicable, we may be storing
					; plan main for eventual contract line creation
					; this is not a plan maintenance invoice
					whgine_lst.lst_wg_pm_group=vjrec.vj_wg_pm_group
				end
				D_VJ_NSTK:        begin
					list_type=T$NON_STK
					lst_ntype = D_VJ_NSTK
					if(pass_gen_data.plan_maint)
					begin
						whgine_lst.lst_wg_pm_group=vjrec.vj_wg_pm_group
						whgine_lst.list_desc=whgine_lst.lst_wg_pm_group.wg_pm_desc
					end
				end
				D_VJ_PART:        begin
					list_type=T$PART
					lst_ntype = D_VJ_PART
					lst_part_seq = %max(lst_part_seq, ^d(vjtstk(5:4)))
					lst_part_type = vj_part_type
					lst_kit_part = vj_kit_status
				end
				D_VJ_COMMENT:     begin
					lst_cmnt_seq = %max(lst_cmnt_seq, ^d(vjtstk(5:4)))
					list_type=T$COMMENT
					lst_ntype = D_VJ_COMMENT
					lst_cmnt_line=vj_comment
				end
			endcase
			lst_hide = vj_hide
			lst_tstk=vjtstk
			if(vjnstk.ne.D_VJ_COMMENT)
				lst_disp_stkno=vjtstk
			if(pass_gen_data.plan_maint.and.vjnstk.eq.D_VJ_NSTK)
				lst_disp_stkno=whgine_lst.lst_wg_pm_group.wg_pm_equip_no
			lst_sb_type = false
			lst_trd_cmnt = trd_cmnt_flg
			xcall time(lst_tim_id)
			lst_prev_batch = true
			; dont want any further details from the record for comment type so might
			; aswell exit
			if(vjnstk.eq.D_VJ_COMMENT) exit

			lst_retail = vj_f_rrp

			; do not show cost if this is restricted group
			no_cost_dsp=false
			; do not show cost if this is restricted group
			if(wg_security .ne. ACC_NO_COST_DISP.and..not.pass_gen_data.plan_maint
			&     .and.vjnstk.le.D_VJ_NSTK.and.whgine_passed.f_acc_wg_exclude.eq.1)
			begin
				if(%f_chk_vgf_restricted(,vjngrp, dt))
					whgine_passed.f_acc_wg_exclude=2
			end

			if(whgine_passed.f_acc_wg_exclude.eq.2)
				no_cost_dsp=true

			if(no_cost_dsp)
				clear vjcost

			lst_dsp_cost = %f_curr_bc(vjcost,pass_gen_data.vi_exch_rate)
			lst_cost=vjcost
			lst_pur_cost=lst_dsp_cost

			lst_tot_retail = vj_f_rrp * vjsold
			if vj_part_type .gt. D_PMF_TYP_MEMO then
				lst_tot_cost = vjcost
			else
				lst_tot_cost = vjcost * vjsold

			if(vjnstk.eq.D_VJ_PART) then
			begin
				part_code = vjnspc(1)
				list_desc = vjnspc(2)
				lst_disc = %f_calc_val(lst_retail, vjsold) -
				&     %f_calc_val(lst_retail, vjsold, vj_disc_pcnt)
				lst_vi_disc=
				if(vj_part_type .gt. D_PMF_TYP_MEMO) ; add hidrec's to link-list file
				begin
					hid_link = D_HID_LINK_WGDS

					if(vistat.ge.D_ADV_INVOICED) then
					begin
						hid_invoice_no = viinvo
						hid_invoice_date = viidat
					end
					else
					begin
						hid_invoice_no = vijob
						hid_invoice_date = 0
					end

					hid_line_no = ^d(whgine_lst.lst_tstk(5:4))
					xcall file( g_hid_chn, hidrec, hid_key, 'FI', err)
					repeat
					begin
						xcall file( g_hid_chn, hidrec, hid_key, 'RS', err
						&         ,,,,,D_NO_LOCK)
						if (err .or. (vistat.ge.D_ADV_INVOICED .and.
						&   (hid_invoice_no .ne. viinvo .or.
						&   hid_invoice_date .ne. viidat)) .or.
						&   (vistat.lt.D_ADV_INVOICED .and.
						&   (hid_invoice_no .ne. vijob .or.
						&   hid_invoice_date .ne. 0)) .or.
						&   hid_line_no .ne. ^d(whgine_lst.lst_tstk(5:4)))
							exitloop

						incr hid_lat
						if (hid_lat.gt.hid_max)
						begin
							hid_max = hid_max + 5
							hid_mhndl = %mem_proc( DM_RESIZ,
							&     hid_max*^size(ll_hidrec), hid_mhndl)
							for loop from hid_lat thru hid_max
								clear ^m(ll_hidrec[hid_lat], hid_mhndl),
								&                               ^m(ll_hidrec[hid_lat].ll_loop, hid_mhndl)
						end
						^m(ll_hidrec[hid_lat].ll_hid, hid_mhndl) = hidrec
						^m(ll_hidrec[hid_lat].ll_hid_st, hid_mhndl) = TRUE
						^m(ll_hidrec[hid_lat].ll_loop, hid_mhndl) = hid_lat
						if( viivcr.eq.D_VIIVCR_CREDIT)
						begin
							hrt_batch = hid_batch
							hrt_line = hid_bat_line
						end

					end
				end
			end
			else
			begin
				lst_stkno=vjtstk
				lst_code=vjcode
				lst_disc=vj_f_disc
				lst_vi_disc=vj_f_vi_disc
			end

			lst_qty=vjsold
			lst_qty_dp = vj_qty_dp
			lst_sett=vj_f_sett
			; if qty less than 0 (negative) then treat settlement as negative
			if(vjsold.lt.0)  lst_sett=lst_sett*-1
			lst_vat=vjnvat
			lst_used = vjused .eq. 'U'
			lst_type = vjtype
			lst_model = vjnmod
			lst_grp = vjngrp
			lst_mak = vjnmak
			for loop from 1 thru 10
				lst_spec(loop) = vjnspc(loop)
			lst_ser = vjnser
			lst_reg = vjnreg
			lst_reg_dat = vj_dreg
			lst_clok = vjnclk
			lst_hide_att = vj_hide_attach
			lst_cost=vjcost
			lst_disc_pcnt = vj_disc_pcnt
			lst_orig_price = vj_orig_price
			if(.not.pass_gen_data.plan_maint.and.f_wg_md_disc.ne.D_CM5_WG_MD_NO.and.
			&  (vjnstk .eq. D_VJ_NSTK  .or. vjnstk.eq.D_VJ_WGD))
				lst_wg_md_group=vj_md_group

			if vjnstk .eq. D_VJ_NSTK
			begin
				if(no_cost_dsp.eq.false)
					xcall calc_wg_pric(lst_pur_cost, lst_code,,,,lst_pur_cost)

				xcall calc_wg_pric(lst_rrp, lst_code,, pass_gen_data.vi_currency,,, 1)
				xcall calc_wg_pric(lst_trd_price, lst_code,, pass_gen_data.vi_currency,,, 2)
			end

			if (vjnstk == D_VJ_WGD)
			begin
				pass_chn_data.h_stok = vjtstk
				xcall check_vm_exists(whgine_passed, lst_vm_exists, lst_vm_rfa)
				if(! no_cost_dsp)
				begin
					if (vistat < D_ADV_INVOICED)
					begin
						xcall WHGINE_Set_VM_Costs(whgine_lst, vmrec)
					end
				end
				; MOVED NEXT TWO LINES TO HERE FROM BELOW AS WHEN
				; LOOKING AT AN INVOICED ADVICE,, THE ROUTINE WAS NOT SETTING
				; LST_RRP BUT LST_RRP WAS LATER USED TO UPDATE VMMRRP
				lst_rrp = %f_curr_fc(%f_curr_bc(vmmrrp,vm_sell_cnv), pass_gen_data.vi_exch_rate)
				lst_trd_price = %f_curr_fc(%f_curr_bc(vm_trd_price,vm_sell_cnv), pass_gen_data.vi_exch_rate)

				; ap100501 there was a problem that a user ended up with
				; a negative invoice cos he amended values in amend wg
				; option and then went into this routine and pressed the
				; invoice buttom.  While there is some validation to stop
				; this occurring it was not man enough for the job because
				; this routine uses the vj_f_rrp value to do the checking
				; which was not changed by amend wg

				if(vistat.lt.D_ADV_INVOICED.and.lst_vm_exists.and.
				&                       viivcr.ne.D_VIIVCR_PART_CRED.and.viivcr.ne.D_VIIVCR_PART_INV)
				begin
					if(vm_rrp(D_FC).ne.vj_f_rrp.or.
					&                       vm_f_disc.ne.vj_f_disc.or.
					&                       vm_sett(D_FC).ne.vj_f_sett)
					begin
						xcall ibc_message('Warning - advice line and {WHOLEGD} '
						&                          +'values differ for {WHOLEGD} no '+vmstok
						&                          +'. The advice lines will be updated to reflect the'
						&                          +' current values from the {WHOLEGD} record.')
					end
					lst_retail=vm_rrp(D_FC)
					if(no_cost_dsp.eq.false)
						lst_pur_cost = vm_est_cos(D_BC)
					lst_disc=vm_f_disc

					lst_used = vmnu .eq. 'U'
					lst_type = vmtype

					lst_code=vmcode
					lst_model = vmmodl
					lst_grp = vmgrp
					lst_mak = vmmak
					lst_ser = vmser
					lst_reg = vmreg
					lst_reg_dat = vmdreg
					lst_clok = vmclok
					for loop=1 until 10 do lst_spec(loop) = vmspec(loop)
					xcall WHGINE_WarnFinanceScheme(vmrec)
				end
				lst_vmmotd=vmmotd
				if(lst_vm_exists.and.
				&     viivcr.ne.D_VIIVCR_PART_CRED.and.viivcr.ne.D_VIIVCR_PART_INV)
				begin
					lst_warr_sdat = vmwdat
					lst_warr_edat = vm_warr_edat
					lst_warr_end_clock = vm_warr_end_clock
					lst_ex_warr_edat = vm_ex_warr_edat
					lst_ex_warr_end_clock = vm_ex_warr_end_clock
					lst_vj_vmdeld = vmdeld
					lst_vj_vm_extra_comm = vm_extra_comm

					lst_fin_inv = vm_fin_inv
					lst_recv_dat = vmrdat

					if (!lst_bonus)
					begin
						; WHGINE_Set_VM_Costs has already calculating bonuses, so whgine_fill_list won't recalculate them
						data lBonusVal,		d10,	0
						lst_bonus = true
						xcall wg_bonus_calc(VMRec, lBonusVal)
						lst_dsp_cost -= lBonusVal
						lst_cost -= lBonusVal
					end
				end
				if(viivcr.ne.D_VIIVCR_PART_CRED.and..not.
				&     (viivcr.eq.D_VIIVCR_PART_INV.and.
				&     lst_vm_exists.eq.'H'
				&     .and.vistat .lt. D_ADV_INVOICED))
					lst_attach_num = %bld_attach_list(vjtstk, attach_ll,,invoice_totals)

				if(viivcr.eq.D_VIIVCR_PART_INV.and.lst_vm_exists.eq.'H'.and.
				&       (vistat.lt.D_ADV_INVOICED.or.
				&       (vistat.ge.D_ADV_INVOICED.and.vmivno.ne.viinvo))) then
					lst_extra_text='{W} MAIN INV '+vmivno
				else
					xcall whgine_set_pm_extra_text(lst_wg_pm_group, lst_extra_text)

				xcall reset_attch_vals(whgine_lst)
				clear pass_chn_data.f_some_recs

			end

			if(.not.vj_f_vi_rrp.and.lst_vat)
			begin
				if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjnstk.ne.D_VJ_PART) then
					vj_f_vi_rrp=vj_f_rrp
				else
					xcall whgine_vat_calc(vj_f_vi_rrp, lst_vat,
					&        vt_vat_code, vt_vrat, lst_retail,
					&        D_RET_VAT_EXC, D_RET_VAT_INC)
			end
			lst_vi_retail = vj_f_vi_rrp

			if(.not.vj_f_vi_disc.and.lst_vat)
			begin
				if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjnstk.ne.D_VJ_PART) then
					vj_f_vi_disc=vj_f_disc
				else
					xcall whgine_vat_calc(vj_f_vi_disc, lst_vat,
					&        vt_vat_code, vt_vrat, lst_disc,
					&        D_RET_VAT_EXC, D_RET_VAT_INC)
			end
			lst_vi_disc=vj_f_vi_disc

			lst_dsp_disc=lst_disc

			set lst_qual, lst_ucar = false
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjused.eq.'U'
			&               .and.lst_ntype .ne. D_VJ_PART.and.vj_qual.eq.false)
			begin
				lst_ucar=TRUE
			end
			lst_qual=vj_qual
		end
		'VB':       begin
			list_type=T$TRADE_IN
			lst_ntype = D_VJ_TRADE
			lst_stkno=vbtstk
			lst_disp_stkno=vbtstk
			lst_sbin = vbsbin
			lst_tstk=vbtstk
			lst_qty=1
			lst_prev_batch = true
			pass_chn_data.h_stok=vbtstk
			lst_sbin =vbsbin
			lst_sb_type = true
			lst_wash_comp = vb_wash
			lst_trd_cmnt = true
			xcall check_vm_exists(whgine_passed, lst_vm_exists, lst_vm_rfa)

			if(lst_vm_exists.and.vistat .lt. D_ADV_INVOICED) then
			begin
				set lst_dsp_cost, vb_trade_prc(D_BC)=vm_tip(D_BC)
				set lst_tot_cost, vb_trade_prc(D_FC)=vm_tip(D_FC)
				lst_disc=vmoa
				lst_pur_cost = vm_tip(D_BC)
				if (vmnu.eq.'N') then
				begin
					if (vm_rrp(D_BC)) then
						lst_retail = vm_rrp(D_BC)
					else
						lst_retail = %f_curr_bc(vmmrrp, vm_sell_cnv)
				end
				else
					lst_retail = vm_rrp(D_BC)
				; regarding market value rrp display, used to
				; calculate other fields and was displaying as zero when the
				; item had been credited
				vb_qual=vm_qualifying

				if(.not.lst_retail) lst_retail=%f_curr_bc(vmmrrp, vm_sell_cnv)
				if(.not.lst_retail) lst_retail=%f_curr_bc(vbtrrp, vm_sell_cnv)
				vb_est_repairs=vm_est_repairs
				vb_est_warr=vm_est_warr
			end
			else
			begin
				lst_dsp_cost=vb_trade_prc(D_BC)
				lst_tot_cost=vb_trade_prc(D_FC)
				lst_disc=vb_trade_prc(D_BC)-vbtnsp
				lst_retail=vbtrrp
				lst_pur_cost=vb_trade_prc(D_BC)
				lst_used = TRUE       ; ASSUME USED
				lst_type = 0
			end

			if(lst_vm_exists) then
			begin
				lst_used = vmnu .eq. 'U'
				lst_type = vmtype
				lst_warr_sdat = vmwdat
				lst_warr_edat = vm_warr_edat
				lst_warr_end_clock = vm_warr_end_clock
				lst_ex_warr_edat = vm_ex_warr_edat
				lst_ex_warr_end_clock = vm_ex_warr_end_clock
				lst_vj_vmdeld = vmdeld
				lst_vj_vm_extra_comm = vm_extra_comm

				lst_fin_inv = vm_fin_inv
				lst_recv_dat = vmrdat

				vbcode=vmcode
				vbtmod=vmmodl

				vbtmak=vmmak
				vbtgrp=vmgrp
				for loop from 1 thru 10
					vbtspc(loop) = vmspec(loop)

				vbtser = vmser
				vbtreg = vmreg
				vbtdat = vmdreg
				vb_year = vm_year

				if(vistat < D_ADV_INVOICED)
					vbtclk = vmclok

				lst_est_pdi_cost = vm_est_pdi_cost
				lst_est_prt_pdi_cost = vm_est_prt_pdi_cost
				lst_est_pdi_hours = vm_est_pdi_hours
			end
			else
			begin
				lst_used = TRUE       ; ASSUME USED
				lst_type = 0
			end

			; if the following is true, then want the trade in price to be
			; vat inclusive
			lst_code = vbcode
			lst_model= vbtmod

			lst_disc = %f_curr_fc(lst_disc, pass_gen_data.vi_exch_rate)
			lst_dsp_disc=lst_disc
			lst_retail = %f_curr_fc(lst_retail, pass_gen_data.vi_exch_rate)
			lst_cost = lst_tot_cost
			lst_est_repairs=vb_est_repairs
			lst_est_warr=vb_est_warr
			lst_vat=vbtvat
			lst_ucar = false
			lst_hide = vb_hide
			lst_grp = vbtgrp
			lst_mak = vbtmak
			for loop from 1 thru 10
				lst_spec(loop) = vbtspc(loop)
			lst_ser = vbtser
			lst_reg = vbtreg
			lst_reg_dat = vbtdat
			lst_clok = vbtclk
			lst_hide_att = vb_hide_attach
			lst_year = vb_year
			lst_qual=vb_qual

			vkkey = vijob + vbtstk
			lst_attach_num = %bld_attach_list(vbtstk, attach_ll,,invoice_totals)
			xcall reset_attch_vals(whgine_lst)
			clear pass_chn_data.f_some_recs
		end
		'VD':       begin
			list_type=T$ATTACH
			lst_stkno=vdastk
			lst_tstk=vdstok
			lst_code=vdcode
			lst_qty=vdqty

			lst_pur_cost=vd_cost(D_BC)
			lst_cost=vd_cost(D_FC)
			lst_dsp_cost = vd_cost(D_BC)
			if(cms_gnvcos.eq.D_WG_AUTO_COST_ADJ
			&                .and..not.vd_fin_inv.and.vd_est_cos(D_BC).gt.vd_cost(D_BC))
			begin
				lst_pur_cost = vd_est_cos(D_BC)
				lst_dsp_cost = vd_est_cos(D_BC)
			end
			lst_pur_cost=lst_pur_cost*vdqty
			lst_cost=lst_cost*vdqty
			lst_dsp_cost = lst_dsp_cost * vdqty
			; if this is not a trade in then want purchase costs in base currency
			; other part of self bill total so still want as fc
			if(.not.lst_sb_type) lst_pur_cost=lst_dsp_cost

			lst_retail=vd_rrp(D_FC)*vdqty
			lst_vat=vdvat
			lst_ucar = false
			; WG7433               if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjused.eq.'U'.and.vjtype
			; WG7433&               .and..not.lst_sb_type.and..not.vj_qual)
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjused.eq.'U'
			&               .and..not.lst_sb_type.and..not.vj_qual)
			begin
				lst_ucar=TRUE
			end
			lst_qual=vj_qual
		end
	endcase

	; WG6433        if(pass_gen_data.h_vatable.and..not.
	; WG6433&               (lst_sb_type.and.cms_country.ne.EIRE_VAT.and..not.pass_gen_data.h_vatreg))
	if(pass_gen_data.h_vatable.and..not.
	&               (lst_sb_type.and..not.pass_gen_data.h_vatreg))
	begin
		if(lst_vat.eq.0)
		begin
			if(cms_country.eq.EIRE_VAT) then
				lst_vat=pass_gen_data.h_vat_code
			else
			begin
				lst_vat = cms_uk_def_vat
				if(lst_ucar.and. lst_ntype .ne. D_VJ_PART)
					lst_vat = cms_used_car_vat
			end
		end

		if(lst_sb_type) then
			lst_vat_val=lst_dsp_cost
		else
		begin
			lst_vat_val=lst_retail
		end

		if(pass_chn_data.h_prog_code == P_COD_CAR_SAL && lst_ucar)
		begin
			data lMarginCost,	int
			lMarginCost = %whgprt_vat_margin_cost(gold_com, vmstok)
			if (vmpsys == 'S' && ! lst_qual && list_type != T$ATTACH && list_type != T$PART && lMarginCost > 0)
			begin
				lst_vat_val=lst_vat_val-%f_curr_fc(lMarginCost, pass_gen_data.vi_exch_rate)
			end
			else
			begin
				lst_vat_val=lst_vat_val-%f_curr_fc(lst_cost, pass_gen_data.vi_exch_rate)
			end
			xcall whgine_vat_calc(lst_vat_val, lst_vat, vt_vat_code, vt_vrat, lst_vat_val, D_RET_VAT_INC, D_RET_VAT_VAL)
		end
		else
		begin
			xcall whgine_vat_calc(lst_vat_val, lst_vat,
			&        vt_vat_code, vt_vrat, lst_vat_val,
			&        D_RET_VAT_EXC, D_RET_VAT_VAL)
		end
		if(.not.lst_sb_type.and.lst_disc)
		begin
			lst_vat_val=lst_vat_val-(lst_vi_disc-lst_disc)
		end
		; if this is the uk and used car type and vat calculated as less than zero
		; ie. when retail - discount - cost < 0 then clear vat
		if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL
		&               .and.lst_ucar.and.lst_vat_val.lt.0)
			clear lst_vat_val
	end
	return
.end
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;       establish total and purchase cost of wholegood
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
subroutine WHGINE_Set_VM_Costs
	.include 'whgine_lst' repository, req inout group='aWhgine_Lst'
	.include 'vmrec' repository, req inout group='aVMRec'
	endparams

	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	external function
		f_curr_fc, 	d
	endexternal

	record lGeneral
		lJournalVal,		d12
		lBonusVal,			d12
	endrecord
proc
	init lGeneral

	if(pass_gen_data.h_ivcr != D_VIIVCR_PART_CRED && pass_gen_data.h_ivcr != D_VIIVCR_PART_INV)
	begin
		xcall WHGINE_Calc_Journal(lJournalVal, aVMRec.vmstok)

		aWhgine_Lst.lst_cost = aVMRec.vmcost
		aWhgine_Lst.lst_dsp_cost = aVMRec.vmcost
		aWhgine_Lst.lst_pur_cost = aVMRec.vm_auto_cos(D_BC)
		if (cmsrec.cms_gnvcos == D_WG_AUTO_COST_ADJ && ! aVMRec.vm_fin_inv)
		begin
			if(aVMRec.vm_est_cos(D_BC) > aVMRec.vm_auto_cos(D_BC))
				aWhgine_Lst.lst_pur_cost = aVMRec.vm_est_cos(D_BC)
			if(aVMRec.vm_est_cos(D_BC) + lJournalVal > aVMRec.vmcost)
				aWhgine_Lst.lst_dsp_cost = aVMRec.vm_est_cos(D_BC) + lJournalVal
			if(aVMRec.vm_est_cos(D_BC) + lJournalVal > aVMRec.vmcost)
				aWhgine_Lst.lst_cost = aVMRec.vm_est_cos(D_BC) + lJournalVal
		end
		if (pass_gen_data.vi_currency != cmsrec.cms_base_cur)
			aWhgine_Lst.lst_cost = %f_curr_fc(aWhgine_Lst.lst_cost, pass_gen_data.vi_exch_rate)
		aWhgine_Lst.lst_est_cost = aVMRec.vm_est_cos(D_BC) + lJournalVal
		aWhgine_Lst.lst_est_cost = %f_curr_fc(aWhgine_Lst.lst_est_cost, pass_gen_data.vi_exch_rate)
		; note - the use of c_journal simply as it is an available work variable
		; the call below will return estimated pdi unless actual is greater
		; or actual is complete
		xcall wgd_pdi_dets_dsp(aVMRec,,, true, lJournalVal,, true)

		if(!lst_bonus)
		begin
			; whgine_fill_list has already calculating bonuses, so WHGINE_Set_VM_Costs won't recalculate them
			xcall wg_bonus_calc(aVMRec, lBonusVal)
			lst_bonus = true
		end
			lJournalVal -= lBonusVal

		; deliberate use of base value - reset_attach_vals make fc
		aWhgine_Lst.lst_dsp_cost += lJournalVal

		lJournalVal = %f_curr_fc(lJournalVal, pass_gen_data.vi_exch_rate)

		aWhgine_Lst.lst_cost += lJournalVal
		aWhgine_Lst.lst_est_cost += lJournalVal
		xcall reset_attch_vals(aWhgine_Lst)
	end
	xreturn
endsubroutine
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;       Reads through the hw file for the current stocked item
	;       accumulating the values for commission, depreciation and journals
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
subroutine WHGINE_Calc_Journal
	req out aJournalVal,	n
	req in aVMStok,			a
	endparams

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record
		.include 'hwrec' repository, group='lHWRec'
		lError,	int
	endrecord
proc
	clear aJournalVal
	xcall file(pass_chn_data.chn(HW_FILE), lHWRec,	aVMStok, 'FI', lError)
	repeat
	begin
		xcall file(pass_chn_data.chn(HW_FILE), lHWRec,, 'RS', lError,,,,, D_NO_LOCK)
		if (lError || lHWRec.hwstk1 != aVMStok)
			exitloop
		if (lHWRec.hwttyp != HW_JOURNAL && lHWRec.hwttyp != HW_COMMISSION && lHWRec.hwttyp != HW_DEPRECIATION)
		 	nextloop
		if (lHWRec.hwmodl == T$VAT_USED_CARSALE)
			nextloop
		if (lHWRec.hwmodl == T$VAT_INC_SALE)
			nextloop
		if(lHWRec.hw_att_stk)
			nextloop
		aJournalVal = aJournalVal + lHWRec.hw_cost(D_BC)
	end
	xreturn
endsubroutine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.subroutine whgine_proc_prt

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:HIDREC.REC'
	.include 'SRC:IVTCOM.REC'               ; !!!

	external function
		f_curr_fc,              d
		f_curr_bc,              d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		rtn_to_seq,     d1
		h_ivt_prog_code,d2
.proc

	clear gen
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	add_part_passed.terminate_list = false
	if do_find
	begin
		set add_part_passed.terminate_list, rtn_to_seq = true
		roll_input = D_AMD_MODE
	end
	if seq_inserting
	begin
		set add_part_passed.terminate_list, rtn_to_seq = true
		roll_input = D_INS_MODE
	end
	if wg_security .eq. ACC_NO_COST_DISP .or.
	&   whgine_passed.f_acc_wg_exclude.gt.1
		add_part_passed.disp_costs = 0        ; hide costs
	else
		add_part_passed.disp_costs = 2        ; display costs
	tot_inv[D_FC] = inv_total
	tot_inv[D_BC]=%f_curr_bc(inv_total, pass_gen_data.vi_exch_rate)
	tot_nett[D_FC] = adv_tot_retail
	tot_nett[D_BC]=%f_curr_bc(adv_tot_retail, pass_gen_data.vi_exch_rate)
	tot_prtlab[D_FC]=tot_nett[D_FC]
	tot_prtlab[D_BC]=tot_nett[D_BC]
	if(viivcr.eq.D_VIIVCR_CREDIT.or.viivcr.eq.D_VIIVCR_PART_CRED)
		adv_type = POS_CRN_TYPE
	else
		adv_type = POS_INV_TYPE
	hdr_advice_no = vi_job
	cust_acc = vi_cust
	store_opp_lev = 63
	crst = vi_crst_inp
	s_c_perc = vi_cr_chrg_inp

	clear add_part_passed.xml_doc
	clear add_part_passed.xml_doc_passed
	clear add_part_passed.xml_doc_is_passed

	add_part_passed.curr_grp.cur_cod[D_FC]=vi_sell_cur
	add_part_passed.curr_grp.cur_cod[D_BC]=cms_base_cur
	add_part_passed.curr_grp.curr=D_FC

	add_part_passed.nxt_line = lst_part_seq
	add_part_passed.no_orders = true
	add_part_passed.add_part_link = D_HID_LINK_WGDS
	add_part_passed.drf_prn = false
	add_part_passed.zero_vat_rate = .not. pass_gen_data.h_vatable
	add_part_passed.kit_part_upd = true
	add_part_passed.vat_allowed = pass_gen_data.h_vatable
	if(pass_gen_data.adv_mode .eq. D_VEW_MODE .or.pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL) then
	begin
		add_part_passed.deletion_allowed=false
		add_part_passed.iad_opts='V'
		fkeys[PRTLST_FKEYS].fkey[D_FK_NO2].disabled_flg=true
		fkeys[PRTLST_FKEYS].fkey[D_FK_NO3].disabled_flg=true
		fkeys[PRTLST_FKEYS].fkey[D_FK_NO4].disabled_flg=true
	end
	else
	begin
		add_part_passed.deletion_allowed=true
		add_part_passed.iad_opts=
		fkeys[PRTLST_FKEYS].fkey[D_FK_NO2].disabled_flg=false
	end
	pre_proc_rtn = 'whgine_prt_preprc'
	; if this is a vat inclusive program type then want the parts to
	; reflect this.
	if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC)
	begin
		h_ivt_prog_code=ivt_prog_code
		ivt_prog_code=P_COD_VAT_INC
	end
	if reseq_req[D_VJ_PART+1]
	begin
		xcall lbc_restart(a_wndid)
		reseq_req[D_VJ_PART+1] = false
		xcall l_queue( a_wndid, D_LBOTTOM, D_LTOP )
	end

	; reason for deleting col is that add_part clears the fk id but
	; does not delete it.  This can cause the routine to crash with too
	; many cols type error.

	xcall e_enter
	clear fkeys[PRTLST_FKEYS].fkmnu_id
	xcall add_part(gold_com, gold_ax, a_wndid, part_data, add_part_passed,
	&              invoice_totals, 'whgine_prt_mnu', 'whgine_prt_init',
	&              'whgine_prt_upd', fkeys[PRTLST_FKEYS], fkeys[PRTINP_FKEYS],
	&              whgine_passed, fkeys, whgine_lst, whgine_inv_tab, whgine_hdr)
	xcall e_exit
	if rtn_to_seq
		xcall m_signal('SEQ_TAB')
	xcall ibctab_highlight(tabset_id, false)
	clear seq_inserting, do_find, rtn_to_seq, roll_input
	lst_part_seq = add_part_passed.nxt_line

	; if this is a vat inclusive program type then
	; restore the program code back to original - note that prior to
	; add_part, the program code was set to the nornmal vat inclusive
	; program code.
	if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC)
		ivt_prog_code=h_ivt_prog_code


	xreturn
.end

.subroutine whgine_part_load

	a_listid           ,n
	a_request          ,n
	.include 'add_part_str' repository, group='part_data'
	a_inpid            ,n
	a_disabled         ,n      ;optional
	a_itemindex        ,n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	a_chn,             n
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,     [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst_dummy'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	;end of argument list

	.include "WND:tools.def"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:PMFREC.REC'
	.include 'SRC:PDFREC.REC'
	.include 'SRC:FCFREC.REC'

	external function
		f_curr_prt,     d
		f_curr_std,     d
		f_curr_bc,      d
		f_curr_fc,      d


		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal


	.align
	record general
		.include 'whgine_lst' repository, group='whgine_lst'
		err,            d3
		first_time,     d1
		search,         d1

	record ids
		tmp_price,      i4
		tmp_disc,       i4
		tmp_cofs,       i4

.proc

	xcall i_ldinp(seq_linp_id, g_utlib, 'whgine_lstinp', D_NOPLC, search,,
	&             h_seq_linp_name)
	case a_request of
	begincase
		;D_LLOADBOT:
		begin
			first_time = a_itemindex .eq. 1
			call load_part
		end

		;D_LLOADTOP:
		a_request = D_LEOF

	endcase

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_part,
	repeat
	begin
		if first_time
		begin
			xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err)
			clear first_time
			prt_t_cost=0
		end
		else
			xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err)

		; next line is workaround for synergex bug
		xcall lp_setup(a_listid)

		if err then
		begin
			a_request = D_LEOF
			exitloop
		end

		if whgine_lst.lst_ntype .ne. D_VJ_PART
			nextloop

		part_line = ^d(whgine_lst.lst_tstk(5:4))
		part_no = whgine_lst.part_code
		part_desc = whgine_lst.list_desc
		set part_sold_qty, part_orig_sold, part_orig_line_qty = whgine_lst.lst_qty
		if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC) then
			part_retail[D_FC] = whgine_lst.lst_vi_retail
		else
			part_retail[D_FC] = whgine_lst.lst_retail
		part_retail[D_BC] = %f_curr_bc(part_retail[D_FC], fcf_std_rate)

		part_cost[D_BC] = whgine_lst.lst_dsp_cost
		part_cost[D_FC] = %f_curr_fc(part_cost[D_BC], fcf_std_rate)
		part_orig_price[D_BC] = part_retail[D_BC]
		part_orig_price[D_FC] = part_retail[D_FC]
		part_disc = whgine_lst.lst_disc_pcnt

		part_sett_value_fc =  whgine_lst.lst_tot_retail -
		&       whgine_lst.lst_disc - whgine_lst.lst_sett
		part_vat = whgine_lst.lst_vat
		part_kit_status = whgine_lst.lst_kit_part
		part_dsp_status = part_kit_status
		part_type = whgine_lst.lst_part_type
		if part_type .gt. D_PMF_TYP_MEMO
			part_dsp_status = part_type
		prev_batch = whgine_lst.lst_prev_batch
		part_wgstk = whgine_lst.lst_tstk
		mod_flag = whgine_lst.lst_moded
		part_cust_demand = whgine_lst.lst_cust_demand
		part_exclude_fill_rep = whgine_lst.lst_exclude_fill_rep

		part_adv_seq=whgine_lst.lst_hide    ; USE SPARE FIELD FOR HIDE FLAG

		xcall file(pass_chn_data.chn(PMF_FILE), pmfrec, part_no, 'RD', err,,,,, D_NO_LOCK)
		if err
			clear pmfrec

		pdf_part_no = part_no
		pdf_depot = gold_com.cur_depot
		xcall file(pass_chn_data.chn(PDF_FILE), pdfrec, pdf_key, 'RD', err,,,,,
		&            D_NO_LOCK)
		if err
			clear pdfrec

		xcall sell_pri_prt( part_no, cusrec, pmfrec, pdfrec, ivtrec, tmp_price,
		&                 tmp_disc, force_disc, tmp_cofs,,,part_sold_qty)

		if part_type .gt. D_PMF_TYP_MEMO then
			prt_t_cost += part_cost[D_FC]
		else
			prt_t_cost += part_sold_qty * part_cost[D_FC]

		xcall add_part_calc_line(part_data, add_part_passed)
		xcall i_display(a_inpid,, part_data,,,,,,,,,, gold_com,
		&             gold_ax)
		exitloop
	end
	return
.end

.subroutine whgine_cmnt_load ;

	a_listid           ,n
	a_request          ,n
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	a_inpid            ,n
	a_disabled         ,n      ;optional
	a_itemindex        ,n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	;end of argument list

	.include "WND:tools.def"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:PMFREC.REC'
	.include 'SRC:PDFREC.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:HIDREC.REC'

	.include 'SRC:HORT.CMN'

	external function
		f_curr_prt,     d
		f_curr_std,     d

	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4


	.align
	record general
		.include 'whgine_lst' repository, group='whgine_lst'
		err,            d3
		first_time,     d1
		search,         d1

	record ids
		loop,           i4

.proc

	xcall i_ldinp(seq_linp_id, g_utlib, 'whgine_lstinp', D_NOPLC, search,,
	&             h_seq_linp_name)
	case a_request of
	begincase
		;D_LLOADBOT:
		begin
			first_time = a_itemindex .eq. 1
			call load_cmnt
		end

		;D_LLOADTOP:
		a_request = D_LEOF

	endcase

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_cmnt,
	repeat
	begin
		if first_time
		begin
			xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err)
			clear first_time
		end
		else
			xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err)

		; next line is workaround for synergex bug
		xcall lp_setup(a_listid)

		if err then
		begin
			a_request = D_LEOF
			exitloop
		end

		if lst_ntype .ne. D_VJ_COMMENT
			nextloop

		lst_comment = lst_cmnt_line
		cmnt_no = ^d(lst_tstk(5:4))
		cmnt_hide = lst_hide
		cmnt_prev_batch = lst_prev_batch
		cmnt_moded = lst_moded

		xcall i_display(a_inpid,, whgine_cmnt_lst,,,,,,,,,, gold_com,
		&             gold_ax)
		exitloop
	end
	return
.end

.subroutine whgine_wgd_load

	a_listid           ,n
	a_request          ,n
	.include 'whgine_vj' repository, group='whgine_vj'
	a_inpid            ,n
	a_disabled         ,n      ;optional
	a_itemindex        ,n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	;end of argument list

	.include "WND:tools.def"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:PMFREC.REC'
	.include 'SRC:PDFREC.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:HIDREC.REC'

	.include 'SRC:HORT.CMN'

	external function
		f_curr_prt,     d
		f_curr_std,     d
		f_curr_fc,      d
		f_curr_bc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4


	.align
	static record general
		;       .include 'whgine_lst' repository, group='whgine_lst'
		err,            d3
		first_time,     d1
		search,         d1
		tmp_rate,	d4

.proc

	xcall i_ldinp(seq_linp_id, g_utlib, 'whgine_lstinp', D_NOPLC, search,,
	&             h_seq_linp_name)
	case a_request of
	begincase
		;D_LLOADBOT:
		begin
			if a_itemindex .eq. 1
			begin
				clear f_attach
				first_time = true
			end
			call load_wgd
		end
		;D_LLOADTOP:
		a_request = D_LEOF

	endcase

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_wgd,
	repeat
	begin
		if .not. f_attach then
		begin
			if first_time
			begin
				xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err)
				clear first_time
			end
			else
				xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err)

			; next line is workaround for synergex bug
			xcall lp_setup(a_listid)

			if err then
			begin
				a_request = D_LEOF
				exitloop
			end

			if whgine_lst.lst_ntype .ne. D_VJ_WGD
				nextloop

			vj_used = lst_used
			vj_type = lst_type

			f_attach = attach_ll .nes. ''
			vj_wg_attach = false
			vj_has_attach = f_attach
			if f_attach
				first_time = true

			vj_tstk = lst_tstk
			vj_disp_tstk = lst_disp_stkno
			vj_code = lst_code
			vj_fc_cost = lst_cost
			if pass_gen_data.vi_currency .ne. cms_base_cur
				vj_bc_cost = %f_curr_bc(vj_fc_cost, pass_gen_data.vi_exch_rate)

			vj_fc_rrp = lst_retail
			vj_fc_vi_rrp = lst_vi_retail

			vj_fc_sett = lst_sett
			vj_fc_disc = lst_disc
			vj_fc_vi_disc = lst_vi_disc
			vj_dsp_disc = lst_dsp_disc

			vj_fc_ecos = lst_est_cost
			vj_bc_ecos = %f_curr_bc(vj_bc_ecos, pass_gen_data.vi_exch_rate)

			vj_fc_mrrp = lst_rrp
			vj_fc_trd_price = lst_trd_price
			if(pass_chn_data.h_prog_code.ne.P_COD_MACH_TRAD) then
				vj_d_fc_mrrp = vj_fc_mrrp
			else
				vj_d_fc_mrrp = vj_fc_trd_price
			if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC.and.lst_vat)
			begin
				xcall whgine_vat_calc(vj_d_fc_mrrp, lst_vat,
				&        vt_vat_code, vt_vrat, vj_d_fc_mrrp,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)
			end

			vj_atd_ord_qty = lst_qty
			vj_grp = lst_grp
			vj_dsp_cost = %f_curr_fc(lst_dsp_cost, pass_gen_data.vi_exch_rate)

			xcall whgine_get_group(vj_grp, vj_grpdes)
			vj_mak = lst_mak
			xcall whgine_get_make(vj_mak, vj_makdes)
			vj_code = lst_code
			vj_model = lst_model
			vj_ser = lst_ser
			vj_reg = lst_reg
			vj_reg_date = lst_reg_dat
			vj_vmmotd = lst_vmmotd
			vj_clok = lst_clok
			vj_vat = lst_vat
			vj_vm_exists = lst_vm_exists
			vj_vm_rfa = lst_vm_rfa
			vj_nom_bonus = lst_bonus
			vj_recv_date = lst_recv_dat
			vj_fin_inv = lst_fin_inv
			vj_vmdeld = lst_vj_vmdeld
			vj_vm_extra_comm = lst_vj_vm_extra_comm
			vj_warr_sdat = lst_warr_sdat
			vj_warr_edat = lst_warr_edat
			vj_warr_end_clock = lst_warr_end_clock
			vj_ex_warr_edat = lst_ex_warr_edat
			vj_ex_warr_end_clock = lst_ex_warr_end_clock
			vj_qualify = lst_qual
			vj_attach_num = lst_attach_num
			vj_prev_batch = lst_prev_batch
			vj_hide_att = lst_hide_att
			vj_hide_ln = lst_hide
			vj_moded = lst_moded
			vj_spec[] = lst_spec[]
			clear vj_att_rfa

			vj_extra_text=lst_extra_text
			vj_inp_md_group=lst_wg_md_group
			if(pass_gen_data.pm_create_cont_ivt)
				whgine_vj.vj_inp_pm_group=whgine_lst.lst_wg_pm_group
		end
		else
		begin
			if first_time then
			begin
				xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
				clear first_time
			end
			else
				xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
			if err
			begin
				clear f_attach, first_time
				nextloop
			end
			clear whgine_vj
			vj_wg_attach = true
			vj_has_attach = f_attach
			vjjob = vijob

			vj_tstk = vdastk
			vj_astk = vdstok
			vj_code = vdcode
			VJ_FC_COST = vd_cost(D_BC)
			vj_fc_ecos = vd_est_cos(D_BC)
			if pass_gen_data.vi_currency .ne. cms_base_cur
			begin
				vj_fc_cost = %f_curr_fc(vj_fc_cost, pass_gen_data.vi_exch_rate)
				vj_fc_ecos = %f_curr_fc(vj_fc_ecos, pass_gen_data.vi_exch_rate)
			end
			xcall whgine_attach_cur_val(vdrec, lst_code, pass_gen_data.vi_currency, invoice_totals)
			vj_fc_rrp = vd_rrp(D_FC)
			vj_fc_vi_rrp = vd_vi_rrp(D_FC)
			vj_grp = vd_gcod
			vj_atd_ord_qty = vdqty
			xcall whgine_get_group(vj_grp, vj_grpdes)
			vj_mak = vd_make
			xcall whgine_get_make(vj_mak, vj_makdes)
			vj_model = vd_model
			vj_ser = vdser
			vj_vat = vdvat
			if(.not.vj_vat)
			begin
				if(cms_country.eq.EIRE_VAT) then
					vj_vat=pass_gen_data.h_vat_code
				else
					vj_vat = cms_uk_def_vat
			end
			xcall f_vat_rate(vj_vat, tmp_rate, true)
			if(tmp_rate.and..not.pass_gen_data.h_vatable)
			begin
				if(cms_country.eq.EIRE_VAT) then
					vj_vat=ivt_vat_zero
				else
					vj_vat=cms_uk_zero_vat
			end
			vj_prev_batch = lst_prev_batch
			if cms_gnvcos .eq. D_WG_AUTO_COST_ADJ .and. .not. vd_fin_inv then
				vj_dsp_cost = %max(vj_fc_ecos, vj_fc_cost)
			else
				vj_dsp_cost = vj_fc_cost
			vj_vm_exists = lst_vm_exists
			vj_spec[] = vdmodl[]
			vj_hide_att = vd_hide

		end
		xcall i_display(a_inpid,, whgine_vj,,,,,,,,,, gold_com,
		&             gold_ax)
		exitloop
	end
	return
.end

.subroutine whgine_nstk_load

	a_listid           ,n
	a_request          ,n
	.include 'whgine_vj' repository, group='whgine_vj'
	a_inpid            ,n
	a_disabled         ,n      ;optional
	a_itemindex        ,n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	;end of argument list

	.include "WND:tools.def"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:PMFREC.REC'
	.include 'SRC:PDFREC.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:HIDREC.REC'

	.include 'SRC:HORT.CMN'

	external function
		f_curr_prt,     d
		f_curr_std,     d
		f_curr_bc,      d
		f_curr_fc,      d

		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4


	.align
	record general
		;        .include 'whgine_lst' repository, group='whgine_lst'
		err,            d3
		first_time,     d1
		search,         d1

.proc

	xcall i_ldinp(seq_linp_id, g_utlib, 'whgine_lstinp', D_NOPLC, search,,
	&             h_seq_linp_name)
	case a_request of
	begincase
		;D_LLOADBOT:
		begin
			first_time = a_itemindex .eq. 1
			call load_nstk
		end

		;D_LLOADTOP:
		a_request = D_LEOF

	endcase

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_nstk,
	repeat
	begin
		if first_time
		begin
			xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err)
			clear first_time
		end
		else
			xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err)

		; next line is workaround for synergex bug
		xcall lp_setup(a_listid)

		if err then
		begin
			a_request = D_LEOF
			exitloop
		end

		if whgine_lst.lst_ntype .ne. D_VJ_NSTK
			nextloop

		vj_tstk = lst_stkno
		vj_disp_tstk = lst_disp_stkno

		vj_code = lst_code
		vj_tim_id = lst_tim_id

		vj_fc_cost = lst_cost
		if pass_gen_data.vi_currency .ne. cms_base_cur
			vj_bc_cost = %f_curr_bc(vj_fc_cost, pass_gen_data.vi_exch_rate)

		if pass_gen_data.vi_currency .ne. cms_base_cur
			vj_bc_ecos = lst_pur_cost
		vj_fc_ecos = %f_curr_fc(lst_pur_cost, pass_gen_data.vi_exch_rate)

		vj_dsp_cost = lst_cost
		vj_fc_rrp = lst_retail

		vj_fc_vi_rrp = lst_vi_retail

		vj_fc_sett = lst_sett
		vj_fc_disc = lst_disc
		vj_fc_vi_disc = lst_vi_disc
		vj_dsp_disc = lst_dsp_disc

		vj_fc_mrrp = lst_rrp
		vj_fc_trd_price = lst_trd_price
		vj_grp = lst_grp
		if(pass_chn_data.h_prog_code.ne.P_COD_MACH_TRAD) then
			vj_d_fc_mrrp=vj_fc_mrrp
		else
			vj_d_fc_mrrp=vj_fc_trd_price

		if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC.and.lst_vat)
			xcall whgine_vat_calc(vj_d_fc_mrrp, lst_vat,
			&        vt_vat_code, vt_vrat, vj_d_fc_mrrp,
			&        D_RET_VAT_EXC, D_RET_VAT_INC)
		xcall whgine_get_group(vj_grp, vj_grpdes)
		vj_mak = lst_mak
		xcall whgine_get_make(vj_mak, vj_makdes)
		vj_code = lst_code
		vj_model = lst_model
		vj_ser = lst_ser
		vj_reg = lst_reg
		vj_reg_date = lst_reg_dat
		vj_clok = lst_clok
		vj_vat = lst_vat
		vj_vm_exists = lst_vm_exists
		vj_vm_rfa = lst_vm_rfa
		vj_nom_bonus = lst_bonus
		vj_recv_date = lst_recv_dat
		vj_fin_inv = lst_fin_inv
		vj_vmdeld = lst_vj_vmdeld
		vj_vm_extra_comm = lst_vj_vm_extra_comm
		vj_warr_sdat = lst_warr_sdat
		vj_warr_edat = lst_warr_edat
		vj_warr_end_clock = lst_warr_end_clock
		vj_ex_warr_edat = lst_ex_warr_edat
		vj_ex_warr_end_clock = lst_ex_warr_end_clock
		vj_qualify = lst_qual
		vj_prev_batch = lst_prev_batch
		vj_hide_ln = lst_hide
		vj_moded = lst_moded
		vj_spec[] = lst_spec[]
		; EXTRA NON DISPLAY FIELDS
		vj_type = lst_type
		vj_used = lst_used
		if(pass_gen_data.plan_maint) then
		begin
			whgine_vj.vj_inp_pm_group=whgine_lst.lst_wg_pm_group
			if(whgine_vj.vj_inp_pm_group.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
			begin
				whgine_vj.vj_extra_text='CLK='+%string(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock)
				if(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_est)
					whgine_vj.vj_extra_text=%atrim(whgine_vj.vj_extra_text)+'E'
			end
		end
		else
			vj_inp_md_group=lst_wg_md_group

		xcall i_display(a_inpid,, whgine_vj,,,,,,,,,, gold_com,
		&             gold_ax)
		exitloop
	end
	return
.end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for parts
;
.function whgine_prt_upd, ^val

	a_listid,       n

	a_inpwndid,     n

	.include 'add_part_str' repository, group='part_data'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	a_chn,          n
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'


	external function
		f_calc_val,             d
		f_curr_bc,				d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		at_bottom,      d1
		err,            d3

	record ifours
		req,            i4
		linp_id,        i4
		no_items,       i4
.proc
	req = D_LRESTORE
	xcall l_process( seq_lst_id, req , whgine_lst,, gold_com,
	&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

	xcall l_status(seq_lst_id, D_LINPID, linp_id, D_LLASTITM, no_items)
	case a_mode of
	begincase
		D_LISTIAD_INS:
		begin
			if .not. seq_inserting then
				xcall pos_b4_trade(gold_com, gold_ax, a_fkeys, whgine_passed,
				&                  whgine_lst, invoice_totals)
			else
				reseq_req[D_VJ_PART+1] = true

			xcall l_queue(seq_lst_id, D_LAPPEND)
			req = D_LNOP
			xcall l_process( seq_lst_id, req, whgine_lst,, gold_com, gold_ax,
			&                a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			clear whgine_lst

			list_type = T$PART
			lst_ntype = D_VJ_PART
			part_code = part_no
			set prev_batch, lst_prev_batch  = false
			lst_tstk = 'part' + %string(part_line, 'XXXX')

			lst_orig_price = part_orig_price_fc

			if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC)
				xcall whgine_vat_calc(lst_orig_price, part_vat,
				&     vt_vat_code, vt_vrat, lst_orig_price,
				&     D_RET_VAT_INC, D_RET_VAT_VAL)

			lst_kit_part = part_kit_status

			lst_trd_cmnt = false
			part_wgstk = lst_tstk

			call upd_list_values

		end
		D_LISTIAD_AMD:
		begin
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			repeat
			begin
				if lst_ntype .eq. D_VJ_PART .and. lst_tstk .eq. part_wgstk
				begin
					call upd_list_values

					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
		D_LISTIAD_DEL:
		begin
			if .not. no_items
				freturn D_USER_ABORT
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			repeat
			begin
				if lst_ntype .eq. D_VJ_PART .and. lst_tstk .eq. part_wgstk
				begin
					if prev_batch
						xcall ll_process( pass_chn_data.lst_cntrl, D_LL_INSERT, whgine_lst, err )
					xcall l_process( seq_lst_id, req = D_LDELITEM, whgine_lst,,
					&                gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
					&                whgine_passed, invoice_totals)
					while lst_kit_part .eq. KIT_LINE
						xcall l_process( seq_lst_id, req = D_LDELITEM, whgine_lst,,
						&              gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
						&              whgine_passed, invoice_totals)
					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			end

		end
	endcase
	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab, add_part_passed, invoice_totals)
	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab)
	tot_inv[D_FC] = inv_total
	tot_inv[D_BC]=%f_curr_bc(inv_total, pass_gen_data.vi_exch_rate)
	tot_nett[D_FC] = adv_tot_retail
	tot_nett[D_BC]=%f_curr_bc(adv_tot_retail, pass_gen_data.vi_exch_rate)
	tot_prtlab[D_FC]=tot_nett[D_FC]
	tot_prtlab[D_BC]=tot_nett[D_BC]

	items_moded = true

	freturn D_NO_ERROR
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       update values for inserted and amended lines
	upd_list_values,

	lst_part_type = part_type
	list_desc = part_desc
	lst_disc_pcnt = part_disc
	lst_qty = part_sold_qty
	lst_qty_dp = part_qty_dp
	lst_cust_demand = part_cust_demand
	lst_exclude_fill_rep = part_exclude_fill_rep
	lst_vat = part_vat
	if(whgine_passed.f_acc_wg_exclude.eq.2)
		set part_cost[D_FC], part_cost[D_BC]=0
	lst_dsp_cost = part_cost[D_BC]
	if part_type .gt. D_PMF_TYP_MEMO then
		lst_tot_cost = part_cost_fc
	else
		lst_tot_cost = part_cost_fc * part_sold_qty
	if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC) then
	begin
		lst_vi_retail=part_retail_fc
		xcall whgine_vat_calc(lst_retail, lst_vat,
		&        vt_vat_code, vt_vrat, lst_vi_retail,
		&        D_RET_VAT_INC, D_RET_VAT_EXC)
	end
	else
	begin
		lst_retail = part_retail_fc
		xcall whgine_vat_calc(lst_vi_retail, lst_vat,
		&        vt_vat_code, vt_vrat, lst_retail,
		&        D_RET_VAT_EXC, D_RET_VAT_INC)
	end
	lst_tot_retail = lst_retail * part_sold_qty
	if part_disc then
		lst_disc = %f_calc_val(part_sold_qty, lst_retail) -
		&             %f_calc_val(part_sold_qty, lst_retail, part_disc)
	else
		lst_disc= 0
	lst_dsp_disc=lst_disc
	lst_vi_disc=lst_disc
	lst_sett=part_sett_value_fc
	if(pass_chn_data.h_prog_code.ne.P_COD_WGD_VAT_INC) then
	begin
		xcall whgine_vat_calc(lst_vi_disc, lst_vat,
		&        vt_vat_code, vt_vrat, lst_vi_disc,
		&        D_RET_VAT_EXC, D_RET_VAT_INC)
		lst_sett = lst_tot_retail - lst_disc - lst_sett
	end
	else
		clear lst_sett

	lst_moded = true
	xcall set_qty_dp(linp_id, lst_qty_dp)
	xcall i_display(linp_id,, whgine_lst)
	xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
	&                    gold_ax,a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine pos_b4_trade

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'

	record gen
		mark_set,       d1
		trade_in_fnd,   d1
		at_top,         d1

	record ifours
		req,            i4
		up_numb,        i4
		loop,           i4

.proc
	clear gen, ^i(ifours)
	req = D_LBOTTOM
	mark_set = -1
	xcall l_process( seq_lst_id, req, whgine_lst,, gold_com,
	&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals )
	repeat
	begin
		if mark_set .eq. -1 .and. lst_ntype .ne. D_VJ_TRADE
		begin
			; our first non trade-in rec
			mark_set = up_numb
			if trade_in_fnd
				exitloop
		end
		if mark_set .ne. -1 .and. lst_ntype .eq. D_VJ_TRADE
			; must have comments after trade in so clear mark_set
			mark_set = -1

		if lst_ntype .eq. D_VJ_TRADE
			trade_in_fnd = true

		xcall l_status(seq_lst_id, D_LATTOP, at_top)

		if at_top
			exitloop

		xcall l_process( seq_lst_id, req = D_LUP, whgine_lst,, gold_com,
		&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals )
		incr up_numb
	end

	if mark_set .eq. -1 then
		; empty list?
		xcall l_process( seq_lst_id, req = D_LBOTTOM, whgine_lst,, gold_com,
		&              gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals )
	else
	begin
		xcall l_process( seq_lst_id, req = D_LBOTTOM, whgine_lst,, gold_com,
		&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals )
		for loop from 1 thru mark_set
			xcall l_process(seq_lst_id, req = D_LUP, whgine_lst,, gold_com,
			&          gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	end
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for parts
;
.subroutine whgine_cmnt_upd

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'invoice_totals' repository, group='invoice_totals'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		at_bottom,      d1
		err,            d3

	record ifours
		req,            i4
		linp_id,        i4
.proc
	req = D_LRESTORE
	xcall l_process( seq_lst_id, req , whgine_lst,, gold_com,
	&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

	xcall l_status(seq_lst_id, D_LINPID, linp_id)
	case a_mode of
	begincase
		D_LISTIAD_INS:
		begin
			if .not. seq_inserting then
				xcall pos_b4_trade(gold_com, gold_ax, a_fkeys, whgine_passed,
				&                  whgine_lst, invoice_totals)
			else
				reseq_req[D_VJ_COMMENT+1] = true

			xcall l_process( seq_lst_id, req = D_LAPPEND, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			clear whgine_lst
			list_type=T$COMMENT
			lst_ntype = D_VJ_COMMENT
			lst_cmnt_line = lst_comment
			incr lst_cmnt_seq
			cmnt_no = lst_cmnt_seq
			lst_tstk = 'comm' + %string(lst_cmnt_seq, 'XXXX')
			set cmnt_prev_batch, lst_prev_batch = false
			lst_trd_cmnt = trd_cmnt_flg
			lst_hide = cmnt_hide
			lst_moded = true
			xcall i_display(linp_id,, whgine_lst)
			xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
		end
		D_LISTIAD_AMD:
		begin
			clear at_bottom
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			repeat
			begin
				if lst_ntype .eq. D_VJ_COMMENT .and. ^d(lst_tstk(5:4)) .eq. cmnt_no
				begin
					lst_cmnt_line = lst_comment
					lst_hide = cmnt_hide
					lst_moded = true
					xcall i_display(linp_id,, whgine_lst)
					xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
					&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
		D_LISTIAD_DEL:
		begin
			clear at_bottom
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			repeat
			begin
				if lst_ntype .eq. D_VJ_COMMENT .and. ^d(lst_tstk(5:4)) .eq. cmnt_no
				begin
					if cmnt_prev_batch          ; add to delete list
						xcall ll_process( pass_chn_data.lst_cntrl, D_LL_INSERT, whgine_lst, err )
					xcall l_process( seq_lst_id, req = D_LDELITEM, whgine_lst,,
					&                gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
					&                whgine_passed, invoice_totals)
					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
	endcase
	items_moded = true
	cmnt_moded = true
	xreturn
.end

.subroutine whgine_seq_arv
	a_status,       n
	a_listid,       n
	a_win_event,    n
	.include 'whgine_lst' repository, group='whgine_lst'
	a_inpid,        n
	a_disabled,     n
	a_index,        n
	a_row,          n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'

.proc
	xcall set_seq_fkeys(gold_com, gold_ax, fkeys, a_listid, whgine_lst,
	&                   whgine_passed)
	xreturn
.end

.subroutine set_seq_fkeys

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	a_listid,       n
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		.include 'whgine_lst' repository, group='whgine_nxt_itm'
		at_btm,         d1
		at_top,         d1
		search,         d1
		err,            d3
		no_items,       d3

	.align
	record ivars
		linp_id,        i4

.proc
	if .not. seq_fkeys_active
		xreturn

	xcall l_status(a_listid, D_LATBOTTOM, at_btm, D_LATTOP, at_top,
	&               D_LLASTITM, no_items)

	fkeys.fkey[D_FK_NO5].disabled_flg = .not. no_items .or.
	&       pass_gen_data.adv_mode .eq. D_VEW_MODE
	fkeys.fkey[D_FK_NO6].disabled_flg = .not. no_items .or.
	&       pass_gen_data.adv_mode .eq. D_VEW_MODE

	if .not. no_items .or. pass_gen_data.adv_mode .eq. D_VEW_MODE then
	begin
		fkeys.fkey[D_FK_NO7].disabled_flg = true
		fkeys.fkey[D_FK_NO8].disabled_flg = true
	end
	else
	begin
		fkeys.fkey[D_FK_NO7].disabled_flg = at_top
		fkeys.fkey[D_FK_NO8].disabled_flg = at_btm

		if whgine_lst.lst_ntype .eq. D_VJ_TRADE
		begin
			call check_tin
		end

		; if move_down still enabled check next item down
		; if next item is trade in we can't move down unless we're a comment
		if (.not. fkeys.fkey[D_FK_NO8].disabled_flg .and.
		&     (whgine_lst.lst_ntype.ne.D_VJ_COMMENT).and.
		&     (whgine_lst.lst_ntype.ne.D_VJ_TRADE))
		begin
			xcall i_ldinp(linp_id, g_utlib, 'seq_lst', TRUE, search, err,
			&                 h_seq_linp_name)
			xcall l_data(a_listid, D_LCURRENT, linp_id, whgine_nxt_itm,, err)
			xcall l_data(a_listid, D_LNEXT, linp_id, whgine_nxt_itm,, err)
			fkeys.fkey[D_FK_NO8].disabled_flg =
			&           whgine_nxt_itm.lst_ntype .eq. D_VJ_TRADE
		end
	end
	xcall ibc_fkeys(a_listid, fkeys, true)

	xreturn

	check_tin,

	xcall i_ldinp(linp_id,g_utlib,'seq_lst',TRUE,search,err,h_seq_linp_name)
	xcall l_data(a_listid,D_LCURRENT,linp_id,whgine_nxt_itm,,err)
	xcall l_data(a_listid,D_LNEXT,linp_id,whgine_nxt_itm,,err)
	if (whgine_nxt_itm.lst_ntype.eq.D_VJ_TRADE.or.
	&   whgine_nxt_itm.lst_ntype.eq.D_VJ_COMMENT) then
		fkeys.fkey[D_FK_NO8].disabled_flg = FALSE
	else
		fkeys.fkey[D_FK_NO8].disabled_flg = TRUE
	xcall l_data(a_listid,D_LCURRENT,linp_id,whgine_nxt_itm,,err)           ; D_LPREV?
	xcall l_data(a_listid,D_LPREV,linp_id,whgine_nxt_itm,,err)
	if (whgine_nxt_itm.lst_ntype.eq.D_VJ_TRADE.or.
	&   whgine_nxt_itm.lst_ntype.eq.D_VJ_COMMENT) then
		fkeys.fkey[D_FK_NO7].disabled_flg = FALSE
	else
		fkeys.fkey[D_FK_NO7].disabled_flg = TRUE

	xcall l_status(a_listid,D_LATBOTTOM,at_btm)
	if (at_btm)
		fkeys.fkey[D_FK_NO8].disabled_flg = TRUE

	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for customer field
.function whgine_tstk_change, ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'

	.include 'SRC:VEHINE_LST.CMN'   ; list of advice detail lines

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record general
		error_text,     a70
		err,            d4
		err2,           d4
		req,            d4

.proc
	if(a_data_entered.and.a_data_entered.ne.'?'
	&  .and.viivcr.ne.D_VIIVCR_PART_INV)
	begin
		error_text='Invalid - this {WHOLEGD} exists in'
		if(viivcr.eq.D_VIIVCR_CREDIT.or.
		&  viivcr.eq.D_VIIVCR_PART_CRED) then
			xcall file(pass_chn_data.chn(VM_FILE),vmrec,a_data_entered,'RD',err,,,,,D_NO_LOCK)
		else
			xcall file(pass_chn_data.chn(HM_FILE),vmrec,a_data_entered,'RD',err,,,,,D_NO_LOCK)
		if(.not.err)
		begin
			if(viivcr.eq.D_VIIVCR_CREDIT.or.
			&  viivcr.eq.D_VIIVCR_PART_CRED) then
				error_text=%atrim(error_text)+' stock'
			else
			begin
				error_text=%atrim(error_text)+' history'
				if(vmivno)
					error_text=%atrim(error_text)+' - see invoice no '+vmivno
			end
			xcall ibc_message(%atrim(error_text))
			xcall i_init(inp_wndid,, whgine_vj, 'vj_tstk')
			freturn D_EMITTEDERR
		end
	end
	a_pending_status = %vm_change( a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj )

	if( g_select .and. (g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL') .or.
	&   a_pending_status.ne.D_OK )      ; Menu entry
		freturn a_pending_status

	; Code to check whether this wgd already exists on this
	; advice.  If it does, this is obviously invalid
	call check_if_wgd_on_advice_already
	if(err) goto vj_tstk_error

	xcall m_signal('TSTK_CHG')

	freturn a_pending_status

	vj_tstk_error,
	xcall m_signal(g_entnam, D_REMOVE)
	xcall i_init(inp_wndid,, whgine_vj, 'vj_tstk')
	freturn D_EMITTEDERR
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; this section checks the wholegood list to ensure that the wgd
        ; selected does not already exist on the list
	check_if_wgd_on_advice_already,

	err=false
	xcall l_remove(seq_lst_id)
	xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err2)
	while .not. err2
	begin
		if(whgine_lst.lst_ntype .eq. D_VJ_WGD)
		begin
			if(whgine_lst.lst_tstk.eq.a_data_stored)
			begin
				xcall ibc_message('Invalid - this wholegood has already been selected')
				err=true
				exitloop
			end
		end
		xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err2)
	end
	xcall l_process(seq_lst_id, req = D_LRESTORE, whgine_lst,,
	&               gold_com, gold_ax,, whgine_passed, invoice_totals)

	return

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for non stocked stock no field
.function whgine_nstk_tstk_change, ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'

	.include 'SRC:VEHINE_LST.CMN'   ; list of advice detail lines

	;               global areas for list processing and the like
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		err,            i4
		no_items,       i4
		linp_id,        i4
		.include 'whgine_lst' repository, group = 'lst_data'

.proc
	if(a_data_entered.eq.T$AUTO.or..not.a_data_entered)
	begin
		xcall ibc_message('Invalid - Auto numbering is not in use')
		freturn D_EMITTEDERR
	end

	xcall l_status(seq_lst_id, D_LLASTITM, no_items)
	if no_items
	begin
		xcall i_ldinp(linp_id, g_utlib, 'whgine_totinp', D_NOPLC,,,
		&         h_seq_linp_name)
		if(.not.pass_gen_data.plan_maint.and.
		&   wg_security .eq. ACC_NO_COST_DISP)
			xcall i_setdel(linp_id, 'full_set', 'lst_tot_cost')

		xcall l_data( seq_lst_id, D_LFIRST, linp_id, lst_data,, err )
		while( .NOT. err )
		begin
			if a_data_entered .eq. lst_data.lst_stkno
			begin
				xcall ibc_message('Invalid - Non Stocked {WHOLEGD} No '
				&                   +'already in use on this advice')
				xcall ibc_window(D_DELETE, linp_id)
				freturn D_EMITTEDERR
			end
			xcall l_data( seq_lst_id, D_LNEXT, linp_id, lst_data,, err )
		end
		xcall ibc_window(D_DELETE, linp_id)
	end

	freturn D_OK

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for plan maintenance equipment entry
.function whgine_pm_equip_change, ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:PMHREC.REC'
	.include 'SRC:PMLREC.REC'
	.include 'SRC:PMCREC.REC'
	.include 'SRC:VEHINE_LST.CMN'   ; list of advice detail lines

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record general
		.include 'pmh_user' repository, group = 'pmh_user'

		.include 'whgine_lst' repository, group = 'lst_data'
		group pml_k1
			pml_k1_equip,   a8
			pml_k1_contract,a8
			pml_k1_srv_series,d4
		endgroup

	record i4s
		err,            i4
		no_items,       i4
		total_items,       i4

.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT'
	&               .or. g_entnam .eq. 'PMH_LOOKUP'))
		freturn a_pending_status

	xcall i_user(inp_wndid, 'WG_PM_EQUIP_NO', pmh_user)

	if (a_data_entered.and.%instr(1,a_data_entered,'?')) .or.
	&       (g_select .and. g_entnam .eq. 'I_DRILL')
	begin
		pmh_user.chk_equip='EQUIP2'
		pmh_user.chk_service_series=true
		xcall i_user(inp_wndid, 'WG_PM_EQUIP_NO',, pmh_user)
		xcall m_signal('I_DRILL')
		freturn D_OK
	end
	no_items=0
	total_items=0

	if(pmh_user.chk_equip.and.pmh_user.chk_equip.eq.a_data_entered)
		whgine_vj.vj_inp_pm_group.wg_pm_service_series=pmh_user.chk_service_series

	if(a_data_entered.eq.vi_i_pm_contract)
	begin
		if(pmh_user.chk_equip.and.pmh_user.chk_equip.ne.'EQUIP2')
		begin
			set a_data_entered, a_data_stored=pmh_user.chk_equip
			if(pmh_user.chk_equip.and.pmh_user.chk_equip.eq.a_data_entered)
				whgine_vj.vj_inp_pm_group.wg_pm_service_series=pmh_user.chk_service_series
		end
	end
	if(a_data_entered)
	begin
		xcall file(pass_chn_data.chn(PML_FILE), pmlrec, %atrim(vi_i_pm_contract), 'FI', err,0,,,,D_NO_LOCK)
		repeat
		begin
			xcall file(pass_chn_data.chn(PML_FILE), pmlrec,, 'RS', err,,,,,D_NO_LOCK)
			if(err) exitloop

			if(pml_contract.ne.vi_i_pm_contract) exitloop
			incr total_items

			if(pml_equip_no.ne.%atrim(a_data_entered)) nextloop
			if(pmh_user.chk_equip.and.pmh_user.chk_equip.eq.a_data_entered.and.
			&  whgine_vj.vj_inp_pm_group.wg_pm_service_series.ne.pmm_service_series) nextloop

			incr no_items
			pml_k1_srv_series=pmm_service_series
			pml_k1_equip=pml_equip_no
		end
		if(no_items.eq.0)
		begin
			xcall ibc_message('Equipment Line not found on contract '+vi_i_pm_contract)
			xcall m_signal('J_QUIT')
			freturn D_OK
		end
	end

	if(no_items.gt.1)
	begin
		xcall m_signal('I_DRILL')
		freturn D_OK
	end

	xcall file(pass_chn_data.chn(PMH_FILE), pmhrec,vi_i_pm_contract, 'RD', err,,,,,D_NO_LOCK)

	pml_k1_contract=vi_i_pm_contract
	xcall file(pass_chn_data.chn(PML_FILE), pmlrec, pml_k1, 'RD', err,1,,,,D_NO_LOCK)
	if(err)
	begin
		xcall ibc_message('Error reading PML contract line')
		if(no_items == 1)
		begin
			xcall m_signal('J_QUIT')
			freturn D_OK
		end
		xcall i_init(inp_wndid,,,'WG_PM_EQUIP_NO')
		xcall i_next(inp_wndid,,'WG_PM_EQUIP_NO')
		freturn D_OK
	end

	xcall file(pass_chn_data.chn(PMC_FILE), pmcrec, pmm_charge_code, 'RD', err)
	if(err)
	begin
		xcall ibc_message('Invalid - The charge code for this equipment line is set to '+pmm_charge_code
		&   +' but this is not a valid charge code')
		if(total_items == 1)
		begin
			xcall m_signal('J_QUIT')
			freturn D_OK
		end
		xcall i_init(inp_wndid,,,'WG_PM_EQUIP_NO')
		xcall i_next(inp_wndid,,'WG_PM_EQUIP_NO')
		freturn D_OK
	end
	if(pmc_charge_type.eq.PM_NOT_SET)
	begin
		xcall ibc_message('Invalid - The charge code for this equipment line is set to '+pmm_charge_code
		&   +' and the charge type for this is not set')
		if(total_items == 1)
		begin
			xcall m_signal('J_QUIT')
			freturn D_OK
		end
		xcall i_init(inp_wndid,,,'WG_PM_EQUIP_NO')
		xcall i_next(inp_wndid,,'WG_PM_EQUIP_NO')
		freturn D_OK
	end
	if(pmc_charge_type.eq.PMC_CHARGE_AS_PER_WSJ)
	begin
		xcall ibc_message('Invalid - The charge code for this equipment line is set to '+pmm_charge_code
		&   +' and the charge type for this is set to Time & Materials on WSJ which is invalid for this routine')
		if(total_items == 1)
		begin
			xcall m_signal('J_QUIT')
			freturn D_OK
		end
		xcall i_init(inp_wndid,,,'WG_PM_EQUIP_NO')
		xcall i_next(inp_wndid,,'WG_PM_EQUIP_NO')
		freturn D_OK
	end

	if(pmc_charge_type.eq.PMC_CHARGE_CLOCK_READING) then
	begin
		xcall ibc_window( D_PLACE, inp_nstk_clk_id, 6,1)
		xcall i_display(inp_nstk_clk_id,, whgine_vj,,,,,,,,,,gold_com ,gold_ax, pmhrec,pmlrec)
	end
	else
	begin
		xcall ibc_window( D_REMOVE, inp_nstk_clk_id)

	end
	; ALSO NEED TO VALIDATE IF THE ITEM ALREADY APPEARS ON THIS INVOICE

	whgine_vj.vj_inp_pm_group.wg_pm_service_series=pml_k1_srv_series
	set a_data_stored, a_data_entered = pml_k1_equip
	xcall i_putfld(inp_wndid,, whgine_vj, 'WG_PM_EQUIP_NO',
	&                 pml_k1_equip, gold_com)
	xcall m_signal('PML_EQUIP_CHG')
	freturn a_pending_status
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       change method for current clock reading
;       displys a warning message if current < previous
.function whgine_wg_pm_clock_change , ^val
	a_data_entered,     n
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		fldnam,         a20
.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT'))
		freturn a_pending_status

	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	upcase fldnam
	if(fldnam.eq.'WG_PM_CURR_CLOCK'.and.a_data_stored.lt.wg_pm_last_clock)
	begin
		xcall ibc_message('Warning - the current clock reading is less than previous')
	end
	if(wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
	begin
		xcall i_putfld(inp_wndid,,whgine_vj,fldnam, a_data_stored)
		vj_fc_rrp=(wg_pm_curr_clock-wg_pm_last_clock-wg_pm_idle_time)*wg_pm_contract_charge
	end
	xcall i_dspfld(inp_wndid,'vj_fc_rrp',vj_fc_rrp, gold_com)

	xcall whgine_vat_calc(vj_fc_vi_rrp, vj_vat,
	&     vt_vat_code, vt_vrat, vj_fc_rrp,
	&     D_RET_VAT_EXC, D_RET_VAT_INC)
	xcall whgine_vj_curr_vals(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       change method for unit charge change for clock reading
;       displays a warning message if current < previous
.function whgine_wg_pm_charge_change , ^val
	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'


	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal


.proc
	a_pending_status = %currency_na_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj, gold_com, gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status
	whgine_vj.wg_pm_contract_charge=a_data_stored

	xcall whgine_set_plan_maint_charges(inp_wndid,
	&       whgine_vj, whgine_passed, gold_com,invoice_totals)
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_plan_maint_charges
	inp_wndid,  n
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'gold_com' repository, group='gold_com'
	.include 'invoice_totals' repository, group='invoice_totals'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal


.proc
	vj_fc_rrp=wg_pm_contract_charge
	if(wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
	begin
		vj_fc_rrp=vj_fc_rrp*(wg_pm_curr_clock-wg_pm_last_clock-wg_pm_idle_time)
	end
	xcall i_dspfld(inp_wndid,'vj_fc_rrp',vj_fc_rrp, gold_com)

	xcall whgine_vat_calc(vj_fc_vi_rrp, vj_vat,
	&     vt_vat_code, vt_vrat, vj_fc_rrp,
	&     D_RET_VAT_EXC, D_RET_VAT_INC)
	xcall whgine_vj_curr_vals(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_wgd_mnu, ^val

	a_entnam,       a

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VGREC.REC'
	.include 'SRC:PREREC.REC'
	.include 'SRC:TRSREC.REC'
	.include 'SRC:PMHREC.REC'
	.include 'SRC:PMLREC.REC'
	.include 'SRC:WQLREC.REC'


	external function
		f_curr_fc,      d
		f_curr_bc,      d
		f_file,         d
		f_yes_no,		d
		f_alpha11_date,	a

		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		dummy_id,       i4
		ret_val,        d1
		err,            d3
		loop,           d2
		yes_no_ans,     d1
		model_code,     a13
		no_items,       d3
		pm_view,	d1
		.include 'whgine_lst' repository, group = 'lst_data'
		lLomDesc,		a30
		lTmpTransfer,	a6
	endrecord

	record ifours
		linp_id,        i4
		;       tmp_pdi,        i8
		tmp_bonus,      i8
		lJournalVal,	i8

.proc
	clear lTmpTransfer
	ret_val = false         ; set to true if invalid value entered
	case a_entnam of
	begincase
		'GET_INPID':
		if a_mode .eq. D_LISTIAD_AMD .or. a_mode .eq. D_LISTIAD_VIEW then
		begin
			if vj_wg_attach then
				freturn pass_gen_data.inp_atd_id
			else
				freturn pass_gen_data.inp_vj_id
		end
		else
			freturn pass_gen_data.inp_vj_id
		'TSTK_CHG':
		begin
			; first check if wgd already entered on this advice
			if pass_gen_data.adv_mode .eq. D_INS_MODE
			begin
				xcall l_status(seq_lst_id, D_LLASTITM, no_items)
				if no_items
				begin
					xcall i_ldinp(linp_id, g_utlib, 'whgine_totinp', D_NOPLC,,,
					&         h_seq_linp_name)
					if(wg_security .eq. ACC_NO_COST_DISP)
						xcall i_setdel(linp_id, 'full_set', 'lst_tot_cost')

					xcall l_data( seq_lst_id, D_LFIRST, linp_id, lst_data,, err )
					while( .NOT. err )
					begin
						if vj_tstk .eq. lst_data.lst_stkno
						begin
							xcall ibc_message('Invalid - {WHOLEGD} already in use on this advice')
							xcall ibc_window(D_DELETE, linp_id)
							goto vj_tstk_error
						end
						xcall l_data( seq_lst_id, D_LNEXT, linp_id, lst_data,, err )
					end
					xcall ibc_window(D_DELETE, linp_id)
				end
			end
			chk_again,
			clear f_history
			if (viivcr) then
			begin
				xcall file(pass_chn_data.chn(HM_FILE),vmrec,vj_tstk,'RD',err,, vj_vm_rfa,,,
				&              D_NO_LOCK)
				if(.not.err) f_history=TRUE
			end
			else
				xcall file(pass_chn_data.chn(VM_FILE),vmrec,vj_tstk,'RD',err,, vj_vm_rfa,,,
				&      D_NO_LOCK)
			if err
			begin
				if(.not.viivcr) then
				begin
					xcall file(pass_chn_data.chn(HM_FILE),vmrec,vj_tstk,'RD',err,,
					&      vj_vm_rfa,,,D_NO_LOCK)
					if(.not.err) f_history=TRUE
				end
				else
					xcall file(pass_chn_data.chn(VM_FILE),vmrec,vj_tstk,'RD',err,,
					&              vj_vm_rfa,,,D_NO_LOCK)
				if(.not.err.and.viivcr.ne.D_VIIVCR_PART_INV) goto invalid_hist
			end

			if(dt.ne.vm_depot)
			begin
				err = 1
				if cms_wgd_inv_idt.and.cms_wg_idt_prt.le.D_WG_IDT_PRT_DN_R
					xcall xsubr('VEHTRN', 'WHGINE', vj_tstk, vm_depot,
					&               gold_com.cur_depot, err)

				if err then
				begin
					xcall ibc_message('Invalid - {WHOLEGD} '+vmstok
					&                 +' is at depot no '+vm_depot)
					goto vj_tstk_error
				end
				else
					goto chk_again
			end

			xcall file( g_com_chn, cm3rec, 3, 'RN', err,,,,,D_NO_LOCK)
			if(.not.viivcr.and.vmstat)
			begin
				for loop from 1 thru 12
					if(vmstat.eq.cm3_gnvhss(loop).and.cm3_gnvhsf(loop).eq.false)
					begin
						xcall ibc_message('Invalid - {WHOLEGD} stock status is set to '
						&               +vmstat+' - ' + %atrim(cm3_gnvhsd(loop)) + ' and it may not be sold.')
						goto vj_tstk_error
					end
				; if this wgd is idt in transit would not normally expect to
				; be able to sell - ut if set to sell  warn user and
				; give them option not to select
				if(vm_idt_to_depot.and.vmstat.eq.cm3_wg_idt_status)
				begin
					if(%f_yes_no('Warning - Wholegood is IDT In Transit - Continue?',,,true, false).eq.false)
						goto vj_tstk_error
				end
			end

			if(whgine_passed.f_acc_wg_exclude.and.
			&  %f_chk_vgf_restricted(,vmrec.vmgrp, vmrec.vm_depot, true, vmrec.vmstok))
			begin
				goto vj_tstk_error
			end

			; check history or stock as approprate
			;   if(chk_ret_val.ne.viivcr+D_WGD_FND_LIVE) then
			if(viivcr.ne.D_VIIVCR_PART_INV.and.
			&   ((.NOT.f_history.and.viivcr)
			&   .or.(f_history.and..not.viivcr)))
			begin
				invalid_hist,
				if(viivcr.eq.D_VIIVCR_CREDIT.or.viivcr.eq.D_VIIVCR_PART_CRED) then
					xcall ibc_message('Invalid - this {WHOLEGD} is not in history')
				else
				begin
					if(vmivno) then
						xcall ibc_message('Invalid - this {WHOLEGD} has already been '
						&                   +' invoiced.  See advice no '+vmadno+ ' Invoice no '
						&                   +vmivno)
					else
						xcall ibc_message('Invalid - this {WHOLEGD} is in history')
				end
				goto vj_tstk_error
			end

			if (vminvf && vmadno != vijob)
			begin
				if (%WHGINE_Allocated(vmrec))
					goto vj_tstk_error
			end
			; WG7433 - 121009 - START OF BLOCK
			; NOTE 121009 - CHANGE PRIMARILY FOR EIRE BUT ALSO FOR UK IN THAT NOW WGD IN
			; ADDITION TO VEHICLES MAY BE SOLD ON THE USED CAR INVOICE TYPE
			; NOTE THAT A CHUNK OF THE VALIDATION HAS BEEN CHANGED FOR THIS
			; THE ORIGINAL - CODE HAS BEEN COPIED AND STORED BELOW IN SECTION
			; ORIGINAL_USED_CAR_SALE_VALIDATION below
			;

			if (pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL .and. vmnu.eq.'N')
			begin
				xcall ibc_message ('Invalid - NEW Item not allowed for this invoice type')
				goto vj_tstk_error
			end

			; when used car sale type and supplied by customer and
			; qualifying flag not set and not received then invalidate
			if (pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL.and.vmpsys.eq.'C'
			&           .and.vm_qualifying.eq.false.and.vmass)
			begin
				xcall ibc_message ('Invalid - You must receive the trade in before'
				&           +' it can be sold in order to ascertain the vatable value')
				goto vj_tstk_error
			end

			if ((cms_country.eq.UK_VAT.or.cms_country.eq.EIRE_VAT)
			&	  	.and.vm_qualifying.eq.TRUE.and.
			&          pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL)
			begin
				xcall ibc_message ('Invalid - Only NON QUALIFYING  Used items'
				&                   +' allowed for this invoice type')
				goto vj_tstk_error
			end

            ; special for rickerbys - always set qual = true
            ; as the special vat on used car sales non applicable for them
			if (cms_user_id != 10436 && (cms_country == UK_VAT || cms_country == EIRE_VAT)&&
			&	   	! vm_qualifying && pass_chn_data.h_prog_code != P_COD_CAR_SAL && vmnu == 'U')
			begin
				vwrec='WARNING - This item has the VAT Qualifying flag set to No.\n'
				&		+'Potentially, these items could be sold under the VAT Margin\n'
				&		+'Scheme Invoice type where VAT is charged on the profit.\n'
				&		+'Continue with this item?'
				err = %f_yes_no(%atrim(vwrec), , , , vmtype != 1, true)
				if(! err)
				begin
					goto vj_tstk_error
				end
			end
			; NOTE THE FOLLOWING WARNING MESSAGE IS A STOP GAP WARNING.  THIS
			; IS APPLICABLE TO EIRE ONLY AND WHERE THE WGD APPLICABLE
			; MAY HAVE BEEN SUBJECT TO SPECIAL VAT SCHEME INVOLVING
			; POTENTIAL VAT CLAWBACK IF LOSS MAKING.  NOW, EIRE HAVE COME INTO
			; LINE WITH UK SO THAT THESE WHOLEGOODS ARE PROCESSED USING
			; THE VAT MARGIN SCHEME AND VAT IS APPLIED ONLY TO THE MARGIN.
			; THE STOP GAP MEASURE IS SIMPLY TO WARN THE USER THAT
			; ON QUALIFYING WGD TYPE WHERE VAT IS ONLY APPLIED TO THE
			; MARGIN.  IF THEY  ARE STOCKED BEFORE 1/1/10 THEN POTENTIAL
			; THE SPECIAL VAT RECLAMATION SCHEME MAY BE APPLICABLE.
			if(cms_country.eq.EIRE_VAT.and.
			&	   	vm_qualifying.ne.TRUE.and.
			&           pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL .and.vmnu.eq.'U'.and.
			&	   	.not.vmass.and.vmrdat.le.20091231)
			begin
				xcall ibc_message ('WARNING - this item was stocked before'
				&		   +' 01/01/2010 and therefore the VAT scheme with potential'
				&		   +' VAT clawback may apply. Note that this routine now'
				&		   +' processes such items using the VAT Margin scheme.  If in'
				&		   +' doubt please refer to the Gold release notices or'
				&		   +' contact the Gold helpline.')
			end
			if(vmass.eq.D_WG_CONSIGN)
			begin
				xcall ibc_message('Invalid - This {WHOLEGD} is on consignment')
				goto vj_tstk_error
			end
			if (vmivno == '999999' && cms_sld_plant && vm_hire_code)
			begin
				xcall ibc_message('Invalid - This {WHOLEGD} has been transerred to Plant Hire - Code '+vm_hire_code)
				goto vj_tstk_error
			end
			if (vmrec.vm_quote && vmrec.vm_quote != virec.vi_quote)
			begin
				data lQuoteCust,	a6
				data lQuoteNick,	a10
				data lQuoteDate,	d8
				data lQuoteStatus,	d2

				whgine_get_quote_dets(gold_com, vmrec.vm_quote, lQuoteDate, lQuoteCust, lQuoteNick, lQuoteStatus)
				; if quote number and it is actve - presume this means < 9 ie. not invoice, elapsed, dead, inv prev period
				if (lQuoteDate && lQuoteStatus < 9)
				begin
					data lMessage,	a120
;123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
;This {WHOLEGD} is allocated to Quote 123456 for Customer 123456 1234567890 dated dd/mmm/yyyy do you wish to continue?'+ vmrec.vmcust
					xcall s_bld(lMessage,,'This {WHOLEGD} is allocated to Quote %a for Customer %a %a '
					&	+'dated %a - Do you wish to continue?', vmrec.vm_quote, lQuoteCust, lQuoteNick,
					&	%f_alpha11_date(lQuoteDate) )
					if(%f_yes_no(%atrim(lMessage),,,,false, true) != true)
						goto vj_tstk_error
				end
			end

			if(vmcust .and. vmcust.ne. %atrim(vi_cust))
			begin
				; if partial credit, do not allow entry of a different customer
				if(vi_iorc.eq.D_VIIVCR_PART_CRED.or.viivcr.eq.D_VIIVCR_PART_INV) then
				begin
					xcall ibc_message('Invalid - This {WHOLEGD} is allocated to '
					&              +'customer '+vmcust)
					goto vj_tstk_error
				end
				else
				begin
					yes_no_ans=D_NO
					xcall yes_no('Warning - Stock Allocated to Customer '+VMCUST+
					&             ' - Continue',yes_no_ans)
					if(yes_no_ans.ne.D_YES)
						goto vj_tstk_error
				end
			end

			if(vmass.eq.D_WG_ON_ORDER) then
			begin
				if(vmpsys .eq. 'C') then
				begin
					xcall ibc_message('Warning - This is a trade-in not yet invoiced')
				end
				else
					xcall ibc_message('Warning - This {WHOLEGD} is on order')
			end


			if f_history then
			begin
				vj_vm_exists = 'H'
				if(viivcr.eq.D_VIIVCR_PART_INV)
					xcall ibc_message('Warning - This {WHOLEGD} is sold')
			end
			else
				vj_vm_exists = 'S'

			if (vj_vm_exists)
			begin
				pass_chn_data.h_stok = vmstok
				f_lock_vm = 2
				xcall check_vm_exists(whgine_passed, vj_vm_exists, vj_vm_rfa)
				if (! vj_vm_exists)
					goto vj_tstk_error
			end
			else
				clear vmrec

			if (vmrec.vm_lombard)
			begin
				xcall LOM_DRILL_FileRead(vmrec.vm_lombard, lLomDesc, err)
				xcall ibc_message('Warning - This {WHOLEGD} has a Finance Scheme Code set to ' + vmrec.vm_lombard + ': ' + lLomDesc)
			end

			if(.not.err.and.vm_sell_cur.ne.vi_sell_cur)
			begin

				; if this is a used wg then we do not want to pick up the standard
				; price for the wholegood.  Instead, set dummy code and this will have effect
				; of converting using standard exchange rates instead of curreny pricing
				; model_code is a convenient field to use for this purpose.

				if(vmnu.eq.'U') then model_code='??????????'
				else model_code=vmcode
				xcall calc_wg_pric(vmmrrp,model_code,,vi_sell_cur,vm_sell_cur,vmmrrp,1)
				if(vmmrrp)
				begin
					xcall ibc_message('Price changes due to change of customer'
					&           +' currency from '+vm_sell_cur+' to '+vi_sell_cur)
				end
				if(vm_rrp(D_FC))
				begin
					xcall calc_wg_pric(vm_rrp(D_FC),model_code,,vi_sell_cur,
					&                   vm_sell_cur,vm_rrp(D_FC),1)
					vm_rrp(D_BC)=%f_curr_bc(vm_rrp(D_FC),vi_cur_cnv)
				end
				; RETURN TRADE PRICE NOTE ARGUMENT NO 7 SET TO 2
				xcall calc_wg_pric(vm_trd_price,model_code,,vi_sell_cur,vm_sell_cur,vm_trd_price,2)
			end

			if(vi_iorc.eq.D_VIIVCR_PART_CRED.or.
			&  (viivcr.eq.D_VIIVCR_PART_INV.and.
			&   vj_vm_exists.eq.'H'.and.
			&   vistat .lt. D_ADV_INVOICED) ) then
				clear vj_attach_num, vj_attach_tot
			else
			begin
				vj_attach_num = %bld_attach_list(vj_tstk,,,invoice_totals)
				vj_attach_tot = %get_attach_tot(vj_tstk, true, whgine_passed, invoice_totals)
			end
			call initialise_vj_from_vm

			ifkeys.fkey[D_FK_NO3].disabled_flg = false
			ifkeys.fkey[D_FK_NO4].disabled_flg = false
			ifkeys.fkey[D_FK_NO5].disabled_flg =
			&   .not. cms_calc_wg_pric

			ifkeys.fkey[D_FK_NO6].disabled_flg = true
			if(pass_gen_data.h_ivcr.eq.D_VIIVCR_INVOICE.and.
			&	pass_gen_data.pm_create_cont_ivt)
			begin
				xcall whgine_validate_pm_entry_ok(whgine_vj)
				ifkeys.fkey[D_FK_NO6].disabled_flg = false
			end

			xcall ibc_fkeys(a_inpwndid, ifkeys)
			xcall ibc_enable(D_SET, a_inpwndid, 'wgd_inpset1')
			xcall whgine_enable_rrp(cms_currency,pass_chn_data.h_prog_code, a_inpwndid)
			if (! whgine_vj.vj_wg_attach)
				xcall whgine_enable_disc(cms_currency,pass_chn_data.h_prog_code, a_inpwndid)
			; WG7447 Initially, we were going to disable and perhaps remove the mot date
			; if the item is not a vehicle. However, as the field is on the serial screen
			; anyway and there is no disabling the field there, it was agreed that we
			; would not do it here either.
			; WG7447	    if(vmtype) then
			; WG7447              xcall ibc_enable(a_inpwndid, 'vj_vmmotd')
			; WG7447	    else
			; WG7447              xcall ibc_disable(a_inpwndid, 'vj_vmmotd')
			if(.not.vj_vmmotd)
				xcall whgine_set_dflt_vmmotd(a_inpwndid, whgine_vj)
			if .not. vj_attach_num
				xcall ibc_disable(a_inpwndid, 'vj_hide_att')
			xcall i_next(a_inpwndid, 'wgd_inpset1', 'vj_code')

			if false
			begin
				vj_tstk_error,
				ret_val = D_ERROR
			end
		end
		'J_TRACK':
		begin
			xcall e_enter
			clear dummy_id
			xcall trk_mnt(gold_com, gold_ax, dummy_id, a_fkeys[W_TRK_FKEY],
			&          D_TRK_WGDS, vj_tstk)
			xcall e_exit
		end

		'J_SPC_WGD':
		if vj_wg_attach then
		begin
			;               xcall ibc_message('This option is only available for main '
			;               &                   +'{WHOLEGD} items')
			xcall whgine_nstk_spec(gold_com, gold_ax, whgine_vj,,,
			&                      pass_gen_data.adv_mode .eq. D_VEW_MODE)
		end
		else
		begin

			xcall whgine_spec(gold_com, gold_ax, vj_tstk, vj_vm_exists .eqs. 'H',,,
			&             pass_gen_data.adv_mode .eq. D_VEW_MODE, vj_vm_exists .eqs. ' ')
		end
		"J_CHG_DISC":           ; MULTIPLE DISCOUNTS
		begin
			if(vj_code) then
				xcall whgine_multiple_discount_entry(whgine_vj, gold_com, gold_ax,
				&         whgine_passed, a_inpwndid, whgine_hdr, invoice_totals)
			else
				xcall ibc_message('Invalid - Model Code must be entered first')
		end

		"J_CALCSALE":
		begin
			if vj_wg_attach then
				xcall wg_sales_prices(true, vdrec)
			else
			begin
				if vj_vm_exists then
				begin
					if(vj_vm_exists .eq. 'S') then
						xcall file(pass_chn_data.chn(VM_FILE),vmrec,,'RD',err,,,, vj_vm_rfa)
					else
						xcall file(pass_chn_data.chn(HM_FILE),vmrec,,'RD',err,,,, vj_vm_rfa)
				end
				else
					clear vmrec
				xcall wg_sales_prices(false, vmrec)
			end
		end
		'J_SER_AMD':
		begin
			if vj_wg_attach then
				xcall ibc_message('This option is only available for main '
				&                 +'{WHOLEGD} items')
			else
			begin
				xcall serial_no_screen(whgine_passed, vj_tstk, vj_vm_exists, vj_vm_rfa,
				&       vj_ser, vj_reg, vj_reg_date, vj_clok ,,vj_vmmotd )
				xcall i_display(a_inpwndid, 'wgd_fullset', whgine_vj,
				&                   'vj_ser,vj_reg,vj_reg_date,vj_clok,vj_vmmotd',,,,,,,,,
				&                    gold_com)
			end
		end
		'J_NOMS': begin
			if(wg_security .ne. ACC_NO_COST_DISP) then
			begin
				if(whgine_passed.f_acc_wg_exclude.eq.2) exit
				
                if(vj_moded)
				begin
					xcall ibc_message("To amend bonuses, first save changes to the advice using Save & Continue")
				end
				else
				begin
					xcall view_bonuses(whgine_vj, whgine_passed, whgine_lst, whgine_hdr, whgine_inv_tab, a_fkeys, invoice_totals, vjrec, add_part_passed, gold_com, gold_ax)
				end
			end
			else
				xcall ibc_message('unavailable')
		end
		'J_PDIREF':
		begin
			xcall file(pass_chn_data.chn(VM_FILE) , vmrec, vj_tstk, 'RD', err,,,,,D_NO_LOCK)
			if(err)
				xcall file(pass_chn_data.chn(HM_FILE) , vmrec, vj_tstk, 'RD', err,,,,,D_NO_LOCK)

			vgcode = vmgrp
			vg_adepot = vi_depot
			xcall file(pass_chn_data.chn(VGF_FILE),vgrec,vgkey,'RD',err)
			if(err) clear vgrec
			if(vgrec.vgf_wsj_wg.eq.D_WSJ_WG_ADV) then
				err = %pdi_refurb_create(vmstok,,true,
				&                                           whgine_passed.h_acc)     ; WG7652b
                         ;err = %pdi_refurb_create(vmstok,,true)     ; WG7652b
			else
				xcall wgd_pdi_dets_dsp(vmrec, gold_com, gold_ax)
		end
		'J_ENQ_WGD':
		if vj_wg_attach then
			xcall execute('whgenq',vj_astk)
		else
			xcall execute('whgenq',vj_tstk)
		'J_PM_CONT':
		begin
			if(vj_wg_attach) exit
			if(pass_gen_data.f_vg_pm_link)
			begin
				if(viivcr.eq.D_VIIVCR_INVOICE) then
					call pm_contract_entry
				else
					xcall ibc_message('Invalid - Planned Maintenance only available for invoices')
			end
			else
				xcall ibc_message('Invalid - The Planned Maintenance link on the {W} group file is not set')
		end
	endcase
	else
	begin
		xcall m_signal(a_entnam)    ; resignal back to tab proc
		ret_val = D_LIST_TERMINATED
	end

	freturn ret_val
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	pm_contract_entry,
	if(whgine_vj.wg_pm_contract.OR.pass_gen_data.adv_mode .eq. D_VEW_MODE) then
		pm_view=true
	else
		pm_view=false

	err=%whgine_pm_contract_entry(gold_com, gold_ax, whgine_vj, whgine_hdr,
	&	pm_view, whgine_passed)

	xcall whgine_set_pm_extra_text(whgine_vj.vj_inp_pm_group, whgine_vj.vj_extra_text)
	xcall i_dspfld(a_inpwndid,'vj_extra_text',whgine_vj.vj_extra_text, gold_com)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       set up the vj field for display
	initialise_vj_from_vm,
	f_attach=false
	if(vi_iorc.ne.D_VIIVCR_PART_CRED.and..not.
	&  (viivcr.eq.D_VIIVCR_PART_INV.and.vj_vm_exists.eq.'H'.and.
	&       vistat.lt.D_ADV_INVOICED))
	begin
		vkkey = vijob+vmstok
		if(vistat.ge.D_ADV_INVOICED) then
			xcall file(pass_chn_data.chn(VK_FILE),vdrec,vkkey,'RD',err)
		else
			xcall file(pass_chn_data.chn(VD_FILE),vdrec,vmstok,'RD',err,1,,,,D_NO_LOCK)
		if(.not.err) f_attach=TRUE
	end
	if(vm_bonuses) vj_nom_bonus=TRUE

	vjjob=vijob
	vjtstk=vmstok

	if(viivcr .ne. D_VIIVCR_PART_CRED.and..not.
	&       (viivcr .eq. D_VIIVCR_PART_INV.and.vj_vm_exists.eq.'H'))
	begin
		vj_f_disc = vm_f_disc
		vj_f_rrp = vm_rrp(D_FC)
		if(.not.vj_f_vi_rrp.and.vjnvat)
		begin
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjnstk.ne.D_VJ_PART) then
				vj_f_vi_rrp=vj_f_rrp
			else
				xcall whgine_vat_calc(vj_f_vi_rrp, vjnvat,
				&        vt_vat_code, vt_vrat, vj_f_rrp,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)
		end
		if(.not.vj_f_vi_disc.and.vjnvat)
		begin
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjnstk.ne.D_VJ_PART) then
				vj_f_vi_disc=vj_f_disc
			else
				xcall whgine_vat_calc(vj_f_vi_disc, vjnvat,
				&        vt_vat_code, vt_vrat, vj_f_disc,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)
		end
		vj_f_sett = vm_sett(D_FC)
		xcall WHGINE_Calc_Journal(lJournalVal, VMRec.vmstok)
		if(vm_fin_inv || vmcost > vm_est_cos[D_BC] + lJournalVal) then
			vjcost = %f_curr_fc(vmcost, pass_gen_data.vi_exch_rate)
		else
			vjcost = %f_curr_fc((vm_est_cos[D_BC] + lJournalVal), pass_gen_data.vi_exch_rate)
	end

	if(pass_chn_data.line_mode.eq.D_INS_MODE.or.
	&  (viivcr.ne.D_VIIVCR_PART_CRED.and.viivcr.ne.D_VIIVCR_PART_INV))
	begin
		vjngrp = vmgrp
		vjnmak = vmmak
		vjcode = vmcode
		vjnmod = vmmodl
		for loop from 1 thru 10
			vj_spec(loop) = vmspec(loop)
		vjnser = vmser
		vjnreg = vmreg
		vj_dreg = vmdreg
		vjnclk = vmclok
	end

	if(pass_chn_data.line_mode .eq. D_INS_MODE .or. .not. vjnvat)
	begin
		vjnvat = vmvat
		if(pass_chn_data.line_mode .eq. D_INS_MODE .and. cms_country .eq. EIRE_VAT)
			vjnvat = pass_gen_data.h_vat_code
	end
	;WG7476 - if non qual on non used czr and insert and 8 set to default
	if(pass_chn_data.line_mode.eq.D_INS_MODE.and.
	&	       (cms_country.eq.UK_VAT.or.cms_country.eq.EIRE_VAT).and.
	&           pass_chn_data.h_prog_code .ne. P_COD_CAR_SAL .and.vmnu.eq.'U'.and.
	&           vm_qualifying.eq.false.and.vmvat.eq.cms_used_car_vat)
	begin
		vjnvat = pass_gen_data.h_vat_code
	end
	if(.not.vjnvat)
	begin
		if(cms_country.eq.EIRE_VAT) then
			vjnvat=pass_gen_data.h_vat_code
		else
			vjnvat = cms_uk_def_vat
	end
	if(.not.vjnvat) vjnvat=1

	vjused = vmnu
	vjtype = vmtype
	vjsold = 1
	vj_qual = vm_qualifying

	; if we are inserting a main wholegood type, then try and read the standard
	; model file
	if(pass_chn_data.line_mode .eq. D_INS_MODE .and. vmnu .ne. 'U' .and.
	&               vjnstk .eq. D_VJ_WGD .and. .not. vm_warr_edat)
	begin
		if(.not.(%f_file(pass_chn_data.chn(VW_FILE), vwrec, vmcode, 'RD',,, D_NO_LOCK)))
		begin
			if(vw_warr_mth)
			begin
				vmwdat = viidat
				vm_warr_edat = viidat
				xcall add_months(vm_warr_edat, vw_warr_mth)
				xcall add_days(vm_warr_edat, -1)
			end
			if(vw_warr_end_clock.and..not.vm_warr_end_clock)
			begin
				vm_warr_end_clock = vw_warr_end_clock
			end
		end
	end

	if(f_wg_md_disc.and.pass_chn_data.line_mode .eq. D_INS_MODE)
	begin
		if(f_wg_md_disc.eq.D_CM5_WG_MD_YES_MODEL) then
		begin
			if(vmcode) then
			begin
				vwrec.vw_md_group=vj_md_group
				xcall wg_md_get_disc(vmcode, vwrec, pass_gen_data.vi_exch_rate, err)
				vj_md_group=vwrec.vw_md_group
			end
			else
				clear vj_md_group
		end
		else
		begin
			vj_md_group=vi_def_md_group
		end
	end
	vjtstk=vmstok
	call init_vj_input_from_vjrec
	clear vj_extra_text
	if(viivcr.eq.D_VIIVCR_PART_INV.and.vj_vm_exists.eq.'H'.and.
	&       (vistat.lt.D_ADV_INVOICED.or.
	&       (vistat.ge.D_ADV_INVOICED.and.vmivno.ne.viinvo))) then
		vj_extra_text='{W} MAIN INV '+vmivno
	else
	begin
		xcall whgine_set_pm_extra_text(vj_inp_pm_group, vj_extra_text)
	end
	xcall whgine_set_vj_curr_flds(whgine_vj, whgine_passed, invoice_totals)
	xcall i_display(a_inpwndid,, whgine_vj,,,,,,,,,, gold_com)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       initialises the vj input fields from the vjrec record.
	init_vj_input_from_vjrec,

	xcall whgine_init_vj_inp_from_vjrec(whgine_vj,whgine_passed, invoice_totals)
	return

.end
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	validates whether item already allocated and if so, invalidates
function WHGINE_Allocated, ^val
	.include 'vmrec' repository, req in group = 'aVMRec'
endparams

external function
	f_yes_no,	d
endexternal

global data section whgine_chn_data
record
	pass_chn_data,  whgine_pass_chn_data_str
endglobal

record lGeneral
.include 'vjrec' repository, group = 'lVjRec'
	lAllocated,	int
	group lVjKey2,		a
		lVjK2StkNo,		a8
		lVjK2Job,		a6
	endgroup
endrecord

proc
	init lGeneral
	if (aVMRec.vminvf)
	begin
		lAllocated = true
		if (! aVMRec.vmadno)
			xcall ibc_message('Invalid - {WHOLEGD} '+aVMRec.vmstok+' has already been '
			&	+'selected for Invoicing but the advice number has not yet been set.'
			&	+'  This may be because it is a new advice currently being entered OR because'
			&	+' advice entry ended unexpectedly before the advice number had been set.')
		else
		begin
			lVjK2StkNo = vmstok
			lVjK2Job = vmadno
			if (! %xf_file(pass_chn_data.chn[VJ_FILE], lVjRec, lVjKey2, 'RE', 2))
			begin
				xcall ibc_message('Invalid - {WHOLEGD} ' + aVMRec.vmstok+' has already been '
				&                   +'selected for Invoicing. See advice no ' + aVMRec.vmadno)
			end
			else
			begin
				if (%f_yes_no('Advice Number allocated but no matching Sales Invoice Item.\nClear advice number and continue ? ') == D_YES)
				begin
					clear aVMRec.vmadno
					lAllocated = false
				end
			end
		end
	end
	freturn lAllocated
endfunction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_init_vj_inp_from_vjrec
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	;;;;;;;;;;;;;;;;;;;;;;

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VMCOM.REC'


	external function
		f_curr_fc,      d
		f_curr_bc,      d

		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	record general
		lJournalVal,	i8
		tmp_pdi,        i8
		tmp_bonus,      i8
.proc
	init general
	call set_vj_inp_from_vjrec
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_vj_inp_from_vjrec,

	vj_tstk = vjtstk
	vj_code = vjcode
	vj_vat = %f_vat_get_code(vjnvat, pass_gen_data.h_vatable, cmf_def_vat, cmsrec, ivtrec)

	if(vjnstk .eq. D_VJ_WGD)
	begin
		vj_recv_date = vmrdat
		vj_fin_inv = vm_fin_inv
		vj_vmdeld = vmdeld
		vj_vm_extra_comm = vj_vm_extra_comm
		vj_warr_sdat = vmwdat
		vj_warr_edat = vm_warr_edat
		vj_warr_end_clock = vm_warr_end_clock
		vj_ex_warr_edat = vm_ex_warr_edat
		vj_ex_warr_end_clock = vm_ex_warr_end_clock

		if(viivcr .ne. D_VIIVCR_PART_CRED.and..not.
		&       (viivcr .eq. D_VIIVCR_PART_INV.and.vj_vm_exists.eq.'H'))
		begin
			xcall WHGINE_Calc_Journal(lJournalVal, VMRec.vmstok)
			; note - the use of c_journal simply as it is an available work variable
			; the call below will return estimated pdi unless actual is greater
			; or actual is complete
			xcall wgd_pdi_dets_dsp(vmrec,,, true,tmp_pdi,,true)

			tmp_pdi= %f_curr_fc(tmp_pdi, pass_gen_data.vi_exch_rate)

			xcall wg_bonus_calc(vmrec, tmp_bonus, pass_gen_data.vi_exch_rate)

			vjcost+=tmp_pdi
			vjcost-=tmp_bonus

			vj_bc_ecos = vm_est_cos(D_BC)
			vj_bc_ecos += lJournalVal

			vj_fc_ecos = %f_curr_fc(vj_bc_ecos, pass_gen_data.vi_exch_rate)

			vj_fc_ecos += tmp_pdi
			vj_fc_ecos -= tmp_bonus

			vj_bc_ecos = %f_curr_bc(vj_fc_ecos, pass_gen_data.vi_exch_rate)

			vj_fc_mrrp = vmmrrp
			if(pass_chn_data.h_prog_code.ne.P_COD_MACH_TRAD) then
				vj_d_fc_mrrp = vj_fc_mrrp
			else
				vj_d_fc_mrrp = vm_trd_price
			if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC)
				xcall whgine_vat_calc(vj_d_fc_mrrp, vj_vat,
				&        vt_vat_code, vt_vrat, vj_d_fc_mrrp,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)

		end
		vj_code = vmcode
		; IF NOT MOT DATE AND
		; IT IS A VEHICLE AND THERE IS A FIRST REGISTERED DATE THE SET
		; THE MOT EXPIRY DATE TO 3 YEARS FROM REG DATE
		if(pass_chn_data.line_mode .eq. D_INS_MODE .and. vmnu .ne. 'U' .and.
		&   vmtype .and. .not. vmmotd .and. vmdreg .and.
		&  (viivcr.ne.D_VIIVCR_PART_CRED.and.viivcr.ne.D_VIIVCR_PART_INV))
		begin
			vmmotd = vmdreg
			xcall add_months(vmmotd, 36)
		end
		vj_vmmotd=vmmotd
	end
	vj_type = vjtype
	vj_used = vjused .eq. 'U'

	vj_model = vjnmod
	vj_grp = vjngrp

	xcall whgine_get_group(vj_grp, vj_grpdes)

	vj_mak = vjnmak
	xcall whgine_get_make(vj_mak, vj_makdes)

	vj_ser = vjnser
	vj_reg = vjnreg
	vj_reg_date = vj_dreg
	vj_clok = vjnclk
	vj_hide_ln = vj_hide
	vj_hide_att = vj_hide_attach

	if(wg_security .ne. ACC_NO_COST_DISP)
	begin
		; do not show cost if this is restricted group
		if(whgine_passed.f_acc_wg_exclude.eq.1.and.%f_chk_vgf_restricted(,vj_grp, dt))
			whgine_passed.f_acc_wg_exclude=2
		if(whgine_passed.f_acc_wg_exclude.eq.2)
			clear vjcost, vj_fc_ecos
	end

	vj_fc_cost = vjcost
	if(pass_gen_data.vi_currency .ne. cms_base_cur)
		vj_bc_cost = %f_curr_bc(vj_fc_cost, pass_gen_data.vi_exch_rate)

	if vjnstk .eq. D_VJ_WGD.and.cms_gnvcos .eq. D_WG_AUTO_COST_ADJ .and. .not. vm_fin_inv then
		vj_dsp_cost = %max(vj_fc_ecos, vj_fc_cost)
	else
		vj_dsp_cost = vj_fc_cost

	set vj_f_orig_price, vj_fc_rrp = vj_f_rrp
	vj_fc_vi_rrp=vj_f_vi_rrp

	if(pass_gen_data.adv_mode .eq. D_INS_MODE .AND.              ; EN0506
	&          cms_user_id .EQ. 10469 .AND..NOT. vj_fc_rrp)              ; EN0506
		vj_fc_rrp = vmmrrp                                         ; EN0506

	vj_fc_disc = vj_f_disc
	vj_fc_vi_disc = vj_f_vi_disc
	if(.not.vj_fc_vi_disc.and.vj_fc_disc)
	begin
		if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.vjnstk.ne.D_VJ_PART) then
			vj_fc_vi_disc=vj_fc_disc
		else
			xcall whgine_vat_calc(vj_fc_vi_disc, vj_vat,
			&        vt_vat_code, vt_vrat, vj_fc_disc,
			&        D_RET_VAT_EXC, D_RET_VAT_INC)
	end
	vj_fc_sett = vj_f_sett

	if(pass_chn_data.h_prog_code .ne. P_COD_CAR_SAL .or. .not.vj_used) then
		vj_qualify = TRUE
	else
		vj_qualify = vj_qual

	vj_spec[]=vjnspc[]

	if(f_wg_md_disc)
		vj_inp_md_group=vj_md_group

	vj_disp_tstk=vj_tstk
	if(pass_gen_data.plan_maint) then
	begin
		vj_inp_pm_group=vj_wg_pm_group
		vj_disp_tstk=vj_wg_pm_group.wg_pm_equip_no
	end
	else
	begin
		if(pass_gen_data.pm_create_cont_ivt.and.vjnstk .eq. D_VJ_WGD)
			vj_inp_pm_group=vj_wg_pm_group
	end
	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_pm_extra_text
	.include 'wg_pm_group' repository, group='wg_pm_group'
	pass_extra_text,	a

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
.proc
	clear pass_extra_text
	if(pass_gen_data.h_ivcr.eq.D_VIIVCR_INVOICE.and.
	&	pass_gen_data.pm_create_cont_ivt.and.
	&   wg_pm_group.wg_pm_charge_code)
		xcall s_bld(pass_extra_text,,'PM:%a %a/%a',
		&	wg_pm_group.wg_pm_contract, wg_pm_group.wg_pm_model, wg_pm_group.wg_pm_charge_code)

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       multiple discounts

.subroutine whgine_multiple_discount_entry
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	pass_inpwndid,  n
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'invoice_totals' repository, group='invoice_totals'
	endparams

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	.include 'vwrec' repository, record='vwrec'

.proc

	if(vj_code)
	begin
		vwrec.vw_md_group=vj_inp_md_group
		xcall wg_md_disc(vwrec, vj_code, vj_fc_rrp, pass_gen_data.vi_exch_rate,
		&            gold_com, gold_ax,(pass_gen_data.adv_mode .eq. D_VEW_MODE),,f_wg_md_disc,
		&            'Multiple Discounts',pass_inpwndid,,
		&            vj_fc_disc, vj_fc_sett,,vi_def_md_group)
		vj_inp_md_group=vwrec.vw_md_group
		xcall whgine_vj_curr_vals(gold_com, whgine_vj, pass_inpwndid, whgine_passed, invoice_totals)
	end

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for wholegood
;
.function whgine_wgd_init, ^val

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:FCFREC.REC'

	external function
		f_format_money, a
		f_curr_fc,      d
		f_curr_bc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		.include 'vm_user' repository, group='vm_user'
		no_items,       d4

.proc
	unlock pass_chn_data.chn(HM_FILE)
	unlock pass_chn_data.chn(VM_FILE)
	clear gen
	xcall set_line_mode(a_mode)
	ifkeys.fkey[D_FK_NO7].disabled_flg =  .not. vj_nom_bonus
	ifkeys.fkey[D_FK_NO3].disabled_flg =  (vj_wg_attach)    ; SERIAL
; AP 08/06/10 - NOW ALLOW SPEC TO BE CHANGED FOR ATTACH
; AP 08/06/10 	ifkeys.fkey[D_FK_NO4].disabled_flg =  (vj_wg_attach)    ; SPEC
	if(pass_gen_data.pm_create_cont_ivt) then
	begin
		if(pass_gen_data.h_ivcr.eq.D_VIIVCR_CREDIT.or. vj_wg_attach.or.
		&	(vistat.ge.D_ADV_INVOICED.and..not.vj_inp_pm_group.wg_pm_contract)) then
			ifkeys.fkey[D_FK_NO6].disabled_flg=true
		else
			ifkeys.fkey[D_FK_NO6].disabled_flg=false
	end
	else
		ifkeys.fkey[D_FK_NO6].disabled_flg =  (vj_wg_attach)    ; MULTIPLE DISCOUNTS & PM CRT
	ifkeys.fkey[D_FK_NO8].disabled_flg =  (vj_wg_attach)

	if .not. vj_wg_attach then
	begin
		case a_mode of
		begincase
			D_LISTIAD_INS:
			begin
				clear vjrec
				; set plan maint link to false.  when the group record is
				; established, it is then set true if applicable
				pass_gen_data.f_vg_pm_link = false

				ifkeys.fkey[D_FK_NO3].disabled_flg = true
				; AP 08/06/10 - NOW ALLOW SPEC TO BE CHANGED FOR ATTACH
				; AP 08/06/10 		ifkeys.fkey[D_FK_NO4].disabled_flg = true
				ifkeys.fkey[D_FK_NO5].disabled_flg = true
				xcall i_init( a_inpwndid )
				xcall ibc_disable(D_SET, a_inpwndid, 'wgd_inpset1')
				xcall ibc_enable(a_inpwndid, 'VJ_TSTK')
				;		xcall i_force('?')
				vjnstk = D_VJ_WGD
				clear vj_vat
				vj_vat = %f_vat_get_code(vj_vat, pass_gen_data.h_vatable, cmf_def_vat, cmsrec, ivtrec)
				clear vj_hide, vj_hide_attach
				if new_tfr_no
				begin
					xcall i_force(new_tfr_no)
					clear new_tfr_no
					; WG7718 - CHANGE FOR DOE - SET DEFAULT HIDE TO NO RATHER THAN YES
					; WG7718                    vj_hide = true
					vj_hide = false     ; WG7718
					vj_hide_attach = false
					xcall i_display(a_inpwndid,, whgine_vj, 'VJ_HIDE_LN',
					&               'VJ_HIDE_ATT')
				end
			end
			D_LISTIAD_AMD:
			begin
				f_attach = vj_has_attach

				xcall ibc_enable(D_SET, a_inpwndid, 'wgd_inpset1')
				xcall ibc_disable(a_inpwndid, 'VJ_TSTK')
				; set plan maint link to false.  when the group record is
				; established, it is then set true if applicable
				if .not. vj_wg_attach
					xcall whgine_get_group(vj_grp)

				if .not. vj_wg_attach .and.
				&       viivcr.ne.D_VIIVCR_PART_CRED.and..not.
				&       (viivcr.eq.D_VIIVCR_PART_INV.and.
				&       vj_vm_exists.eq.'H'.and.
				&       vistat.lt.D_ADV_INVOICED) then
					vj_attach_tot = %get_attach_tot(vj_tstk, false, whgine_passed, invoice_totals)
				else
					clear vj_attach_tot
				xcall whgine_disp_vj_curr_vals(gold_com, whgine_vj, a_inpwndid,
				&                              whgine_passed, invoice_totals)
				xcall i_display(a_inpwndid, 'wgd_fullset', whgine_vj,,,,,,,,,,
				&               gold_com, gold_ax)
				if .not. vj_code
					xcall i_init(a_inpwndid, 'wgd_inpset1', whgine_vj, 'vj_code')
			end
		endcase
		xcall whgine_enable_rrp(cms_currency,pass_chn_data.h_prog_code, pass_gen_data.inp_vj_id)
		; WG7447 Initially, we were going to disable and perhaps remove the mot date
		; if the item is not a vehicle. However, as the field is on the serial screen
		; anyway and there is no disabling the field there, it was agreed that we
		; would not do it here either.
		; WG7447	    if(vmtype) then
		; WG7447              xcall ibc_enable(a_inpwndid, 'vj_vmmotd')
		; WG7447	    else
		; WG7447              xcall ibc_disable(a_inpwndid, 'vj_vmmotd')
		if .not. vj_wg_attach
		begin
			xcall whgine_enable_disc(cms_currency,pass_chn_data.h_prog_code, a_inpwndid)
			xcall i_user( a_inpwndid, 'vj_tstk',vm_user )
			if vm_user.vm_user_mh
				vm_user.vm_user_mh = %mem_proc(DM_FREE, vm_user.vm_user_mh)
			clear vm_user, ^i(vm_user.vm_user_mh)
			;;????>>>>> PROBLEM THAT WITH THE INTRODUCTION OF A NEW INVOICE
;; TRANSACTION TYPE OF PARTIAL INVOICE - WE CAN HAVE ITEMS THAT ARE NOT
; SOLD (NEED THESE FOR TRANSFERRING NEW ATTACHMENTS TO) BUT AT THE SAME
; TIME, WHOLEGOODS HAVE PREVIOUSLY BEEN SOLD.  THEREFORE, NEED TO EXTEND
; THE CRITERIA TO ALLOW ENTRY OF HISTORY FOR THE FIRST ITEM AND THEREAFTER
; NOT SOLD
			vm_user.chk_cust =
			case vi_iorc of
			begincase
				D_VIIVCR_INVOICE:   vm_user.chk_option = D_NOT_SOLD
				D_VIIVCR_CREDIT:    begin
					vm_user.chk_option = D_ON_HIST
					vm_user.chk_cust = vi_cust
				end
				D_VIIVCR_PART_CRED: begin
					vm_user.chk_option = D_ON_HIST
					vm_user.chk_cust = vi_cust
				end
				D_VIIVCR_PART_INV:  begin
					xcall l_status(wgd_lst_id, D_LLASTITM, no_items)
					if no_items.gt.1 then
					begin
						vm_user.chk_option = D_NOT_SOLD
					end
					else
					begin
						vm_user.chk_cust = vi_cust
						vm_user.chk_option = D_ON_HIST
					end
				end
			endcase
			xcall i_user( a_inpwndid, 'vj_tstk',,vm_user )
		end
		call format_vj
		f_hide_attach = vj_hide_att
		xcall evaluate_vj_hide_attach(whgine_vj, whgine_passed)
	end
	else
	begin

		if(wg_security .ne. ACC_NO_COST_DISP)
		begin
			if(pass_gen_data.vi_currency.ne.cms_base_cur)
			begin
				set vj_atd_rrp_bcur = base_desc
				set vj_atd_cost_curr, vj_atd_ecos_curr = curr_desc
			end
		end
		if(pass_gen_data.vi_currency .ne. cms_base_cur)
			vj_atd_rrp_curr = curr_desc

		vj_atd_t_ecost = vj_fc_ecos * vj_atd_ord_qty
		vj_atd_t_cost = vj_fc_cost * vj_atd_ord_qty

		if(.not.vj_fc_vi_rrp)
		begin
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL) then
				vj_fc_vi_rrp=vj_fc_rrp
			else
				xcall whgine_vat_calc(vj_fc_vi_rrp, vj_vat,
				&        vt_vat_code, vt_vrat, vj_fc_rrp,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)
		end

		if(pass_chn_data.h_prog_code .eq. P_COD_WGD_VAT_INC) then
		begin
			xcall whgine_vat_calc(vj_fc_rrp, vj_vat,
			&        vt_vat_code, vt_vrat, vj_fc_vi_rrp,
			&        D_RET_VAT_INC, D_RET_VAT_EXC)
		end
		else
		begin
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL) then
				vj_fc_vi_rrp=vj_fc_rrp
			else
				xcall whgine_vat_calc(vj_fc_vi_rrp, vj_vat,
				&        vt_vat_code, vt_vrat, vj_fc_rrp,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)
		end

		vj_bc_rrp = %f_curr_bc(vj_fc_rrp, pass_gen_data.vi_exch_rate)
		vj_bc_vi_rrp = %f_curr_bc(vj_fc_vi_rrp, pass_gen_data.vi_exch_rate)

		vj_atd_t_rrp = vj_fc_rrp * vj_atd_ord_qty
		vj_atd_t_brrp = vj_bc_rrp * vj_atd_ord_qty
		vj_atd_t_vi_rrp = vj_fc_vi_rrp * vj_atd_ord_qty
		vj_atd_t_vi_brrp = vj_bc_vi_rrp * vj_atd_ord_qty

		xcall whgine_enable_rrp(cms_currency,pass_chn_data.h_prog_code, pass_gen_data.inp_atd_id)

		xcall i_display(pass_gen_data.inp_atd_id, 'wgd_fullset', whgine_vj,,,,,,,,,,
		&                 gold_com )
		xcall i_frames(pass_gen_data.inp_atd_id, 'wgd_fullset')


		ifkeys.fkey[ D_FK_NO5].disabled_flg =
		&   .not. (cms_calc_wg_pric)
	end
	xcall ibc_fkeys(a_inpwndid, ifkeys)
	xcall i_next(a_inpwndid, 'wgd_inpset1', '*FRST*')
	freturn D_NO_ERROR

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       loads the vehine_vj input window after opening environment
        ;       Also, formats money fields
	format_vj,
	; if costs allowed to be amended then enable
	xcall ibc_disable(a_inpwndid,'vj_bc_cost')
	xcall ibc_disable(a_inpwndid,'vj_fc_cost')

	; EURO TRAILERS SPECIAL (10204) CHANGE PROMPTS
	if(cms_user_id.eq.10204)
	begin
		xcall i_prompt(a_inpwndid,'vj_ser','Chassis No.')
		xcall i_prompt(a_inpwndid,'vj_reg','Ministry')
	end
	call draw_vj_lines
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       draws lines for multicurrency transaction
	draw_vj_lines,
	if(.not.cms_currency.or.pass_gen_data.vi_currency.eq.cms_base_cur) return
	if(.not.vj_line1_id)
	begin
		xcall w_proc(WP_CREATE, vj_line1_id, 'window_vj1',1, 20)
		xcall w_proc(WP_CREATE, vj_line2_id, 'window_vj2',8, 1)
	end
	xcall SetParent(a_inpwndid, vj_line1_id)
	xcall SetParent(a_inpwndid, vj_line2_id)

	xcall w_proc(WP_PLACE, vj_line1_id,  4, 59)
	xcall w_proc(WP_PLACE, vj_line2_id,  5, 65)

	xcall w_disp(vj_line1_id, WD_VLINE, 1,7,1, WD_HLINE, 1,1,16 )
	xcall w_disp(vj_line1_id, WD_POS, 1, 2, WD_FIELD, base_desc )
	xcall w_disp(vj_line1_id, WD_POS, 1, 16, WD_FIELD, curr_desc)
	xcall w_disp(vj_line2_id, WD_VLINE, 1,7,8)
	xcall w_brdr(vj_line1_id,WB_OFF)
	xcall w_brdr(vj_line2_id,WB_OFF)
	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : for wgd item and non stocked entry, enable / disable the rrp fields
; depending on program code ie. if vat inclusive, disable rrp but enable
; vat inclusive price or if vat inclusive visa versa
.subroutine whgine_enable_rrp
	currency_in_use,n
	pass_prog_code, n
	inp_wnd_id,     n
.proc
	if(pass_prog_code.eq.P_COD_WGD_VAT_INC) then
	begin
		if(currency_in_use)
		begin
			xcall ibc_disable(inp_wnd_id,'vj_bc_rrp')
			xcall ibc_enable(inp_wnd_id,'vj_bc_vi_rrp')
		end
		xcall ibc_disable(inp_wnd_id,'vj_fc_rrp')
		xcall ibc_enable(inp_wnd_id,'vj_fc_vi_rrp')
	end
	else
	begin
		if(currency_in_use)
		begin
			xcall ibc_disable(inp_wnd_id,'vj_bc_vi_rrp')
			xcall ibc_enable(inp_wnd_id,'vj_bc_rrp')
		end
		xcall ibc_disable(inp_wnd_id,'vj_fc_vi_rrp')
		xcall ibc_enable(inp_wnd_id,'vj_fc_rrp')
	end
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : for wgd item and non stocked entry, enable / disable the disc fields
; depending on program code ie. if vat inclusive, disable disc but enable
; vat inclusive price or if vat inclusive visa versa
.subroutine whgine_enable_disc
	currency_in_use,n
	pass_prog_code, n
	inp_wnd_id,     n
.proc
	if(pass_prog_code.eq.P_COD_WGD_VAT_INC) then
	begin
		if(currency_in_use)
		begin
			xcall ibc_disable(inp_wnd_id,'vj_bc_disc')
			xcall ibc_enable(inp_wnd_id,'vj_bc_vi_disc')
		end
		xcall ibc_disable(inp_wnd_id,'vj_fc_disc')
		xcall ibc_enable(inp_wnd_id,'vj_fc_vi_disc')
	end
	else
	begin
		if(currency_in_use)
		begin
			xcall ibc_disable(inp_wnd_id,'vj_bc_vi_disc')
			xcall ibc_enable(inp_wnd_id,'vj_bc_disc')
		end
		xcall ibc_disable(inp_wnd_id,'vj_fc_vi_disc')
		xcall ibc_enable(inp_wnd_id,'vj_fc_disc')
	end
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for parts
;
function whgine_wgd_upd, ^val

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:IVTCOM.REC'

	external function
		f_curr_fc,      d
		f_curr_bc,      d
		f_yes_no,		d
	endexternal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		at_bottom,      d1
		err,            d3
		key_ref,        d1
		stkno,          a8
		loop,           d2
		rtn_err,        d3
		first_attch,    d1
		tmp_rate,		d4
		a_vm_exists,	d1
		hld_transfer_advice,	a6
		hld_transfer_cust,		a6
	endrecord

	record ifours
		req,            i4
		linp_id,        i4
		wlinp_id,       i4
		gen_channel,    i4

proc

	if(%whgine_check_crlim(a_mode, whgine_vj, whgine_lst, whgine_passed,
	&  whgine_inv_tab,add_part_passed))
		freturn D_CLEAR_ENTRY

	req = D_LRESTORE
	xcall l_process( seq_lst_id, req , whgine_lst,, gold_com,
	&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

	rtn_err = D_NO_ERROR
	xcall l_status(seq_lst_id, D_LINPID, linp_id)
	xcall l_status(wgd_lst_id, D_LINPID, wlinp_id)

	if (a_mode != D_LISTIAD_DEL)
	begin
		rtn_err = %WHGINE_Sett_Valid(vj_fc_sett, (vj_fc_rrp - vj_fc_disc))
		if (rtn_err)
		begin
			xcall i_next(a_inpwndid, '*CURR*', 'VJ_FC_RRP')
			freturn D_REINPUT_ENTRY
		end
	end

	case a_mode of
	begincase
		D_LISTIAD_INS:
		begin
			if(f_wg_md_disc)
			begin
				xcall whgine_multiple_discount_entry(whgine_vj, gold_com, gold_ax,
				&               whgine_passed, a_inpwndid, whgine_hdr, invoice_totals)
			end

			xcall whgine_check_vj_marg(whgine_vj)

			if .not. seq_inserting then
				xcall pos_b4_trade(gold_com, gold_ax, a_fkeys, whgine_passed,
				&                  whgine_lst, invoice_totals)
			else
				reseq_req[D_VJ_WGD+1] = true
			xcall l_process( seq_lst_id, req = D_LAPPEND, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			clear whgine_lst

			vminvf = true
			if (virec.vijob)
				vmadno = virec.vijob
			if(vj_vm_exists == 'S')
				xcall file(pass_chn_data.chn(VM_FILE), vmrec, , 'WR', err, , , , vj_vm_rfa)
			else
				xcall file(pass_chn_data.chn(HM_FILE), vmrec, , 'WR', err, , , , vj_vm_rfa)

			call set_line_discount
			first_attch = true
			list_type=T$MAIN_WG
			lst_ntype = D_VJ_WGD
			set lst_tstk, lst_stkno = vj_tstk
			lst_disp_stkno=lst_stkno
			lst_code = vj_code
			set vj_atd_ord_qty = 1
			set lst_qty = 1.000

			xcall WHGINE_Set_VM_Costs(whgine_lst, vmrec)

			xcall whgine_get_cost(vj_dsp_cost , whgine_vj, whgine_passed)
			lst_dsp_cost = %f_curr_bc(vj_dsp_cost, pass_gen_data.vi_exch_rate)
			lst_cost = vj_fc_cost
			lst_sett = vj_fc_sett
			lst_retail = vj_fc_rrp
			lst_vi_retail = vj_fc_vi_rrp
			if(.not. vj_bc_ecos) then
				lst_pur_cost=lst_dsp_cost
			else
				lst_pur_cost=vj_bc_ecos
			lst_orig_price = vj_fc_rrp
			lst_rrp = vj_fc_mrrp
			lst_trd_price = vj_fc_trd_price
			lst_vm_exists = vj_vm_exists
			lst_vm_rfa = vj_vm_rfa
			set vj_prev_batch, lst_prev_batch = false
			lst_vat=vj_vat
			lst_used = vj_used
			lst_type = vj_type
			lst_code = vj_code
			lst_model = vj_model
			lst_grp = vj_grp
			lst_mak = vj_mak
			for loop from 1 thru 10
				lst_spec(loop) = vj_spec(loop)
			lst_ser = vj_ser
			lst_reg = vj_reg
			lst_reg_dat = vj_reg_date
			lst_clok = vj_clok
			lst_hide_att = vj_hide_att
			lst_hide = vj_hide_ln

			lst_warr_sdat = vj_warr_sdat
			lst_warr_edat = vj_warr_edat
			lst_warr_end_clock = vj_warr_end_clock
			lst_ex_warr_edat = vj_ex_warr_edat
			lst_ex_warr_end_clock = vj_ex_warr_end_clock
			lst_vj_vmdeld = vj_vmdeld
			lst_vj_vm_extra_comm = vj_vm_extra_comm
			lst_fin_inv = vj_fin_inv
			lst_recv_dat = vj_recv_date
			lst_bonus = vj_nom_bonus
			lst_attach_num = vj_attach_num
			lst_trd_cmnt = false
			set lst_ucar = false
			; WG7433            if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.lst_used.and.lst_type
			; WG7433&               .and.vj_qual.eq.false)
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.lst_used
			&               .and.vj_qual.eq.false)
			begin
				lst_ucar=TRUE
			end
			lst_qual=vj_qual
			lst_wg_md_group=vj_inp_md_group
			if(pass_gen_data.pm_create_cont_ivt)
			begin
				whgine_lst.lst_wg_pm_group=whgine_vj.vj_inp_pm_group
			end

			set lst_moded, vj_moded = true
			stkno = vj_tstk
			if(viivcr.ne.D_VIIVCR_PART_CRED.and..not.
			&  (viivcr.eq.D_VIIVCR_PART_INV.and.
			&   lst_vm_exists.eq.'H'.and.
			&   vistat.lt.D_ADV_INVOICED))
			begin
				if(vistat.ge.D_ADV_INVOICED) then
				begin
					vkkey = vijob + vj_astk
					xcall file(pass_chn_data.chn(VK_FILE),vdrec,vkkey,'FI',err)
					gen_channel = pass_chn_data.chn(VK_FILE)
					key_ref = 0
				end
				else
				begin
					xcall file(pass_chn_data.chn(VD_FILE),vdrec,vj_tstk,'FI',err,1)
					gen_channel = pass_chn_data.chn(VD_FILE)
					key_ref = 1
				end
				repeat
				begin
					xcall file(gen_channel,vdrec, vj_tstk,'RS', err,
					&                key_ref,,,, D_NO_LOCK)
					if err .or. vdstok .ne. stkno
					begin
						if first_attch
						begin ; postpone writing main wg until we know if there's attchs
							xcall i_display(wlinp_id,, whgine_vj,,,,,,,,,, gold_com, gold_ax)
							req = D_LNOP
							xcall l_process(wgd_lst_id, req, whgine_vj,,
							&                   gold_com, gold_ax, fkeys, whgine_passed,
							&                   fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
							&                   add_part_passed, invoice_totals)
							first_attch = false
						end
						exitloop
					end
					if first_attch
					begin
						vj_has_attach = true
						xcall i_display(wlinp_id,, whgine_vj,,,,,,,,,, gold_com, gold_ax)
						req = D_LNOP
						xcall l_process(wgd_lst_id, req, whgine_vj,,
						&               gold_com, gold_ax, fkeys, whgine_passed,
						&               fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
						&               add_part_passed, invoice_totals)
						first_attch     = false
					end
					if .not. attach_ll
						xcall ll_open(attach_ll, ^size(vdrec))
					xcall whgine_attach_cur_val(vdrec, lst_code, vi_sell_cur, invoice_totals)
					req = D_LAPPEND
					xcall ll_process(attach_ll, D_LL_APPEND, vdrec)
					xcall l_process(wgd_lst_id, req, whgine_vj,,
					&                   gold_com, gold_ax, fkeys, whgine_passed,
					&                   fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
					&                   add_part_passed, invoice_totals)

					vj_wg_attach = true
					vj_has_attach = f_attach
					vjjob = vijob
					vj_tstk = vdastk
					vj_disp_tstk=vj_tstk
					vj_astk = vjtstk
					vj_code = vdcode
					vj_fc_ecos = %f_curr_fc(vd_est_cos(D_BC),pass_gen_data.vi_exch_rate)
					vj_fc_cost = %f_curr_fc(vd_cost(D_BC),pass_gen_data.vi_exch_rate)
					vj_fc_rrp = vd_rrp(D_FC)
					vj_fc_vi_rrp = vd_vi_rrp(D_FC)

					if cms_gnvcos .eq. D_WG_AUTO_COST_ADJ .and. .not. vd_fin_inv then
						vj_dsp_cost = %max(vj_fc_ecos, vj_fc_cost)
					else
						vj_dsp_cost = vj_fc_cost

					vj_grp = vd_gcod
					xcall whgine_get_group(vj_grp, vj_grpdes)
					vj_mak = vd_make
					xcall whgine_get_make(vj_mak, vj_makdes)
					vj_model = vd_model
					vj_ser = vdser
					vj_vat = vdvat
					if(.not.vj_vat)
					begin
						if(cms_country.eq.EIRE_VAT) then
							vj_vat=pass_gen_data.h_vat_code
						else
							vj_vat = cms_uk_def_vat
					end
					xcall f_vat_rate(vj_vat, tmp_rate, true)
					if(tmp_rate.and..not.pass_gen_data.h_vatable)
					begin
						if(cms_country.eq.EIRE_VAT) then
							vj_vat=ivt_vat_zero
						else
							vj_vat=cms_uk_zero_vat
					end
					vj_atd_ord_qty = vdqty
					vj_prev_batch = false
					vj_moded = true
					vj_vm_exists = lst_vm_exists
					vj_hide_att = f_hide_attach

					for loop from 1 thru 10
						vj_spec(loop) = vdmodl(loop)

					xcall i_display(wlinp_id,, whgine_vj,,,,,,,,,, gold_com, gold_ax)
					req = D_LNOP
					xcall l_process(wgd_lst_id, req, whgine_vj,,
					&                   gold_com, gold_ax, fkeys, whgine_passed,
					&                   fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
					&                   add_part_passed, invoice_totals)

				end
			end
			xcall reset_attch_vals(whgine_lst)
			xcall set_qty_dp(linp_id, lst_qty_dp)
			xcall i_display(linp_id,, whgine_lst)
			xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
		end
		D_LISTIAD_AMD:
		begin
			xcall whgine_check_vj_marg(whgine_vj)
			clear at_bottom
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			if vj_wg_attach then
				stkno = vj_astk
			else
				stkno = vj_tstk
			repeat
			begin
				if lst_ntype .eq. D_VJ_WGD .and. lst_stkno .eq. stkno
				begin
					if .not. vj_wg_attach then
					begin
						lst_code = vj_code

						xcall WHGINE_Set_VM_Costs(whgine_lst, vmrec)

						xcall whgine_get_cost(lst_dsp_cost, whgine_vj, whgine_passed)
						lst_dsp_cost = %f_curr_bc(lst_dsp_cost, pass_gen_data.vi_exch_rate)

						call set_line_discount
						lst_sett = vj_fc_sett
						lst_rrp = vj_fc_mrrp
						lst_trd_price = vj_fc_trd_price
						lst_retail = vj_fc_rrp
						lst_vi_retail = vj_fc_vi_rrp
						lst_vat=vj_vat
						lst_used = vj_used
						lst_type = vj_type
						lst_code = vj_code
						lst_model = vj_model
						lst_grp = vj_grp
						lst_mak = vj_mak
						for loop from 1 thru 10
							lst_spec(loop) = vj_spec(loop)
						lst_ser = vj_ser
						lst_reg = vj_reg
						lst_reg_dat = vj_reg_date
						lst_clok = vj_clok
						lst_hide_att = vj_hide_att
						lst_hide = vj_hide_ln

						lst_warr_sdat = vj_warr_sdat
						lst_warr_edat = vj_warr_edat
						lst_warr_end_clock = vj_warr_end_clock
						lst_ex_warr_edat = vj_ex_warr_edat
						lst_ex_warr_end_clock = vj_ex_warr_end_clock
						lst_vj_vmdeld = vj_vmdeld
						lst_vj_vm_extra_comm = vj_vm_extra_comm
						lst_fin_inv = vj_fin_inv
						lst_recv_dat = vj_recv_date
						if f_history then
							lst_vm_exists = 'H'
						else
							lst_vm_exists = 'S'
						lst_moded = true
						lst_wg_md_group=vj_inp_md_group
						if(pass_gen_data.pm_create_cont_ivt)
						begin
							whgine_lst.lst_wg_pm_group=whgine_vj.vj_inp_pm_group
						end
					end
					else
					begin
						lst_moded = true
						xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
						while .not. err
						begin
							if vj_tstk .eq. vdastk
							begin
								vd_rrp(D_FC) = vj_fc_rrp
								vd_vi_rrp(D_FC) = vj_fc_vi_rrp
								vd_hide = vj_hide_att
								vd_model = vj_model
								vdmodl[]=vj_spec[]
								vdvat=vj_vat
								xcall ll_process(attach_ll,D_LL_WRITE,vdrec,err)
								exitloop
							end
							xcall ll_process(attach_ll,D_LL_NEXT,vdrec,err)
						end
					end
					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
			xcall reset_attch_vals(whgine_lst)
			xcall i_display(linp_id,, whgine_lst)
			xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,,
			&            gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
			&            whgine_passed, invoice_totals)
		end
		D_LISTIAD_DEL:
		begin
			gen_channel = pass_chn_data.chn(VM_FILE)
			xcall file(gen_channel, vmrec, vj_tstk, 'RE', err)
			if(err)
			begin
				gen_channel = pass_chn_data.chn(HM_FILE)
				xcall file(gen_channel, vmrec, vj_tstk, 'RE', err)
				if (err)
					clear vmrec
			end
			if (! err && ! vi_iorc && vmrec.vminvf)
			begin
				; if wholegood is deleted from advice of internal customer (non-VAT), reset the VAT Code
				if (vmvat == 9 && (!(vmrec.vmcust > ' 1000' || %non_numeric(vmrec.vmcust))))
				begin
				    vmvat = 1
				    xcall ibc_message('Wholegood VAT Code changed to 1, please check and'
				    &                   +' amend if necessary')
				end
			      
			      	clear vmrec.vminvf, vmrec.vmadno, vmrec.vmcust
				err = %xf_file(gen_channel ,vmrec, , 'WR', err)
			end

			clear at_bottom
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			repeat
			begin
				if lst_ntype .eq. D_VJ_WGD .and. lst_stkno .eq. vj_tstk
				begin
					err=%whgine_check_pdi_jobs(gold_com, vj_tstk)
					if vj_prev_batch
						xcall ll_process( pass_chn_data.lst_cntrl, D_LL_INSERT, whgine_lst, err )
					if vj_has_attach
					begin
						xcall ll_close(attach_ll)
						req = D_LDELITEM        ; delete main wg
						xcall l_process(wgd_lst_id, req, whgine_vj,,
						&                   gold_com, gold_ax, fkeys, whgine_passed,
						&                   fkeys_grp, whgine_lst, whgine_inv_tab,
						&                   whgine_hdr, add_part_passed, invoice_totals)
						xcall l_status(wgd_lst_id, D_LATBOTTOM, at_bottom)
						while vj_wg_attach
						begin
							req = D_LDELITEM    ; delete attachment
							xcall l_process(wgd_lst_id, req, whgine_vj,,
							&               gold_com, gold_ax, fkeys, whgine_passed,
							&               fkeys_grp, whgine_lst, whgine_inv_tab,
							&               whgine_hdr, add_part_passed, invoice_totals)
							if at_bottom
								exitloop
							xcall l_status(wgd_lst_id, D_LATBOTTOM, at_bottom)
						end
						rtn_err = D_USER_ABORT          ; prevent listiad_proc from deleting
					end

					; Molsom special - retain advice in case we're transferring
					hld_transfer_advice = vmadno
					hld_transfer_cust = vmcust

					xcall l_process( seq_lst_id, req = D_LDELITEM, whgine_lst,,
					&                gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
					&                whgine_passed, invoice_totals)
					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
	endcase
	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab, add_part_passed, invoice_totals)
	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab)
	set vj_moded, items_moded = true
	; IF PARTIAL INVOICE - DO NOT ROLL INPUT - USER CAN ONLY HAVE 1 WGD ITEM
	if(a_mode.eq.D_LISTIAD_INS.and.pass_gen_data.h_ivcr.eq.D_VIIVCR_PART_INV)
		rtn_err = D_LIST_TERMINATED

	freturn rtn_err
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_line_discount,
	vj_dsp_disc=vj_fc_disc
	if(.not.vj_fc_vi_disc.and.vj_fc_disc)
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
			vj_fc_vi_disc=vj_fc_disc
		else
			xcall whgine_vat_calc(vj_fc_vi_disc, vj_vat,
			&        vt_vat_code, vt_vrat, vj_fc_disc,
			&        D_RET_VAT_EXC, D_RET_VAT_INC)
	end
	lst_disc = vj_fc_disc
	lst_vi_disc = vj_fc_vi_disc
	lst_dsp_disc = vj_dsp_disc
	return
endfunction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       function to check any pdi jobs in progress or completed for this
;       wholegood
;     change method for job field
.function whgine_check_pdi_jobs, ^val
	.include 'GOLD_COM' repository, group='gold_com'
	tmp_stok,               a
	pass_find_refurb,		n		; if passed and true want to find any flagged
								; with pdi refurb only,
	.include 'SRC:IHHREC.REC'
	.include 'SRC:IVHREC.REC'
	.include 'SRC:IVTREC.REC'
	.include 'SRC:VSREC.REC'

	.define WGD_TYP_SER,    0       ; {WHOLEGD} TYPES ONLY

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		group ivh_key,  a
			ivhk_typ_ser, d1      ; 0 for wholegoods
			ivhk_wgstk,   a8
		endgroup

	record ids
		err,            i4

.proc

	xcall e_enter

	clear gen, ^i(ids)

	xcall flash('Checking for pdi jobs...')

	call check_for_os_pdi_jobs

	if(^passed(pass_find_refurb).and.ivh_pdi_refurb.and.err.eq.99) then
		nop
	else
		call check_for_comp_pdi_jobs

	xcall e_exit

	freturn err

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	check_for_os_pdi_jobs,
	; first check o/s jobs
	clear ivhrec
	ivhk_typ_ser = 0
	ivhk_wgstk = tmp_stok
	xcall file(pass_chn_data.chn(IVH_FILE),ivhrec,ivh_key,'FI',err,3)
	repeat
	begin
		xcall file(pass_chn_data.chn(IVH_FILE),ivhrec,,'RS',err,,,,,Q_NO_LOCK)
		if(err.EQ. 1 .OR. ivh_wg_no .NE. tmp_stok.or.ivh_typ_ser) exitloop

		if(ivh_status .EQ. D_STATUS_PRINTED .OR.
		&                 ivh_status .EQ. D_STATUS_DELETED) nextloop

		if(^passed(pass_find_refurb).and.ivh_pdi_refurb)
		begin
			err=99	; found refurb
			return
		end


		xcall file(pass_chn_data.chn(IVT_FILE), ivtrec, ivh_inv_typ, 'RD', err,,,,, Q_NO_LOCK)
		if err clear ivtrec

		if ivt_prog_code .ne. P_COD_PDI nextloop

		xcall ibc_message('Warning - Outstanding PDI WSJ No '+ivh_job_no
		&               +' for {WHOLEGD} '+tmp_stok)
	end

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	check_for_comp_pdi_jobs,

	; set up primary key for first read
	clear vsstok
	vs_typ_ser = WGD_TYP_SER
	vsstk = tmp_stok
	vssdat = 99999999
	xcall file(pass_chn_data.chn(VS_FILE),vsrec,vsstok,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VS_FILE),vsrec,,'RS',err)
		if(err.eq.$ERR_EOF .OR. vsstk.NE.tmp_stok .or. vs_typ_ser.ne.WGD_TYP_SER )
			exitloop

		if(^passed(pass_find_refurb).and.vs_pdi_refurb)
		begin
			err=99	; found refurb
			return
		end

		xcall file(pass_chn_data.chn(IVT_FILE), ivtrec, vstype, 'RD', err,,,,, Q_NO_LOCK)
		if err clear ivtrec
		; ap20121025 - log no 622099 bourne tractors. The customer had changed the
		; program code assocated with invoice type 29 a number of time and this
		; caused problems with the display.  Rather than using the current setting of
		; program code, try and use ihh_prog_code which would have been setat the time of
		; raising the invoice.
		ihhk1_invno = vsivno
		ihhk1_invdate = vssdat
		if(.not.%xf_file(pass_chn_data.chn(IHH_FILE),ihhrec,ihh_key1,'RD',1).and.ihh_prog_code)
			ivt_prog_code=ihh_prog_code

		if ivt_prog_code .ne. P_COD_PDI nextloop

		xcall ibc_message('Warning - Completed PDI WSJ No '+vsjob
		&               +' Invoice no '+vsivno +' for {WHOLEGD} '+vsstk)
	end
	clear err
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for job field
.function whgine_job_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vi' repository, group = 'whgine_vi'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,                a
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'

	external function
		f_yes_no,       d

	record gen
		err,            d3
		filename,       a14

	record ifours
		vi_chn,         i4

.proc
	if(.not. cms_gngvad.and.a_data_stored.eq.T$AUTO)
	begin
		xcall ibc_message('Invalid - Auto advice numbering is not in use')
		freturn D_EMITTEDERR
	end

	if a_pending_status .eq. D_OK
	begin
		clear gen, ^i(ifours)
		filename = vifile
		filename(7:3) = gold_com.cur_company, 'XXX'
		xcall u_fndfil(filename,, vi_chn)
		if vi_chn then
		begin
			xcall file(vi_chn, virec, a_data_stored, 'RD', err,,,,, D_NO_LOCK)
			if .not. err
			begin
				if %f_yes_no('Advice already exists - Amend? ',,,, D_YES, true) then
					xcall m_signal('J_CHG_AMD')
				else
					freturn D_EMITTEDERR
			end
		end
		else
		begin
			xcall ibc_message('Error opening VI file')
			freturn D_EMITTEDERR
		end
	end

	freturn a_pending_status
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for job field
.function whgine_jobamd_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vi' repository, group = 'whgine_vi'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,                a
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'

.proc
	if ((a_pending_status.ne.D_OK .and. a_pending_status.ne.D_REQERR) .or.
	&   g_select .and. (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&   g_entnam .eq. 'I_HYPER' .or. g_entnam .eq. 'J_INS' .or.
	&   g_entnam .eq. 'J_AMD' .or. g_entnam .eq. 'J_DEL' ||
	&   g_entnam == "J_NXT_ADV" || g_entnam == "J_PRV_ADV"))
		freturn a_pending_status

	a_pending_status = %wvi_change(a_data_entered, a_data_stored, a_pending_status,
	&           inputinfo, whgine_vi, gold_com)
	.ifdef D_GUI
		if (a_data_stored.and.a_pending_status.ne.D_EMITTEDERR)
			xcall m_signal('I_OK')
	.endc
	freturn a_pending_status
.end


.subroutine whgine_upd

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'whgine_vj' repository, group='whgine_nstk'
	.include 'add_part_str' repository, group='part_data'
	.include 'wgd_deladd' repository, group='aWgd_del_add'
	.include 'ivtrec' repository, group = 'aIVTrec'
endparams

	.include 'SRC:OPSCOM.REC'

.proc
	xcall whgine_upd_seq(gold_com, gold_ax, fkeys, whgine_passed,
	&                    whgine_lst, add_part_passed, whgine_hdr,
	&                    invoice_totals, whgine_inv_tab, whgine_vj,
	&                    whgine_vb, whgine_nstk, whgine_cmnt_lst,
	&                    part_data, aWgd_del_add, aIVTrec)
	xreturn
.end

.subroutine whgine_upd_seq

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'invoice_totals' repository, group = 'invoice_totals'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'whgine_vj' repository, group='whgine_nstk'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'wgd_deladd' repository, group='aWgd_del_add'
	.include 'ivtrec' repository, group = 'aIVTrec'
endparams

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VQREC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:PMFREC.REC'
	.include 'SRC:PDFREC.REC'
	.include 'SRC:PMVREC.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:HIDREC.REC'
	.include 'SRC:HPDREC.REC'
	.include 'SRC:PMLREC.REC'
	.include 'SRC:WQLREC.REC'
	.include 'SRC:PLDREC.REC'

	.include 'SRC:POS_PARTS.CMN'
	.include 'SRC:HORT.CMN'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	external function
		f_curr_bc,      d
		generate_adv_no,a
		f_get_dec,      a
		f_ljust,        a
	endexternal
	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4

	record gen
		.include 'vmrec' repository, group = 'old_vmrec', nofields
		err,            d3
		seq_no,         d4
		at_bottom,      d1
		loop,           d2
		old_qty,        d10
		tmp_qty,        d10.3
		new_rrp,        d10
		new_vi_rrp,     d10
		free,           d10.3
		sign,           d1
		lWqlRFA,		a6
		write_type,     a2
		new_hide_att,   d1
		new_model,	a20
		new_spec,	10a32
		new_vat,	d2
		tmp_trk_text,   a60
		lAtLeastOneWgd,	d1
		lAtLeastOneSB,	d1
		lPrevVM,		a8
		lNextVM,		a8
	endrecord
	record ifours
		req,            i4
		linp_id,        i4
		gen_channel,    i4
		lFileError ,	i4
	endrecord
.proc
	clear gen, ^i(ifours)
	; restore lists to current state
	req = D_LRESTORE
	xcall l_process(cmnt_lst_id, req, whgine_cmnt_lst,, gold_com, gold_ax,
	&               fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)

	req = D_LRESTORE
	xcall l_process(nstk_lst_id, req, whgine_nstk,, gold_com, gold_ax,
	&               fkeys[NSTK_FKEYS], whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
	&       whgine_hdr, add_part_passed, invoice_totals)

	if(vistat .ge. D_ADV_INVOICED)
		add_part_passed.edit_mode = D_VIEW_MODE
	req = D_LRESTORE
	xcall l_process(prt_lst_id, req, part_data,,gold_com, gold_ax,
	&              fkeys[PRTLST_FKEYS], add_part_passed, invoice_totals,
	&              pass_chn_data.chn, whgine_passed, fkeys, whgine_lst,
	&              whgine_inv_tab, whgine_hdr)

	req = D_LRESTORE
	xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
	&               fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
	&               whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)

	req = D_LRESTORE
	xcall l_process(wgd_lst_id, req, whgine_vj,, gold_com, gold_ax,
	&               fkeys[WGD_FKEYS], whgine_passed, fkeys, whgine_lst,
	&               whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)

	req = D_LBOTTOM
	xcall l_process(wgd_lst_id,req,whgine_vj,,gold_com,gold_ax,
	&               fkeys[WGD_FKEYS],whgine_passed,fkeys,whgine_lst,
	&               whgine_inv_tab,whgine_hdr,add_part_passed, invoice_totals)

	; update header rec
	if hdr_moded
	begin
		if pass_gen_data.adv_mode .eq. D_INS_MODE then
		begin
			clear virec
			if(vi_job.eq.T$AUTO.and.cms_gngvad)
			begin
				vjjob = %generate_adv_no(pass_gen_data.plan_maint)
				call update_inv_cmnt
				vi_job=vjjob
				xcall i_display(inp_vi_id, 'adv_set', whgine_hdr,,,,,,,,,,
				&                 gold_com, gold_ax)
			end
			call update_vi_fields

			xcall whgine_set_vi_ignore_ivacc(vi_ignore_ivacc)

			xcall file(pass_chn_data.chn(VI_FILE), virec, vijob, 'ST', err)
			if(err)
				xcall ibc_message('Failed to store new advice')
			xcall file(pass_chn_data.chn(VI_FILE), virec,vijob,'RD',err)
			if(err)
				xcall ibc_message('Failed to re-read new advice')
		end
		else
		begin
			call update_vi_fields
			xcall update_virec
		end
		; Generate Tracking Record if customer on Total Stop
		if (cusrec.cmf_stop == 2 || crlim_pass_ent)
			xcall WHGINE_Trk_Stop_Flag (cusrec, virec.vijob)

	end

	; removed existing sequence recs
	xcall l_status(seq_lst_id, D_LINPID, linp_id)
	clear vq_key
	vq_job = vijob
	xcall file(pass_chn_data.chn[VQ_FILE], vqrec, vq_key, 'FI', err)
	repeat
	begin
		xcall file(pass_chn_data.chn[VQ_FILE], vqrec, vq_key, 'RS', err)
		if err .or. vq_job .ne. vijob
			exitloop
		xcall file(pass_chn_data.chn[VQ_FILE], vqrec, vq_key, 'DE', err)
	end
	unlock pass_chn_data.chn[VQ_FILE]

	; quite a major change.  Any items deleted will now be processed
	; first. The problem prior to this is that if an item is deleted then
	; reinserted, the deletions process will remove a record that has
	; simply been moved.  Should be able to delete an item and then reinsert

	call process_deletions

	; process the sequence list
	xcall l_data(seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err, gold_com,
	&            gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	while .not. err
	begin
		vq_job = vijob
		vq_date_created = vidate
		seq_no += 10
		vq_seq_no = seq_no
		case lst_ntype of
		begincase
			D_VJ_WGD:     begin
				call wgd_upd
				vq_type = D_VJ_WGD
				if (! lAtLeastOneWgd)
					lAtLeastOneWgd = true
			end
			D_VJ_NSTK:    begin
				call nstk_upd
				vq_type = D_VJ_NSTK
			end
			D_VJ_PART:    begin
				call part_upd
				vq_type = D_VJ_PART
			end
			D_VJ_COMMENT: begin
				call cmnt_upd
				vq_type = D_VJ_COMMENT
			end
			D_VJ_TRADE:   begin
				vq_type = D_VJ_TRADE
				call trd_upd
				if (! lAtLeastOneSB)
					lAtLeastOneSB = true
			end
		endcase
		vq_stok = lst_tstk
		xcall file(pass_chn_data.chn(VQ_FILE), vqrec,, 'ST', err)
		if err
			xcall ibc_message('Error storing VQ record')
		xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
		xcall l_data(seq_lst_id, D_LNEXT, linp_id, whgine_lst,, err, gold_com,
		&            gold_ax, fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

	end
	; if just a trade in and main washout stock no is not set then
	; do not allow any over allowance through.
	if (lAtLeastOneSB && ! lAtLeastOneWgd && ! (pass_chn_data.h_prog_code == P_COD_SEL_BILL && virec.vistok))
	begin
		err = %xf_file(pass_chn_data.chn(VB_FILE), vbrec, virec.vijob, 'FI')
		repeat
		begin
			err = %xf_file(pass_chn_data.chn(VB_FILE), vbrec, , 'RS')
			if (err || vbrec.vbjob != virec.vijob)
				exitloop

			if (vbrec.vb_trade_prc[D_BC] - vbrec.vbtnsp)
			begin
				xcall ibc_message('WARNING - Trade in stock no ' + vbrec.vbtstk +' over allowance will be zeroised'
				&	+' as there is no washout stock no to allocate it to.')
				vbrec.vbtnsp = vbrec.vb_trade_prc[D_BC]
				err = %xf_file(pass_chn_data.chn(VB_FILE), vbrec, , 'WR')

				gen_channel = pass_chn_data.chn(VM_FILE)
				err = %xf_file(gen_channel, vmrec, vbrec.vbtstk, 'RD')
				if (err)
				begin
					gen_channel = pass_chn_data.chn(HM_FILE)
					err = %xf_file(gen_channel, vmrec, vbrec.vbtstk, 'RD')
				end
				if (! err)
				begin
					clear vmrec.vmoa
					err = %xf_file(gen_channel, vmrec,, 'WR')
				end
			end
		end
	end
	clear items_moded, hdr_moded, add_part_passed.moded_flag
	if(fkeys[PRTLST_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[PRTLST_FKEYS].fkmnu_id)
	if(fkeys[WGD_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[WGD_FKEYS].fkmnu_id)

	if pass_gen_data.adv_mode .eq. D_INS_MODE
		pass_gen_data.adv_mode = D_AMD_MODE
	mode = pass_gen_data.adv_mode
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section deletes any relevant items from file
	process_deletions,

	; process deletions
	; anything to delete ?
	clear lWqlRFA
	req = D_LL_FIRST
	xcall ll_process(pass_chn_data.lst_cntrl, req, whgine_lst, err)
	while .not. err
	begin
		if(lst_vm_exists)
		begin
			f_lock_vm = TRUE
			pass_chn_data.h_stok = lst_tstk
			xcall check_vm_exists(whgine_passed, lst_vm_exists, lst_vm_rfa)
		end
		if(lst_ntype .ne. D_VJ_TRADE) then
		begin
			vjjob = vijob
			vjtstk = lst_tstk
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok, 'RD', err, 1)
			if(err)
			begin
				del_fail,
				unlock pass_chn_data.chn(VJ_FILE)
				unlock pass_chn_data.chn(VB_FILE)
				unlock pass_chn_data.chn(VM_FILE)
				unlock pass_chn_data.chn(HM_FILE)
				xcall ibc_message(T$FILE_DEL_ERR)
				return
			end
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok, 'DE', err, 1)
			if(err) goto del_fail
			if (virec.vi_quote)
			begin
				lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec, virec.vi_quote, 'FI')
				repeat
				begin
					lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec,, 'RS',, lWqlRFA, Q_NO_LOCK)
					if (lFileError || wqlrec.wql_quote != virec.vi_quote)
						exitloop

					case vjrec.vjnstk of
					begincase
				D_VJ_WGD:	begin
								if (! (wqlrec.wql_type == D_WQL_TYPE_ATTACH && wqlrec_a.wql_a_stok == vjrec.vjtstk) &&
								&   ! (wqlrec.wql_type == D_WQL_TYPE_WGOOD  && wqlrec.wql_w_stk_no == vjrec.vjtstk))
									nextloop
							end
				D_VJ_PART:	if (wqlrec.wql_type != D_WQL_TYPE_PART ||
				&				wqlrec_p.wql_p_partno != vjrec.vj_part_no ||
				&				wqlrec_p.wql_p_qty != vjrec.vjsold)
								nextloop
				D_VJ_COMMENT:if (wqlrec.wql_type != D_WQL_TYPE_COMMENT || wqlrec_c.wql_c_comment != vjrec.vj_comment)
								nextloop
					endcase
					else
						nextloop

					lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec,, 'RD',,,,, lWqlRFA)
					lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec,, 'DE')
					if (vjrec.vjnstk == D_VJ_WGD)
						; need to continue looking for and removing attachments associated with
						; wholegood line just deleted
						nextloop
					else
						exitloop
				end
			end
		end
		else
		begin
			vbjob = vijob
			vbtstk = lst_tstk
			xcall file(pass_chn_data.chn(VB_FILE), vbrec, vbstok, 'RD', err, 1)
			if(err) goto del_fail
			xcall file(pass_chn_data.chn(VB_FILE), vbrec, vbstok, 'DE', err, 1)
			if(err) goto del_fail
			; when looking through quote lines for trade ins, start at the first record for a trade in
			if (virec.vi_quote)
			begin
				lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec, virec.vi_quote, 'FI')
				repeat
				begin
					lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec,, 'RS',, lWqlRFA, Q_NO_LOCK)
					if (lFileError || wqlrec.wql_quote != virec.vi_quote)
						exitloop

					if (wqlrec.wql_type != D_WQL_TYPE_TRADE_IN)
						nextloop
					if (wqlrec.wql_w_stk_no == vbrec.vbtstk)
					begin
						lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec,, 'RD',,,,, lWqlRFA)
						lFileError = %xf_file(pass_chn_data.chn(WQL_FILE), wqlrec,, 'DE')
						exitloop
					end
				end
			end
		end

		if(lst_ntype .eq. D_VJ_NSTK)
			goto del_line_exit     ; no further action for n_stock

		if(lst_ntype .eq. D_VJ_PART)
		begin
			pmf_part = vjnspc(1)
			xcall file(pass_chn_data.chn(PMF_FILE),pmfrec,pmf_part,'RD',err)
			if(.not.err)
			begin
				if( vjsold )
				begin
					if vj_part_type .gt. D_PMF_TYP_MEMO
						xcall whgine_del_hid(gold_com, gold_ax, whgine_lst)
				end
				pdf_depot = dt
				pdf_part_no = vjnspc(1)

				xcall file(pass_chn_data.chn(PDF_FILE),pdfrec,pdf_key,'RE',err)
				xcall upd_pdf_wip(D_WIP_DEL_MODE, D_WIP_WGD, vjrec, virec,
				&		       pdfrec, aIVTrec, cusrec, part_sold_qty)

				if (part_lost_qty)
				begin
					data lPLDChannel,	int
					lPLDChannel = %get_chn(gold_com, PLDFIL, 'U:I')

					if (part_no(1:2) .EQS. 'XX')
						pld_part = part_no(4:18)
					else
						pld_part = part_no
					pld_depot = dt
					pld_date_lost = %ndate
					pld_typ_loss='L'
					pld_ret_pri = part_retail[D_BC]
					pld_q_qty = part_lost_qty

					xcall file(lPLDChannel, pldrec, pld_part, 'ST', err)
					pdf_q_tot_lost += pld_q_qty
				end
				xcall file(pass_chn_data.chn(PDF_FILE), pdfrec, pdf_key, 'WR', err)
				if(err) xcall ibc_message('Error updating depot stock record')
			end
		end
		else
		begin
			if(.not.lst_vm_exists) goto del_line_exit

			if(lst_ntype .eq. D_VJ_WGD) then
				clear vminvf, vmadno, vm_quote, vmrep
			else
				clear vm_sb_adv, vm_sb_advno, vm_buy_rep, vmoa
			if (lst_ntype == D_VJ_WGD && ! viivcr)
			begin
				clear vm_rrp(D_FC), vm_sett(D_FC), vm_f_disc
				clear vm_rrp(D_BC), vm_sett(D_BC)
				if (cms_user_id != 99999)
				begin
					clear vmcust, vmcord, vmfcom, vmfpro, vm_fp_edate
				end
			end
			if(vicust.ne.vmrec.vmcust)
			begin
				xcall vm_cust_trk_update(vmrec.vmstok, vicust, Vmrec.vmcust, gold_com)
			end
			call write_lst_vm
		end

		del_line_exit,

		req = D_LL_DELETE
		xcall ll_process( pass_chn_data.lst_cntrl, req, whgine_lst, err )
		req = D_LL_NEXT
		xcall ll_process( pass_chn_data.lst_cntrl, req, whgine_lst, err )
	end
	return


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       This section creates or writes a vm and a vr record
	write_lst_vm,

	gen_channel = pass_chn_data.chn(VM_FILE)
	if(.not. lst_vm_exists) then
	begin
		while(.not. vmpord)
			xcall dep_seq(vi_depot, DEP_S_PUR, vmpord)
		vmpdat = %ndate
		write_type = 'ST'
	end
	else
	begin
		if(lst_vm_exists .eq. 'H')
			gen_channel = pass_chn_data.chn(HM_FILE)
		write_type = 'WR'
	end

	if (lst_ntype != D_VJ_WGD && lst_ti_del_opt)
	begin
		lNextVM = vmrec.vmnstk
		lPrevVM = vmrec.vmpstk
		clear vmrec.vmnstk, vmrec.vmpstk
	end

	if(write_type .eq. 'WR' .and. old_vmrec)
		xcall upd_wg_serials(old_vmrec, vmrec)

	xcall file(gen_channel, vmrec, vmstok, write_type, err)
	if (lst_ntype != D_VJ_WGD && lst_ti_del_opt && (lPrevVM || lNextVM))
	begin
		if (lPrevVM)
		begin
			gen_channel = pass_chn_data.chn(HM_FILE)
			err = %xf_file(gen_channel, vmrec, lPrevVM, 'RD', , ,Q_NO_LOCK)
			if (err)
			begin
				gen_channel = pass_chn_data.chn(VM_FILE)
				err = %xf_file(gen_channel, vmrec, lPrevVM, 'RD', , ,Q_NO_LOCK)
			end
			if (! err)
			begin
				err = %xf_file(gen_channel, vmrec, lPrevVM, 'RD')
				if (! err)
				begin
					vmrec.vmnstk = lNextVM
					err = %xf_file(gen_channel, vmrec, lPrevVM, 'WR')
				end
			end
		end
		if (lNextVM)
		begin
			gen_channel = pass_chn_data.chn(HM_FILE)
			err = %xf_file(gen_channel, vmrec, lNextVM, 'RD', , ,Q_NO_LOCK)
			if (err)
			begin
				gen_channel = pass_chn_data.chn(VM_FILE)
				err = %xf_file(gen_channel, vmrec, lNextVM, 'RD', , ,Q_NO_LOCK)
			end
			if (! err)
			begin
				err = %xf_file(gen_channel, vmrec, lNextVM, 'RD')
				if (! err)
				begin
					vmrec.vmpstk = lPrevVM
					err = %xf_file(gen_channel, vmrec, lNextVM, 'WR')
				end
			end
		end
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	update_inv_cmnt,
	xcall ScratchPadMove(CMNT_WG_INV_STY,tmp_job_no,CMNT_WG_INV_STY,vjjob)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       updates the advice header fields
	update_vi_fields,

	vijob = vi_job
	viivcr = vi_iorc
	pass_gen_data.h_ivcr = viivcr
	vi_ityp = vi_inv_typ
	vinarr = vi_narr

	vicust = vi_cust
	vinick = cmf_nick_name

	vifcus = vi_fcus
	viord = vi_cord
	vi_req_date=vi_req_dt

	virep = vi_rep
	vi_depot = vi_dep
	viidat = vi_idat
	if(.not.vidate)
		vidate = %ndate

	visett = vi_sett
	viddat = vi_ddat
	vi_crst = vi_crst_inp
	vi_cr_chrg = vi_cr_chrg_inp
	vifpro = vi_fpro
	vi_fp_edate = vi_fpedat

	if((vi_not_sbill.eq.D_VI_NOT_SB_PUR_INV.or.
	&  vi_not_sbill.eq.D_VI_NOT_SB_PUR_SB).and..not. pass_chn_data.h_supacc)
	begin
		vi_not_sbill=D_VI_NOT_SB_PRT_SB
		xcall ibc_message('WARNING - The Trade in Type field on the advice header is '
		& +'set to a purchase option rather than Print Self Biller.  However, there is '
		& +'no associated supplier and therefore this is invalid.  This will be changed'
		& +' automatically to Print Self Biller.')
	end

	vi_not_sb = vi_not_sbill
	vi_sell_cur = pass_gen_data.vi_currency
	vi_cur_cnv = pass_gen_data.vi_exch_rate

	; if item has already been invoiced and the set delivery address
	; to customer address flag is set, then if updates done
	; to the delivery address, will need to clear the flag
	if(vistat .ge. D_ADV_INVOICED .and. vi_cmf_add_in_dela ) then
	begin
		if(wgd_deladd[])
		begin
			videla[] = wgd_deladd[]
			vi_del_postcode = wgd_del_postcode
			clear vi_cmf_add_in_dela
		end
	end
	else
	begin
		videla[] = wgd_deladd[]
		vi_del_postcode = wgd_del_postcode
	end

	vistok = vi_stok
	vitigr = vi_tigr

	vi_comm_buy_split=vi_comm_buy_sp
	vi_pm_contract=vi_i_pm_contract
	vi_deposit_status=fin_deposit_status
	vi_deposit_amt=fin_deposit_amt
	vi_deposit_vat=fin_deposit_vat
	vi_deposit_total=fin_deposit_total
	vi_deposit_desc[]=fin_deposit_desc[]
	vi_px_fin_sett=fin_px_fin_sett
	vi_px_fin_supp=fin_px_fin_supp
	vi_px_fin_desc[]=fin_px_fin_desc[]
	vi_dep_inv_no=fin_dep_inv_no
	vi_dep_inv_date=fin_dep_inv_date
	vi_md_group=vi_def_md_group

	vi_prv_ti_stk[]=fin_pr_ti_stk[]
	
	; if cash sale set customer address fields, cash a/c name and address can be changed in header tab
	if( cmf_inv_mthd == CMF_INV_MTHD_CASH)
	begin
		vi_cus_name = vi_cusnam
		vi_cus_add[] = vi_cusadd[]
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	wgd_upd,
	req = D_LTOP
	repeat
	begin
		xcall l_process(wgd_lst_id, req, whgine_vj,, gold_com, gold_ax,
		&           fkeys[WGD_FKEYS], whgine_passed, fkeys, whgine_lst,
		&           whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)
		xcall l_status(wgd_lst_id, D_LATBOTTOM, at_bottom)
		if lst_stkno .eq. whgine_vj.vj_tstk
		begin
			call wgd_line_upd
			exitloop
		end
		if at_bottom
			exitloop
		req = D_LDOWN
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	wgd_line_upd,
	if whgine_vj.vj_hide_ln .ne. lst_hide
		lst_moded = true

	if lst_moded .or.hdr_moded      ; eg hdr moded to update customer
	begin
		vjjob = vijob
		vjtstk = lst_tstk
		xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok,'RE',err, 1)
		if(err) then
		begin
			whgine_vj.vj_prev_batch = false
			clear vjrec
		end
		else
			whgine_vj.vj_prev_batch = true
		vjnstk = D_VJ_WGD
		whgine_vj.vj_hide_ln = lst_hide
		xcall update_vj_fields(whgine_lst, whgine_vj, whgine_passed, invoice_totals)
		if (! whgine_vj.vj_prev_batch)
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok, 'ST', err, 1)
		else
			xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vjstok,'WR',err,1)
		if(err) xcall ibc_message('Write error on vj record')

		if attach_ll
		begin
			xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
			while .not. err
			begin
				new_rrp = vd_rrp(D_FC)
				new_vi_rrp = vd_vi_rrp(D_FC)
				new_hide_att = vd_hide
				new_model = vd_model
				new_spec[] = vdmodl[]
				new_vat = vdvat

				xcall file(pass_chn_data.chn(VD_FILE),vdrec, vdastk, 'RD', err)
				if .not. err
				begin
					vd_rrp(D_FC) = new_rrp
					vd_rrp(D_BC)=%f_curr_bc(vd_rrp(D_FC),pass_gen_data.vi_exch_rate)
					vd_vi_rrp(D_FC) = new_vi_rrp
					vd_vi_rrp(D_BC)=%f_curr_bc(vd_vi_rrp(D_FC),pass_gen_data.vi_exch_rate)
					vd_hide = new_hide_att
					vd_sell_cur=pass_gen_data.vi_currency
					vd_model = new_model
					vdmodl[] = new_spec[]
					vdvat = new_vat

					xcall file(pass_chn_data.chn(VD_FILE),vdrec, vjstok, 'WR', err)
				end
				xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
			end
		end
		pass_chn_data.h_stok=vjtstk
		xcall check_vm_exists(whgine_passed, whgine_vj.vj_vm_exists,
		&                     whgine_vj.vj_vm_rfa)
		if whgine_vj.vj_vm_exists then
		begin
			if(whgine_vj.vj_vm_exists .eq. 'S') then
			begin
				xcall file(pass_chn_data.chn(VM_FILE),vmrec,,'RD',err,,,, whgine_vj.vj_vm_rfa)
				if err
					xcall ibc_message('Error reading vmrec - S')
			end
			else
			begin
				xcall file(pass_chn_data.chn(HM_FILE),vmrec,,'RD',err,,,, whgine_vj.vj_vm_rfa)
				if err
					xcall ibc_message('Error reading vmrec - H')
			end
		end

		xcall update_vm_from_vj(old_vmrec, whgine_vj, gold_com)
		xcall whgine_write_vm(whgine_vj.vj_vm_exists, whgine_vj.vj_vm_rfa,
		&                     old_vmrec)
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	nstk_upd,
	req = D_LTOP
	repeat
	begin
		xcall l_process(nstk_lst_id, req, whgine_nstk,, gold_com, gold_ax,
		&           fkeys[NSTK_FKEYS], whgine_passed, fkeys, whgine_lst, whgine_inv_tab,
		&       whgine_hdr, add_part_passed, invoice_totals)
		xcall l_status(nstk_lst_id, D_LATBOTTOM, at_bottom)
		if lst_stkno .eq. whgine_nstk.vj_tstk
		begin
			call nstk_line_upd
			exitloop
		end
		if at_bottom
			exitloop
		req = D_LDOWN
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	nstk_line_upd,
	if whgine_nstk.vj_hide_ln .ne. lst_hide
		lst_moded = true

	if lst_moded
	begin
		if whgine_nstk.vj_prev_batch
		begin
			vjjob = vijob
			vjtstk = lst_tstk
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok,'RD',err, 1)
		end
		vjnstk = D_VJ_NSTK
		whgine_nstk.vj_hide_ln = lst_hide

		if(pass_gen_data.plan_maint)
		begin
			whgine_vj.vj_inp_pm_group=whgine_lst.lst_wg_pm_group
			; prepare to update pml record with latest clock reading if this has been set
			if(whgine_lst.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING.and.whgine_vj.wg_pm_clock)
			begin
				err=%pm_clock_update(D_AUDIT_WHOLEGOOD_INVOICE, whgine_lst.wg_pm_equip_no, whgine_lst.wg_pm_equip_no,
				&  whgine_hdr.vi_i_plant_wgd,
				&  whgine_vj.wg_pm_clock, whgine_vj.wg_pm_curr_clock_date,,true)
			end
			if(whgine_vj.vj_inp_pm_group.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
			begin
				whgine_vj.vj_extra_text='CLK='+%string(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock)
				if(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_est)
					whgine_vj.vj_extra_text=%atrim(whgine_vj.vj_extra_text)+'E'
			end
		end
		xcall update_vj_fields(whgine_lst, whgine_nstk, whgine_passed, invoice_totals)

		if .not. whgine_nstk.vj_prev_batch then
			xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vjstok,'ST',err,1)
		else
			xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vjstok,'WR',err,1)
		if(err)
			xcall ibc_message('Write error on vj record')
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	part_upd,
	req = D_LTOP
	repeat
	begin
		xcall l_process(prt_lst_id, req, part_data,,gold_com, gold_ax,
		&          fkeys[PRTLST_FKEYS], add_part_passed, invoice_totals,
		&          pass_chn_data.chn, whgine_passed, fkeys, whgine_lst,
		&          whgine_inv_tab, whgine_hdr)
		xcall l_status(prt_lst_id, D_LATBOTTOM, at_bottom)
		if part_wgstk .eq. lst_tstk
		begin
			call part_line_upd
			exitloop
		end
		if at_bottom
			exitloop
		req = D_LDOWN
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	part_line_upd,
	if lst_moded
	begin
		if .not. part_data.prev_batch
		begin
			; create vjrec
			clear vjrec
			vjjob = vijob
			vjtstk = lst_tstk
			vjnspc(1) = part_no
			vjnspc(2)= part_desc
			vjsold = part_sold_qty
			vj_qty_dp = part_qty_dp
			vj_hide = lst_hide
			vjnvat = part_vat
			vjcost = part_cost_fc
			call retail_update
			vjnstk = D_VJ_PART
			vj_f_sett = lst_sett
			vj_f_disc = lst_disc
			vj_f_vi_disc = lst_vi_disc
			vj_part_type = part_type
			vj_disc_pcnt = lst_disc_pcnt
			vj_orig_price = lst_orig_price
			vj_kit_status = part_kit_status
			vj_cust_demand = part_cust_demand
			vj_exclude_fill_rep = part_exclude_fill_rep

			if( part_type.gt. D_PMF_TYP_MEMO .and. part_sold_qty .and.
			&  (vi_iorc.eq.D_VIIVCR_INVOICE .or.vi_iorc.eq.D_VIIVCR_PART_INV))
				xcall update_hort(D_HID_LINK_WGDS, vijob, part_line)

			if( part_type.gt. D_PMF_TYP_MEMO .and. part_sold_qty .and.
			&       vi_iorc .eq. D_VIIVCR_CREDIT)
				call cre_hpd

			if( vjsold .AND. part_no(1:2) .nes. 'XX' )
			begin
				pdf_depot = dt
				pdf_part_no = vjnspc(1)

				xcall file(pass_chn_data.chn(PDF_FILE),pdfrec,pdf_key,'RE',err)
				if (err)
					exit
				xcall upd_pdf_wip(D_WIP_INS_MODE, D_WIP_WGD, vjrec, virec,
				&		       pdfrec, aIVTrec, cusrec, part_sold_qty)
				xcall file(pass_chn_data.chn(PDF_FILE), pdfrec, pdf_key, 'WR', err)
				if(err)
					xcall ibc_message('Error updating depot stock record')
			end

			xcall file(pass_chn_data.chn[VJ_FILE], vjrec, vjstok, 'ST', err)
			if err
				xcall ibc_message('Error storing VJ record')
		end

		if( part_data.prev_batch )
		begin
			vjjob = vijob
			vjtstk = lst_tstk
			vj_hide = lst_hide
			xcall file( pass_chn_data.chn[VJ_FILE], vjrec, vjstok, 'RD', err, 1 )
			; if vj record not found display message and ignore
			; rather than update wrong one.
			if(err) then
			begin
				xcall ibc_message(T$UPD_ERROR)
				unlock pass_chn_data.chn[VJ_FILE]
			end
			else
			begin
				vj_hide = lst_hide
				vj_f_disc = lst_disc
				vj_f_vi_disc = lst_vi_disc
				vj_f_sett = lst_sett
				vj_disc_pcnt = lst_disc_pcnt
				vjnspc(2)= part_desc
				if( part_no(1:2) .eq. 'XX' )
				begin
					vjnvat = part_vat
					vjcost = part_cost_fc
				end
				call retail_update
				vj_disc_pcnt = lst_disc_pcnt
				pdf_depot = dt
				pdf_part_no = vjnspc(1)

				xcall file(pass_chn_data.chn(PDF_FILE),pdfrec,pdf_key,'RE',err)
				xcall upd_pdf_wip(D_WIP_AMD_MODE, D_WIP_WGD, vjrec, virec,
				&		       pdfrec, aIVTrec, cusrec, part_sold_qty)
				xcall file(pass_chn_data.chn(PDF_FILE), pdfrec, pdf_key, 'WR', err)
				if(err)
					xcall ibc_message('Error updating depot stock record')

				vjsold = part_sold_qty
				vj_cust_demand = part_cust_demand
				xcall file( pass_chn_data.chn[VJ_FILE], vjrec, vjstok, 'WR', err )
			end
		end
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	retail_update,
	if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC) then
	begin
		vj_f_vi_rrp=part_retail_fc
		xcall whgine_vat_calc(vj_f_rrp, vjnvat,
		&        vt_vat_code, vt_vrat, vj_f_vi_rrp,
		&        D_RET_VAT_INC, D_RET_VAT_EXC)
	end
	else
	begin
		vj_f_rrp = part_retail_fc
		xcall whgine_vat_calc(vj_f_vi_rrp, vjnvat,
		&        vt_vat_code, vt_vrat, vj_f_rrp,
		&        D_RET_VAT_EXC, D_RET_VAT_INC)
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;               Create HPD records for Receipt
	cre_hpd,
	for loop from 1 thru hid_lat
	begin
		hidrec = ^m(ll_hidrec[loop].ll_hid, hid_mhndl)
		if( hid_line_no .eq. part_line )
		begin
			if(hid_invoice_no.eq.T$AUTO) hid_invoice_no = vijob
			if(hid_pur_ord_no.eq.T$AUTO) hid_pur_ord_no = vijob
			if( .not. ^m(ll_hidrec[loop].ll_hid_st, hid_mhndl) )
				xcall file(g_hid_chn, hidrec, ,'ST',err)

			clear hpdrec
			hpd_status = HRT_LIVE_TYPE
			hpd_part = hid_part
			hpd_depot = gold_com.cur_depot
			hpd_batch = hid_batch
			hpd_bat_line = hid_bat_line
			hpd_pur_ord_no = hid_pur_ord_no
			hpd_order_line = hid_order_line
			hpd_del_date = vidate
			hpd_qty_rec = hid_qty
			hpd_alloc = hid_qty
			hpd_serial = hid_serial_no
			hpd_cost = hid_act_cost
			hpd_retail = %f_curr_bc(hid_f_retail,fcf_std_rate)
			hpd_text = hid_text
			hpd_source = hid_source
			hpd_type = hid_type
			xcall file( g_hpd_chn, hpdrec, , 'ST', err)

		end
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	trd_upd,
	req = D_LTOP
	repeat
	begin
		xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
		&           fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
		&           whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)
		xcall l_status(trd_lst_id, D_LATBOTTOM, at_bottom)
		if vb_tstk .eq. lst_tstk
		begin
			call trd_line_upd
			exitloop
		end
		if at_bottom
			exitloop
		req = D_LDOWN
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	trd_line_upd,
	if lst_moded .or. hdr_moded     ; eg hdr moded to update customer (vmpacc)
	begin
		if .not. vb_prev_batch then
		begin
			clear vbrec
			vbjob=vijob
			vbtstk=vb_tstk

			if(pass_gen_data.adv_mode.eq.D_INS_MODE.and.cms_gnavsk.and.vb_tstk.eq.T$AUTO)
			begin
				while(vb_tstk.eq.T$AUTO)
				begin
					xcall stk_seq(vb_tstk,err,vi_dep)
					if(.not.err) vbtstk=vb_tstk
				end
			end
		end
		else
		begin
			vbjob = vijob
			vbtstk = vb_tstk
			xcall file(pass_chn_data.chn(VB_FILE), vbrec, vbstok, 'RD', err, 1)
		end

		vbtgrp = vb_grp
		vbtmak = vb_mak
		vbcode = vb_code
		vbtmod = vb_tmod
		for loop from 1 thru 10
			vbtspc[loop] = vb_spec[loop]
		vbtser = vb_ser
		vbtreg = vb_reg
		vbtdat = vb_dreg
		vbtclk = vb_clok
		vb_year = vb_yr

		vb_trade_prc(D_BC) = vb_tip_bc
		if(pass_gen_data.vi_currency .eq. cms_base_cur) then
			vb_trade_prc(D_FC) = vb_tip_bc
		else
			vb_trade_prc(D_FC) = vb_tip_fc

		vb_est_repairs=vb_e_repairs_bc
		vb_est_warr=vb_e_warr_bc

		vbtnsp = vb_net_bc
		vbtrrp = vb_rrp_bc
		vbtvat = vb_vat
		vb_hide = vb_hide_ln
		vb_hide_attach = vb_hide_att

		vb_wash = vb_wash_comp
		vb_qual = vb_qualify

		if(.not. vb_prev_batch) then
			xcall file(pass_chn_data.chn(VB_FILE),vbrec,vbstok,'ST',err,1)
		else
			xcall file(pass_chn_data.chn(VB_FILE),vbrec,vbstok,'WR',err,1)
		if(err) xcall ibc_message('Write error on vb record')

		if attach_ll
		begin
			xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
			while .not. err
			begin
				new_rrp = vd_rrp(D_FC)
				new_vat = vdvat
				xcall file(pass_chn_data.chn(VD_FILE),vdrec, vdastk, 'RD', err)
				if .not. err
				begin
					vd_rrp(D_FC) = new_rrp
					vd_rrp(D_BC) = %f_curr_bc(vd_rrp(D_FC),pass_gen_data.vi_exch_rate)
					vdvat=new_vat
					xcall file(pass_chn_data.chn(VD_FILE),vdrec, vjstok, 'WR', err)
				end
				xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
			end
		end

		if vb_vm_exists then
		begin
			if(vb_vm_exists .eq. 'S') then
				xcall file(pass_chn_data.chn(VM_FILE),vmrec,,'RD',err,,,, vb_vm_rfa)
			else
				xcall file(pass_chn_data.chn(HM_FILE),vmrec,,'RD',err,,,, vb_vm_rfa)
		end

		xcall vm_change_to_qualify(VMREC, vb_qual)

		call update_vm_from_vb
		call write_vb_vm
		if vb_same_machine
		begin
			pass_chn_data.h_stok = vb_prev_stk
			f_lock_vm = true
			xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
			vmnstk = vb_tstk
			if(vb_vm_exists.eq.'S') then
				xcall file(pass_chn_data.chn(VM_FILE), vmrec, vmstok, 'WR', err)
			else
				xcall file(pass_chn_data.chn(HM_FILE), vmrec, vmstok, 'WR', err)
		end
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       update the vm fields from the vb record
	update_vm_from_vb,
	old_vmrec = vmrec

	vm_sb_advno = vijob
	vm_buy_rep=virep
	vmpacc = vi_cust
	if(vmpsys.ne.'C') vmpsys='C'
	vmstok = vbtstk
	vmgrp = vbtgrp
	vmmak = vbtmak
	vmcode = vbcode
	vmmodl = vbtmod
	vmser = vbtser
	vmclok = vbtclk
	vmreg = vbtreg
	vmdreg = vbtdat
	vm_tip(D_FC) = vb_trade_prc(D_FC)
	vm_tip(D_BC) = vb_trade_prc(D_BC)
	vm_est_cos(D_FC) = vm_tip(D_FC)
	vm_est_cos(D_BC) = vm_tip(D_BC)

	if(.not.vminvf) vmvat = vbtvat
	vmoa = vb_trade_prc(D_BC) - vbtnsp
	set vm_rrp(D_FC), vm_rrp(D_BC) = vbtrrp
	vm_sell_cur = cms_base_cur
	vm_sell_cnv = 1.0
	vm_pur_cur = pass_gen_data.vi_currency
	vm_pur_cnv = fcf_std_rate
	vm_wash = vb_wash
	vm_qualifying = vb_qual
	vm_year = vb_year

	if(vb_same_machine) vmpstk = vb_prev_stk
	if(.not. vb_prev_batch)
	begin
		vm_sb_adv = TRUE
		vm_comm_code = h_comm_code
	end
	if(.not.vm_comm_code)
		xcall whgine_get_group(vmgrp,,,, vm_comm_code)
	if(.not.vm_comm_code) vm_comm_code = cmf_def_comcod

	if(vb_used) then vmnu = 'U'
	else vmnu = 'N'
	vmtype = vb_type                        ; 0={wholegd}, 1=vehicle

	vm_est_repairs = vb_est_repairs
	vm_est_warr = vb_est_warr

	call update_est_pdi_details
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       if there has been a changhe in either est pdi cost or hours
        ;       write a wgd tracking record away reflect change
	update_est_pdi_details,

	if(vb_prev_batch)
	begin
		if(vm_est_pdi_cost  .ne. vb_est_pdi_cost_bc)
		begin
			xcall s_bld(tmp_trk_text,,'PDI/Refurb Labour Cost Change %a -> %a',
			&       %f_ljust(%f_get_dec(vm_est_pdi_cost,cms_base_dp)),
			&       %f_ljust(%f_get_dec(vb_est_pdi_cost_bc,cms_base_dp)))
			call write_tracking
		end

		if(vm_est_prt_pdi_cost  .ne. vb_est_prt_pdi_cost_bc)
		begin
			xcall s_bld(tmp_trk_text,,'PDI/Refurb Parts Cost Change %a -> %a',
			&       %f_ljust(%f_get_dec(vm_est_prt_pdi_cost,cms_base_dp)),
			&       %f_ljust(%f_get_dec(vb_est_prt_pdi_cost_bc,cms_base_dp)))
			call write_tracking
		end

		if(vm_est_pdi_hours .ne. vb_est_pdi_hours)
		begin
			xcall s_bld(tmp_trk_text,,'PDI/Refurb Hours Change %a -> %a',
			&       %f_ljust(%f_get_dec(vm_est_pdi_hours,2)),
			&       %f_ljust(%f_get_dec(vb_est_pdi_hours,2)))
			call write_tracking
		end
	end

	vm_est_pdi_cost = vb_est_pdi_cost_bc
	vm_est_prt_pdi_cost = vb_est_prt_pdi_cost_bc
	vm_est_pdi_hours = vb_est_pdi_hours
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       write a wgd tracking record away reflect change
	write_tracking,

	xcall tracking(D_TRK_WGDS, vmstok, tmp_trk_text)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       This section creates or writes a vm and a vr record
	write_vb_vm,

	gen_channel = pass_chn_data.chn(VM_FILE)

	while(! vmpord)
		xcall dep_seq(vi_depot, DEP_S_PUR, vmpord)

	if (! vmpdat)
		vmpdat = %ndate

	if(.not. vb_vm_exists) then
	begin
		write_type = 'ST'
	end
	else
	begin
		if(vb_vm_exists .eq. 'H')
			gen_channel = pass_chn_data.chn(HM_FILE)
		write_type = 'WR'
	end

	xcall file(gen_channel, vmrec, vmstok, write_type, err)

	if(write_type .eq. 'WR' .and. old_vmrec)
		xcall upd_wg_serials(old_vmrec, vmrec)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cmnt_upd,
	req = D_LTOP
	repeat
	begin
		xcall l_process(cmnt_lst_id, req, whgine_cmnt_lst,, gold_com, gold_ax,
		&           fkeys[CMNT_FKEYS], whgine_passed, fkeys, whgine_lst)
		xcall l_status(cmnt_lst_id, D_LATBOTTOM, at_bottom)
		if cmnt_no .eq. ^d(lst_tstk(5:4))
		begin
			call cmnt_line_upd
			exitloop
		end
		if at_bottom
			exitloop
		req = D_LDOWN
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	cmnt_line_upd,
	if lst_hide .ne. cmnt_hide ; hide can be moded without changing vj rec
		lst_moded = true

	if lst_moded
	begin
		if .not. cmnt_prev_batch then
		begin
			; create vjrec
			clear vjrec
			vjjob = vijob
			vjtstk = lst_tstk
			vj_comment = lst_comment
			vj_hide = lst_hide
			vjnstk = D_VJ_COMMENT
			xcall file(pass_chn_data.chn[VJ_FILE], vjrec, vjstok, 'ST', err)
			if err
				xcall ibc_message('Error storing VJ record')
		end
		else
		begin
			vjjob = vijob
			vjtstk = lst_tstk
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok,'RD',err, 1)
			vj_comment = lst_comment
			vj_hide = lst_hide
			xcall file(pass_chn_data.chn(VJ_FILE), vjrec, vjstok,'WR',err)
			if err
				xcall ibc_message('Error storing VJ record')
		end
	end
	return

.end

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	routine to cancel any wholegoods that have been entered this
	;	session.  This is because we now allocate thw wholegood when the item is
	;	inserted,this functionality was introduced in Jan 2016 after it was found
	;	that it was possible to enter the same wholegood in more than
	;	advice.  Prior to this change, vminf, vmadno was only updated
	;	once the whole advice is saved.
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
subroutine whgine_cancel_wgds
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	endparams

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VMCOM.REC'

external function
	f_yes_no,	d
endexternal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record lGeneral
		.include 'whgine_lst' repository, group='whgine_lst'
		lError,			int
		lReq,			int
	endrecord
proc
	init lGeneral


	xcall l_data( seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst, , lError)
	while(! lError )
	begin
		if (lst_ntype == D_VJ_WGD && ! lst_prev_batch)
		begin
			f_lock_vm = TRUE
			pass_chn_data.h_stok = lst_tstk
			xcall check_vm_exists(whgine_passed, lst_vm_exists, lst_vm_rfa)
			if (vmrec.vminvf)
			begin
				if (vmrec.vmadno && vmrec.vmadno != whgine_hdr.whgine_vi_grp.vi_job)
					exit
				clear vmrec.vminvf, vmrec.vmadno
				if (vmrec.vmcust && %f_yes_no(lst_tstk + ' is allocated to Customer - Deallocate ? ') == D_YES)
					clear vmrec.vmcust

				if(lst_vm_exists == 'H')
					lError = %xf_file(pass_chn_data.chn(HM_FILE), vmrec, lst_tstk, 'WR')
				else
					lError = %xf_file(pass_chn_data.chn(VM_FILE), vmrec, lst_tstk, 'WR')
			end
		end
		xcall l_data( seq_lst_id,D_LNEXT, seq_linp_id, whgine_lst, , lError)
	end

	; If any wgds were deleted from the list the vminvf flag would be cleared.  If we're now cancelling the update we need to reset the flag
	xcall WHGINE_reset_inv_flag(whgine_passed, whgine_hdr)

	xreturn
endsubroutine
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_proc_tab

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup

	.include 'SRC:OPSCOM.REC'

	record gen
		chr,            a1
		num,            d2
.proc
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	repeat
	begin
		xcall ibc_chr(chr, a_wndid)
		if g_select
		begin
			case g_entnam of
			begincase
				'J_QUIT':           exitloop
			endcase
			else
				exitloop
		end
	end
	xcall ibctab_highlight(tabset_id, false)
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
.function whgine_vb_ser_change,^val
	a_data_entered,         a
	a_data_stored,          a
	a_pending_status,       n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group = 'whgine_vb'
.proc
	if (a_pending_status.ne.D_OK)
		freturn a_pending_status

	xcall stk_serial(a_data_stored,vb_tstk)

	freturn D_OK

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.function whgine_aft_trd_hide,^val
	a_data_entered,         a
	a_data_stored,          n
	a_pending_status,       n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group = 'whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group = 'fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VMCOM.REC'

	record general
		line_no,                d3

.proc
	if (a_pending_status .ne. D_OK .or. (g_select .and.g_entnam .eq. 'J_QUIT'))
		freturn a_pending_status

	xcall l_status(trd_lst_id,D_LCURITM,line_no)

	if (line_no.eq.1.and.a_data_stored)
	begin
		xcall ibc_message('Cannot Hide First Trade In Line')
		freturn D_EMITTEDERR
	end

	freturn D_OK

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       This section reads through all the items on the list and
        ;       displays totals for the advice
.subroutine whgine_disp_lst_tots

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_curr_fc,      d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	record gen
		err,            d3
		.include 'whgine_lst' repository, group='whgine_lst'
		tmp_val,        d10
	endrecord
	record ifours
		linp_id,        i4
		lVatType,		int
	endrecord

.proc
	clear gen, ^i(ifours)
	xcall i_ldinp(linp_id, g_utlib, 'whgine_totinp', D_NOPLC,,,
	&             h_seq_linp_name)
	if(.not.pass_gen_data.plan_maint.and.
	&       wg_security .eq. ACC_NO_COST_DISP)
		xcall i_setdel(linp_id, 'full_set', 'lst_tot_cost')

	clear adv_totals, trd_cmnt_flg, any_zero_cost

	; accumulate wholegoods and attachments
	xcall l_data( seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err )
	while( .NOT. err )
	begin
		if lst_ntype .eq. D_VJ_COMMENT
		begin
			lst_trd_cmnt = trd_cmnt_flg
			xcall i_display(linp_id,, whgine_lst)
			xcall l_data( seq_lst_id,D_LWRITE, linp_id, whgine_lst,, err )
			xcall l_data( seq_lst_id,D_LNEXT, linp_id, whgine_lst,, err )
			nextloop
		end
		incr line_count
		if(.not. lst_qty) lst_qty=1.0
		if(.not.lst_sb_type) then
		begin
			if lst_ntype .eq. D_VJ_PART
				lst_retail = lst_retail * lst_qty
			call calc_vat
			if lst_ntype .eq. D_VJ_PART
				lst_retail = lst_retail / lst_qty
			if lst_ntype .eq. D_VJ_PART then
			begin
				incr part_count
				if lst_kit_part .ne. KIT_LINE
				begin
					prt_t_retail += lst_retail * lst_qty
					if lst_part_type .gt. D_PMF_TYP_MEMO then
						prt_t_cost += %f_curr_fc(lst_dsp_cost, pass_gen_data.vi_exch_rate)
					else
						prt_t_cost += %f_curr_fc(lst_dsp_cost * lst_qty , pass_gen_data.vi_exch_rate)
					prt_t_disc +=  lst_dsp_disc
					prt_t_sett += lst_sett
					prt_t_vat += lst_vat_val
					prt_t_orig_rrp += lst_orig_price * lst_qty
				end
				lst_trd_cmnt = trd_cmnt_flg
				if .not. lst_dsp_cost
					any_zero_cost = true
				xcall set_qty_dp(linp_id, lst_qty_dp)
				xcall i_display(linp_id,, whgine_lst)
				xcall l_data( seq_lst_id,D_LWRITE, linp_id, whgine_lst,, err )
			end
			else
			begin
				incr adv_line_count
				adv_t_cost += lst_tot_cost
				adv_t_disc += lst_disc
				adv_t_sett += lst_sett
				adv_t_retail += lst_retail
				adv_t_vat += lst_vat_val
				adv_t_orig_rrp += lst_orig_price
				if((pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.lst_ntype .ne. D_VJ_PART).or.
				&   (pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC.and.lst_ntype .eq. D_VJ_PART))
					adv_t_vat_inc += lst_vat_val

				lst_trd_cmnt = trd_cmnt_flg
				if .not. lst_dsp_cost
					any_zero_cost = true
				xcall i_display(linp_id,, whgine_lst)
				xcall l_data( seq_lst_id,D_LWRITE, linp_id, whgine_lst,, err )
				if attach_ll
					call chk_attachments
			end
		end
		else
		begin
			trd_cmnt_flg = true
			incr sb_line_count
			call calc_vat
			sb_t_cost_bc += lst_dsp_cost
			sb_t_cost_fc += lst_cost
			sb_t_disc += lst_disc
			if(pass_chn_data.h_prog_code.ne.P_COD_SEL_BILL)
				adv_t_cost += lst_disc
			sb_t_retail += lst_retail
			sb_t_vat += lst_vat_val
			lst_trd_cmnt = trd_cmnt_flg
			xcall i_display(linp_id,, whgine_lst)
			xcall l_data( seq_lst_id,D_LWRITE, linp_id, whgine_lst,, err )
			if attach_ll
				call chk_attachments
		end
		xcall l_data( seq_lst_id,D_LNEXT, linp_id, whgine_lst,, err )
	end

	xcall ibc_window(D_DELETE, linp_id)

	sb_t_mrg = sb_t_retail - (sb_t_cost_fc - sb_t_disc)
	if sb_t_retail
		sb_t_mrg_pcnt = (sb_t_mrg * 10000) / sb_t_retail

	adv_t_mrg = adv_t_retail - adv_t_cost - adv_t_disc
	if(adv_t_retail - adv_t_disc) then
		adv_t_mrg_pcnt = (adv_t_mrg * 10000) / (adv_t_retail - adv_t_disc)
	else
		clear adv_t_mrg_pcnt

	prt_t_mrg = prt_t_retail - prt_t_cost - prt_t_disc

	if(prt_t_retail - prt_t_disc) then
		prt_t_mrg_pcnt = (prt_t_mrg * 10000) / (prt_t_retail - prt_t_disc)
	else
		clear prt_t_mrg_pcnt

	adv_tot_retail = adv_t_retail + prt_t_retail
	adv_tot_sett = adv_t_sett + prt_t_sett
	adv_tot_disc = adv_t_disc + prt_t_disc
	adv_tot_cost = adv_t_cost + prt_t_cost
	adv_tot_mrg = adv_t_mrg + prt_t_mrg
	adv_tot_vat = adv_t_vat + prt_t_vat
	if(adv_tot_retail - adv_tot_disc) then
		adv_tot_mrg_pcnt = (adv_tot_mrg * 10000) /
		&     (adv_tot_retail - adv_tot_disc)
	else
		clear adv_tot_mrg_pcnt

	if(.not.adv_line_count)
		clear last_quick_wg, last_quick_desc

	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed,
	&                            whgine_hdr, whgine_inv_tab)

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	calc_vat,
	if (! whgine_lst.lst_vat)
	begin
		if (whgine_lst.lst_ntype == D_VJ_TRADE)
		begin
			if ((! pass_gen_data.h_vatable || ! pass_gen_data.h_vatreg) ||
			&  ((cms_country == UK_VAT || cms_country == EIRE_VAT) && whgine_lst.lst_used && ! whgine_lst.lst_qual))
				whgine_lst.lst_vat = pass_gen_data.sb_vat_zero
			else
				whgine_lst.lst_vat = pass_gen_data.sb_vat_code
		end
		else
		begin
			if (! pass_gen_data.h_vatable)
			begin
				if (cms_country == EIRE_VAT)
					whgine_lst.lst_vat = ivt_vat_zero
				else
					whgine_lst.lst_vat = cms_uk_zero_vat
			end
			else
			begin
				if (cms_country == EIRE_VAT)
					whgine_lst.lst_vat = ivt_vat_code
				else
					whgine_lst.lst_vat = cms_uk_def_vat
			end
		end
		; if after all of the above, the vat code is still not set to
		; anything, set it to 1
		if (! whgine_lst.lst_vat)
		begin
			xcall ibc_message('The vat code for ' + %atrim(whgine_lst.part_code) + ' - ' + %atrim(whgine_lst.list_desc)
			&	+ ' is not set.  Please amend the line and set the vat code correctly.  This problem indicates'
			&   +' that the default vat codes have not been fully set.')
		end
	end

	if(lst_sb_type) then
		lst_vat_val=%f_curr_fc(lst_pur_cost, pass_gen_data.vi_exch_rate)
	else
	begin
		lst_vat_val = lst_retail
	end

	if(pass_chn_data.h_prog_code == P_COD_CAR_SAL && list_type == T$MAIN_WG && lst_ucar)
	begin
		data lMarginCost,		int
		lMarginCost = %whgprt_vat_margin_cost(gold_com, lst_tstk)
		if (vmpsys == 'S' && ! lst_qual && list_type != T$ATTACH && list_type != T$PART && lMarginCost > 0 )
		begin
			lst_vat_val=lst_vat_val-%f_curr_fc(lMarginCost, pass_gen_data.vi_exch_rate)
		end
		else
		begin
			lst_vat_val=lst_vat_val-%f_curr_fc(lst_cost, pass_gen_data.vi_exch_rate)
		end
		xcall whgine_vat_calc(lst_vat_val, lst_vat, vt_vat_code, vt_vrat, lst_vat_val, D_RET_VAT_INC, D_RET_VAT_VAL)
	end
	else
	begin
		if (vmnu == 'U' && !vm_qualifying && list_type == T$ATTACH)
		begin
			lVatType = D_RET_VAT_INC
		end
		else
		begin
			lVatType = D_RET_VAT_EXC
		end

		xcall whgine_vat_calc(lst_vat_val, lst_vat, vt_vat_code, vt_vrat, lst_vat_val, lVatType, D_RET_VAT_VAL)
	end

	if(.not. lst_sb_type .and. lst_disc)
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL .and. lst_ucar) THEN
		xcall whgine_vat_calc(tmp_val, lst_vat,
		&        vt_vat_code, vt_vrat, lst_disc,
		&        D_RET_VAT_INC, D_RET_VAT_VAL)
		else
			xcall whgine_vat_calc(tmp_val, lst_vat,
			&        vt_vat_code, vt_vrat, lst_disc,
			&        D_RET_VAT_EXC, D_RET_VAT_VAL)
		lst_vat_val -=tmp_val
	end

	; if this is the uk and used car type and vat calculated as less than zero
	; ie. when retail - discount - cost < 0 then clear vat
	if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL
	&  .and. lst_ucar .and.lst_vat_val .lt. 0)
		clear lst_vat_val

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	chk_attachments,
	xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
	while .not. err
	begin
		; temporarily overwrite parent record values
		lst_pur_cost=vd_est_cos(D_BC)
		lst_cost=vd_cost(D_BC)
		if(cms_gnvcos.eq.D_WG_AUTO_COST_ADJ
		&                .and..not.vd_fin_inv.and.vd_est_cos(D_BC).gt.vd_cost(D_BC))
		begin
			lst_pur_cost=vd_est_cos(D_BC)
			lst_cost=vd_est_cos(D_BC)
		end
		if pass_gen_data.vi_currency .ne. cms_base_cur
		begin
			lst_pur_cost = %f_curr_fc(lst_pur_cost, pass_gen_data.vi_exch_rate)
			lst_cost = %f_curr_fc(lst_cost, pass_gen_data.vi_exch_rate)
		end

		lst_pur_cost=lst_pur_cost * vdqty
		lst_cost=lst_cost * vdqty
		clear lst_disc, lst_dsp_disc, lst_vi_disc

		clear lst_sett

		lst_retail=vd_rrp(D_FC)*vdqty
		lst_vat=vdvat
		list_type = T$ATTACH

		xcall whgine_attach_cur_val(vdrec, lst_code, pass_gen_data.vi_currency, invoice_totals)

		call calc_vat

		if(.not. lst_sb_type) then
		begin
			; note that adv_t_cost seems to include attachments twice - this is
			; because adv_t_cost for the main item is set to lst_tot_cost which does
			; include attachments
			adv_t_disc += lst_dsp_disc
			adv_t_sett += lst_sett
			adv_t_retail += lst_retail
			adv_t_vat += lst_vat_val
			if((pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL .and.lst_ntype .ne. D_VJ_PART).or.
			&  (pass_chn_data.h_prog_code .eq. P_COD_WGD_VAT_INC.and.lst_ntype .eq. D_VJ_PART))
				adv_t_vat_inc += lst_vat_val
			if .not. lst_cost
				any_zero_cost = true
		end
		else
		begin
			sb_t_cost_bc=sb_t_cost_bc+%f_curr_bc(lst_cost, pass_gen_data.vi_exch_rate)
			sb_t_cost_fc=sb_t_cost_fc+lst_cost
			sb_t_disc=sb_t_disc+lst_disc
			sb_t_retail=sb_t_retail+lst_retail
			sb_t_vat=sb_t_vat+lst_vat_val
		end
		xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
	end
	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       display invoice values
        ;       if the advice has already been invoiced then this info
        ;       can come directly from header, else, from details entered
.subroutine whgine_disp_inv_vals

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'

	external function
		f_curr_fc,      d
		f_ljust,        a

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		disp_line,      a80

.proc

	if(vistat .ge. D_ADV_INVOICED .and. .not.
	&             (pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL
	&             .and. vi_not_sb.eq.D_VI_NOT_SB_PUR_INV)) then
	begin
		if(vi_cr_chrg.and.vi_crst .eq. D_IVT_CRST_CREDIT)
			inv_cred = ((vi_f_totinv * 100000 /
			&     (vi_cr_chrg + 10000)) * vi_cr_chrg)#5
		inv_val = vi_f_totinv - inv_cred
;		set adv_tot_vat, inv_vat = vi_f_totvat

		if(vistat .eq. D_ADV_PRV_PRD)
			disp_line='Pre Period'
		if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL)
			disp_line(%trim(disp_line)+2:2)='SB'
		if(disp_line)
		begin
			disp_line = %f_ljust(disp_line)
		end
	end
	else            ; build invoice values from line details entered
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL) then
		begin
			inv_val = sb_t_cost_fc
			inv_vat = sb_t_vat
		end
		else
		begin
			inv_val = adv_tot_retail - adv_tot_disc
			set inv_vat = adv_tot_vat
			if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL)
				inv_val = inv_val - adv_t_vat_inc
			if(vi_crst .eq. D_IVT_CRST_CREDIT .and. vi_cr_chrg .and. .not.
			&                  (viivcr .and. vi_cr_sett_yn .eq. 'N'))
				inv_cred = ((inv_val) * (10000 + vi_cr_chrg))#4 - (inv_val)
		end
	end
	set inv_vat = adv_tot_vat

	inv_total = inv_val + inv_vat + inv_cred

	if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL) then
		clear adv_inv_total
	else
		set adv_inv_total = inv_total

	inv_nett = inv_val

	adv_deposit_total=fin_deposit_amt+fin_deposit_vat
	adv_px_fin_sett=fin_px_fin_sett

	inv_sbtot = sb_t_cost_fc
	adv_to_pay = adv_inv_total - (sb_t_cost_fc + sb_t_vat)

	adv_to_pay=adv_to_pay - adv_deposit_total

	if(adv_deposit_total.and..not.fin_dep_inv_no) then
		adv_deposit_txt='+ Deposit'
	else
		adv_deposit_txt=

	if(.not.fin_px_acc_same)
		adv_to_pay=adv_to_pay + adv_px_fin_sett

	if(whgine_passed.f_acc_wg_exclude.eq.2) then
		clear inv_prof_v, inv_prof_p
	else
	begin
		inv_prof_v = inv_val - adv_tot_cost
		if(inv_val)
			inv_prof_p = (inv_prof_v * 10000) / inv_val
		else
			clear inv_prof_p
	end
	xcall i_display(inp_vi_id, 'tot_set', whgine_hdr,,,,,,,,,, gold_com,
	&               gold_ax)


	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
.function whgine_dep_val_change ,^val

	a_data_entered       ,a
	a_data_stored        ,n
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'invoice_totals' repository, group='invoice_totals'

	external function
		f_yes_no,       d

	.include "SRC:OPSCOM.REC"
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'

	record general
		fldnam,         a20
		h_val,          d10
		tmp_max,        D10

.proc
	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	if (fldnam.eq.'FIN_DEPOSIT_AMT') then
		h_val = fin_deposit_amt
	else
		h_val = fin_deposit_total

	a_pending_status = %currency_change(a_data_entered,a_data_stored,
	&       a_pending_status,inputinfo,whgine_hdr,gold_com,gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status
	; after conversation with Alan while at Molsons, he said they had
	; a problem where the deposit value provided as unspecified trade in included
	; vat while the adv_t_retail does not.  therefore, include vat in invoice value
	; to check against
	if (pass_chn_data.h_prog_code.eq.P_COD_MACH_NO_SPC_TI)  then
		tmp_max = inv_total
	else
		tmp_max = adv_inv_total - (sb_t_cost_fc + sb_t_vat)

	if (a_data_stored.gt.tmp_max)
	begin
		xcall ibc_message('Invalid - this must not be more than invoice value')
		if (h_val.le.tmp_max) then
			a_data_stored = h_val
		else
			clear a_data_stored
		if (fldnam.eq.'FIN_DEPOSIT_AMT') then
			fin_deposit_amt = a_data_stored
		else
			fin_deposit_total = a_data_stored
		freturn D_EMITTEDERR
	end

	if (fldnam.eq.'FIN_DEPOSIT_AMT') then
	begin
		fin_deposit_amt = a_data_stored
		call calc_vat_and_tot_val
	end
	else
	begin
		fin_deposit_total = a_data_stored
		call calc_dep_and_vat_val
	end

	xcall whgine_calc_px_vals(whgine_inv_tab,whgine_hdr)
	xcall i_display(inp_wndid, 'tot_set', whgine_hdr,,,,,,,,,,
	&               gold_com, gold_ax)

	freturn D_OK

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section is called when the user has changed the deposit
        ;       value and calculates the vat and total values
	calc_vat_and_tot_val,

	clear fin_deposit_vat
	if(pass_chn_data.h_prog_code.ne.P_COD_MACH_NO_SPC_TI.and.cms_country.ne.EIRE_VAT.and.
	&               pass_gen_data.h_vatable.and. pass_gen_data.h_vat_code)
	begin
		xcall whgine_vat_calc(fin_deposit_vat, pass_gen_data.h_vat_code,
		&       vt_vat_code, vt_vrat, fin_deposit_amt,
		&       D_RET_VAT_EXC, D_RET_VAT_VAL)
	end

	fin_deposit_total=fin_deposit_amt+fin_deposit_vat

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section is called when the user overrides the deposit
        ;       and vat total and recalculates the deposit and vat value
	calc_dep_and_vat_val,

	clear fin_deposit_vat

	if(pass_chn_data.h_prog_code.ne.P_COD_MACH_NO_SPC_TI.and.cms_country.ne.EIRE_VAT.and.
	&               pass_gen_data.h_vatable.and. pass_gen_data.h_vat_code)
	begin
		xcall whgine_vat_calc(fin_deposit_vat, pass_gen_data.h_vat_code,
		&       vt_vat_code, vt_vrat, fin_deposit_total,
		&       D_RET_VAT_INC, D_RET_VAT_VAL)
	end
	fin_deposit_amt = fin_deposit_total-fin_deposit_vat

	return

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
.function whgine_sett_val_change ,^val

	a_data_entered       ,a
	a_data_stored        ,n
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'

	external function
		f_yes_no,       d

	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'

	record general
		h_px_fin_sett,  d10
.proc
	h_px_fin_sett=fin_px_fin_sett
	a_pending_status = %currency_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr, gold_com, gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status

	if(.not.a_data_stored.and.fin_px_fin_supp)
	begin
		if( %f_yes_no('Clear Settlement Details? ',,,, false, true) .eq.
		&   D_YES) then
		begin
			clear fin_px_fin_sett
			clear fin_px_fin_supp, fin_supp_nick
			clear fin_px_fin_desc
			clear fin_px_acc_same
		end
		else
		begin
			fin_px_fin_sett=h_px_fin_sett
			freturn D_EMITTEDERR
		end
	end

	xcall whgine_set_px_sett_totals(inp_wndid,whgine_inv_tab,
	&                               whgine_hdr)

	xcall i_display(inp_wndid, 'disp_set', whgine_hdr,,,,,,,,,,
	&               gold_com, gold_ax)

	if(a_data_stored.and..not.fin_px_fin_supp)
	begin
		xcall i_init(inp_wndid, 'tab_set',whgine_hdr, 'FIN_PX_FIN_SUPP')
	end

	if(.not.a_data_stored) then
		xcall i_fldmod(inp_wndid, 'FIN_PX_FIN_SUPP',,,D_OFF,D_FLD_REQUIRED)
	else
		xcall i_fldmod(inp_wndid, 'FIN_PX_FIN_SUPP',,,D_ON,D_FLD_REQUIRED)

	if(.not.a_data_stored) then
		xcall i_next(inp_wndid,'tab_set','*DONE*')
	else
		xcall i_next(inp_wndid,'tab_set', 'fin_px_fin_supp')
	freturn D_OK

.end

.function whgine_fin_supp_change ,^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'

	.include "SRC:OPSCOM.REC"

	external function
		f_curr_fc,      d
		f_ljust,        a
		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal


	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:SMFREC.REC'

	record ids
		err,            i4
.proc

	a_pending_status = %smf_change(a_data_entered,a_data_stored,
	&       a_pending_status,inputinfo,whgine_hdr,gold_com,gold_ax)

	a_data_stored = %f_ljust(a_data_stored)

	if (a_pending_status.ne.D_OK .or. g_entnam.eq.'SMF_LOOKUP'
	&       .or. g_entnam.eq.'I_DRILL')
		freturn a_pending_status

	err=true
	if (a_data_stored)
	begin
		a_data_stored=a_data_stored [RIGHT]
		smf_supp_acc=a_data_stored
		if(.not.smf_supp_acc) then
			clear suprec
		else
		begin
			xcall file(pass_chn_data.chn(SMF_FILE),suprec,smf_supp_acc,'RD',err)
			if(.not.err)
				if(smf_cur_cod.ne.inv_curr)
				begin
					xcall ibc_message('Invalid - Advice currency is '
					&                 +inv_curr+ ' while Supplier currency is '
					&         +smf_cur_cod+'\nThe currencies must be the same')
					err=true
				end
			if(.not.err)
				fin_supp_nick=smf_nickname
		end
	end
	if(err)
	begin
		xcall i_init(inp_wndid, 'tab_set',whgine_hdr, 'FIN_PX_FIN_SUPP')
		freturn D_EMITTEDERR
	end

	if(smf_supp_acc.eq.fin_finance_supacc) then
		fin_px_acc_same='**'
	else
		fin_px_acc_same=

	xcall i_dspfld(inp_wndid,'fin_supp_nick', fin_supp_nick,gold_com)
	xcall i_dspfld(inp_wndid,'fin_px_acc_same', fin_px_acc_same,gold_com)

	xcall whgine_calc_px_vals(whgine_inv_tab, whgine_hdr)

	xcall i_display(inp_wndid, 'disp_set', whgine_hdr,,,,,,,,,,
	&               gold_com, gold_ax)
	freturn D_OK

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       validate Rep for T H Whites
;
.function whgine_aft_rep,^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'

	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMSCOM.REC'

.proc

	a_pending_status = %srp_change(a_data_entered, a_data_stored, a_pending_status, inputinfo, whgine_hdr)

	if (a_pending_status.ne.D_OK .or. (g_select .and.
	&	(g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL' .or. g_entnam.eq.'I_HYPER')) )
		freturn a_pending_status

	; Ernest Doe & Sons Ltd / T.H.Whites
	if ((cms_user_id.eq.10687 .or. cms_user_id.eq.10116).and.
	&       (.not.a_data_stored.or.a_data_stored.eq.'**'))
	begin
		xcall ibc_message('Invalid - A Sales Rep Code must be entered')
		freturn D_EMITTEDERR
	end

	freturn D_OK
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
.subroutine whgine_set_px_sett_totals
	inp_wndid     ,n
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'

.proc

	xcall whgine_calc_px_vals(whgine_inv_tab, whgine_hdr)

	if(fin_px_fin_sett) then
	begin
		xcall ibc_enable(inp_wndid,'FIN_PX_FIN_SUPP')
		xcall ibc_enable(inp_wndid,'FIN_PX_FIN_DESC')
	end
	else
	begin
		xcall ibc_disable(inp_wndid,'FIN_PX_FIN_SUPP')
		xcall ibc_disable(inp_wndid,'FIN_PX_FIN_DESC')
	end
	xreturn

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_calc_px_vals
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'

	.include 'cmfrec' repository, record='cmfrec'
.proc

	fin_deposit_rcv = fin_deposit_total + sb_t_cost_fc + sb_t_vat

	; if the finance company supplier account is the same as
	; supplier a/c for settlement then
	if (fin_px_fin_sett.and..not.fin_px_acc_same)
		fin_deposit_rcv = fin_deposit_rcv - fin_px_fin_sett

	fin_calc_total = inv_total - fin_deposit_rcv

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_vi_i_pm_contract_change,^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:PMHREC.REC'
	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal


	record general
		err,            i4
	literal
	cont_type,              2a9,    '{WHOLEGD}','Plant'
.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL'))
		freturn a_pending_status

	a_pending_status = %pmh_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'PMH_LOOKUP')
		freturn a_pending_status

	if( a_data_entered .eqs. '?' .or..not.a_data_entered)
	begin
		clear a_data_entered, a_data_stored
		xcall m_signal('I_DRILL')
		freturn D_OK
	end
	if(a_data_entered.and.%instr(1,a_data_entered,'?'))
	begin
		xcall m_signal('I_DRILL')
		freturn D_OK

	end
	xcall file(pass_chn_data.chn(PMH_FILE), pmhrec, a_data_stored, 'RD', err,,,,,Q_NO_LOCK)
	if(err)
	begin
		xcall ibc_message('Invalid Contract')
		freturn D_EMITTEDERR
	end
	if(pmh_plant_equipment.ne.vi_i_plant_wgd)
	begin
		xcall ibc_message('Invalid - Invoice Type is for '
		&   +%atrim(cont_type(vi_i_plant_wgd+1))
		&   +' type contract while Contract is '
		&   +%atrim(cont_type(pmh_plant_equipment+1))+' type')
		freturn D_EMITTEDERR
	end

	if(pmh_sal_date_fr.gt.%ndate)
	begin
		xcall ibc_message('Warning - Contract Start Date later than today')
	end

	if(pmh_sal_date_to.and.pmh_sal_date_to.lt.%ndate)
	begin
		xcall ibc_message('Warning - Contract End Date already passed')
	end
	if(.not.vi_cust)
	begin
		xcall i_putfld(inp_wndid,, whgine_hdr, 'vi_cust',
		&              pmh_cust_acc, gold_com)
	end
	if(.not.vi_fcus)
	begin
		xcall i_putfld(inp_wndid,, whgine_hdr, 'vi_fcus',
		&              pmh_fin_acc, gold_com)
	end

	if a_data_stored
	begin
		csp_comacc = vi_cust
		csp_comtype = CMNT_CUSTOMER
		csp_comview = FALSE
		xcall m_signal('J_CHECK')
	end
	freturn D_OK
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_cus_acc_change ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'

	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMSCOM.REC'

.proc
	if( a_pending_status.eq.D_REQERR )
		a_pending_status = D_OK
	a_pending_status = %cmf_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr, gold_com, gold_ax)

	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or. g_entnam .eq. 'J_POST_COD' .or.
	&       g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_NEW_CUS' .or. g_entnam .eq. 'CMF_LOOKUP'))
		freturn a_pending_status

	if a_data_stored
	begin
		csp_comacc = a_data_stored
		csp_comtype = CMNT_CUSTOMER
		csp_comview = FALSE
		xcall m_signal('J_CHECK')
	end
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_vi_not_sb_change ,^val
	a_data_entered       ,a
	a_data_stored        ,n
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

.proc
	; if the deposit invoice trade in type has been selected, then the
	; routine will not allow trade in entry.  If this is changed
	; then the validation routine will check

	if(a_data_stored.eq.D_VI_NOT_SB_PUR_SB)
	begin
		; this section can not be used in conjunction with the following
		; program code as there will need to be trade in items entered
		; while the program code prohibits this.
		if(pass_chn_data.h_prog_code.eq.P_COD_MACH_NO_SPC_TI)
		begin
			xcall ibc_message('Invalid - This selection is not '
			&                 +'applicable where the program code associated'
			&                 +' with the selected invoice type is for\n '
			&                 +T$P_COD_MACH_NO_SPC_TI
			&                 +'.  Purchase {W} Self Billing Invoices".')
			freturn D_EMITTEDERR
		end
	end
	if(a_data_stored.ne.D_VI_NOT_SB_PRT_SB.and.fin_pr_ti_stk[])
	begin
		xcall ibc_message('Invalid - There are Previous Trade in details for this'
		&                 +' advice.  This can not be used in conjunction with'
		&                 +' non self biller options.')
		freturn D_EMITTEDERR
	end

	if((a_data_stored.eq.D_VI_NOT_SB_PUR_INV.or.
	&  a_data_stored.eq.D_VI_NOT_SB_PUR_SB).and..not. pass_chn_data.h_supacc)
	begin
		vi_not_sbill=a_data_stored
		if(.not. pass_chn_data.h_supacc)
		begin
			xcall ibc_message('WARNING - Supplier a/c not set up for the customer.  \n'
			&       +'You will not be able to complete this advice until'
			&       +' a valid supplier is associated with the customer entered.')
		end
	end
	vi_not_sbill=a_data_stored
	xcall whgine_set_prv_tin_fkey(whgine_hdr, fkeys)
	xcall ibc_fkeys(inp_wndid, fkeys)
	freturn D_OK
.end
.subroutine whgine_vi_not_sb_leave
	.include 'WND:inpinf.def'       ; layout for a_inpinfo
	a_inprec,       a
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMFCOM.REC'

	record
		lErr,		i4
		work_field,     d1
		.include 'whgine_hdr' repository, group='whgine_hdr'
.include 'DEF:IBCOS_LEAVE.DEF'

	field_validate,

	whgine_hdr = a_inprec
	xcall whgine_check_cmf_sb_exp_date(vi_not_sbill, cmf_sb_exp_date, vi_idat, lErr)
	return
.end
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	Subroutine to check if self bill expiry date has been reached and warn
	;	user when applicable.  If control file setting cm3_0_sb_exp_expired
	;	is true and the expiry date has not been set then display a warning.
subroutine WHGINE_Check_Cmf_SB_Exp_Date
	req in aPass_Vi_Not_Sb,         n
	req in aPass_Cmf_Sb_Exp_Date,   n
	req in aPass_Inv_date,          n
	req out aError,					n
	endparams

	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM3REC.REC'

	external function
		f_alpha11_date,         a
	endexternal

	record lGeneral
		lWarnId,	i4
		lPassword,	a6
		lMessage,	a60
	endrecord
proc
	init lGeneral
	xcall e_enter
	aError = FALSE
	if (aPass_Vi_Not_Sb == D_VI_NOT_SB_PRT_SB)
	begin
		if (%xf_file( g_com_chn, cm3rec, 3, 'RN',,, Q_NO_LOCK))
			clear cm3rec
		if (aPass_Cmf_Sb_Exp_Date)
		begin
			if (aPass_Cmf_Sb_Exp_Date < %max(%ndate, aPass_Inv_Date))
				xcall s_bld(lMessage,, 'Self Bill Invoice Expiry Date Applicable: %a', %f_alpha11_date(aPass_Cmf_Sb_Exp_Date))
		end
		else
			if (cm3rec.cm3_0_sb_exp_expired)
						   ;123456789012345678901234567890123456789012345678901234567890
				lMessage = 'Self Bill Invoice Expiry Date is not set for customer'
		if (lMessage)
		begin
			if (cm3rec.cm3_sb_exp_date_pwd)
			begin
				xcall ibc_ldinp(lWarnId, g_utlib, 'whgine_sb_exp_d', D_NOPLC,,,, TRUE,, D_NO_DEF_BTNS)
				xcall i_dspfld(lWarnId, 'sb_exp_date', lMessage)
				.ifdef D_GUI
					xcall ibc_window(D_PLACE, lWarnId, 10, COL_CENTER(lWarnId))
				.else
					xcall ibc_window(D_PLACE, lWarnId, 8, COL_CENTER(lWarnId))
				.endc
				aError = %get_password(cm3rec.cm3_sb_exp_date_pwd, , 'Self Bill Expiry Date Password')
			end
			else
			begin
				xcall ibc_message('WARNING - ' + %atrim(lMessage))
			end
		end
	end
	xcall e_exit
	xreturn
endsubroutine
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	check each wholegood on the advice note. If this is an invoice
	;	check the wholegood status code.  if it is the type 39 status
	;	check the operator has autohority to do this. Even if they do
	;	display message to this effect
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
function whgine_check_39_status, ^val
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	endparams

	; global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	external function
		f_chk_access,  d
	endexternal

	record lGeneral
		.include 'cm3rec' repository, group='lCM3Rec'
		.include 'vjrec' repository, group='lVJRec'
		.include 'vmrec' repository, group='lVMRec'
		lReturnError,	int
	endrecord
proc
	init lGeneral
	; ensure the cm3 record is blank to force the read
	clear lCM3Rec
	if (whgine_hdr.whgine_vi_grp.vi_iorc == D_VIIVCR_INVOICE ||
	&   whgine_hdr.whgine_vi_grp.vi_iorc == D_VIIVCR_PART_INV)
	begin
		data lAccess39,		int, 99
		data lFileError,	int
		data lStatLoop,		int
		xcall file(pass_chn_data.chn(VJ_FILE), lVJRec, whgine_hdr.whgine_vi_grp.vi_job, 'FI', lFileError)
		repeat
		begin
			xcall file(pass_chn_data.chn(VJ_FILE), lVJRec, , 'RS', lFileError, , , , , D_NO_LOCK)
			if (lFileError || lVJRec.vjjob != whgine_hdr.whgine_vi_grp.vi_job)
				exitloop
			if (lVJRec.vjnstk != D_VJ_WGD)
				nextloop

			xcall file(pass_chn_data.chn(VM_FILE), lVMRec, lVJRec.vjtstk, 'RD', lFileError, , , , , D_NO_LOCK)
			; If there is an error, presume  partial invoice with main item already sold (therefore in history
			; and thereore irrelevant so skip)
			if (lFileError)
				nextloop
			if (! lCM3Rec)
				xcall file(g_com_chn, lCM3Rec, 3, 'RN', lFileError, , , , ,D_NO_LOCK)

			for lStatLoop from 1 thru 12
				if (lVMRec.vmstat == lCM3Rec.cm3_gnvhss(lStatLoop) && lCM3Rec.cm3_gnvhsf(lStatLoop) == 2)
				begin
					data lErrorText,	a200
					; process to invalidate vmstat selected type is 2 (access
					; level 39 required) and user does not have this
					if (lAccess39 == 99)
						lAccess39 = %f_chk_access(39)
					xcall s_bld(lErrorText, ,
					&	'{WHOLEGD} %a: Status Code is set to %a (%a) with Allow to Sell only with access level 39.'
					&	, lVMRec.vmstok, lCM3Rec.cm3_gnvhss(lStatLoop), lCM3Rec.cm3_gnvhsd(lStatLoop))
					if (! lAccess39)
						lErrorText = %atrim(lErrorText)
						&  + ' Your current login does not have access level 39 set so cannot continue.'
					else
						lErrorText = %atrim(lErrorText) + ' Warning only as you have this level of access.'
					xcall ibc_message(%atrim(lErrorText))
					if (! lAccess39)
						lReturnError = true
					exitloop
				end
			if (lReturnError == true)
				exitloop
		end
	end
	freturn lReturnError

endfunction
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; if settlement days has not been set but there is some settlement
	; discount, this is invalid
function whgine_check_settlement, ^val
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	endparams

	; global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	.include 'SRC:OPSCOM.REC'

	record lGeneral
		.include 'vjrec' repository, group='lVJRec'
		lReturnError,	int
		lErrorText,		a250
	endrecord
proc
	init lgeneral
	if (whgine_hdr.whgine_vi_grp.vi_iorc == D_VIIVCR_INVOICE ||
	&   whgine_hdr.whgine_vi_grp.vi_iorc == D_VIIVCR_PART_INV)
	begin
		data lFileError,	int
		; first check header and if the percentageisnon zerfo,invalidate as we
		; know already that the days is zero
		if (whgine_hdr.whgine_vi_grp.vi_cr_chrg_inp)
		begin
			xcall s_bld(lErrorText, ,
			&	'Invalid - there is a settlement discount of %a% specified on the advice header'
			&   ' but no settlement days.\n'
			& +	'You need to either enter the settlement days or clear the settlement discount value before'
			& +	' the invoice can be printed.', %string(whgine_hdr.whgine_vi_grp.vi_cr_chrg_inp, 'ZX.XX'))
			lReturnError = true
		end
		if (lReturnError)
			exit
		xcall file(pass_chn_data.chn(VJ_FILE), lVJRec, whgine_hdr.whgine_vi_grp.vi_job, 'FI', lFileError)
		repeat
		begin
			xcall file(pass_chn_data.chn(VJ_FILE), lVJRec, , 'RS', lFileError, , , , , D_NO_LOCK)
			if (lFileError || lVJRec.vjjob != whgine_hdr.whgine_vi_grp.vi_job)
				exitloop

			if (lVJRec.vjnstk == D_VJ_COMMENT)
				nextloop

			if (vj_f_sett)
			begin
				if (lVJRec.vjnstk == D_VJ_PART)
					xcall s_bld(lErrorText, ,
					&	'Invalid - there is a settlement discount for Part %a but no settlement days.\n'
					& +	'You need to either enter the settlement days or clear the settlement discount value before'
					& +	' the invoice can be printed.', lVJRec.vj_spec_01)
				else
					xcall s_bld(lErrorText, ,
					&	'Invalid - there is a settlement discount for {WHOLEGD} %a but no settlement days.\n'
					& +	'You need to either enter the settlement days or clear the settlement discount value before'
					& +	' the invoice can be printed.', lVJRec.vjtstk)
				xcall ibc_message(%atrim(lErrorText))
				lReturnError = true
				exitloop
			end
		end
	end
	if (lReturnError)
		xcall ibc_message(%atrim(lErrorText))

	freturn lReturnError
	endfunction

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.function whgine_fcus_acc_change ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'


.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_NEW_CUS'))
		freturn a_pending_status

	a_pending_status = %cmf_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr, gold_com, gold_ax)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'CMF_LOOKUP')
		freturn a_pending_status

	clear fin_finance_supdes, fin_finance_supacc, fin_px_acc_same

	if a_data_stored
	begin
		if a_data_stored .eq. vi_cust
		begin
			xcall ibc_message(T$INVAL_FCUS)
			clear a_data_stored
			freturn D_EMITTEDERR
		end
		cmf_acc_no = a_data_stored
		xcall whgine_get_customer_dets

		; WG7283 - CURRENCY FOR CUST AND FCUS MUST MATCH
		if(cmf_cur_cod.ne.inv_curr)
		begin
			xcall ibc_message('Invalid - The finance company currency is '+cmf_cur_cod
			&               + ' while the customer account currency is '+inv_curr+' - the currencies must match')
			clear cusrec
			a_data_stored=cmf_acc_no
		end
	end
	else
		clear cusrec

	xcall whgine_set_finance_co_fields(inp_wndid, whgine_hdr, gold_com, whgine_passed)

	freturn D_OK
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_finance_co_fields
	inp_wndid,      n
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'whgine_passed' repository, group='whgine_passed'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	.include 'SRC:CMFCOM.REC'
	record general
		add_line4,      a32
.proc

	vi_fcus = cmf_acc_no
	vi_fcusacc = cmf_acc_no
	vi_finnam = cmf_name
	if .not. pass_gen_data.plan_maint
	begin
		xcall i_putfld(inp_wndid, 'disp_set', whgine_hdr, 'vi_fcus',
		&              vi_fcus, gold_com)
		xcall i_putfld(inp_wndid, 'disp_set', whgine_hdr, 'vi_finnam',
		&            vi_finnam, gold_com)

		xcall i_putfld(inp_vi_id, 'adv_set', whgine_hdr,'vi_fcusacc',vi_fcusacc,gold_com)
		xcall i_putfld(inp_vi_id, 'adv_set', whgine_hdr,'vi_finnam',vi_finnam,gold_com)
	end

	xcall i_putfld(hdr_cust_id, 'disp_set', whgine_hdr, 'vi_finadd1',
	&                  cmf_address1, gold_com)
	xcall i_putfld(hdr_cust_id, 'disp_set', whgine_hdr, 'vi_finadd2',
	&                  cmf_address2, gold_com)
	xcall i_putfld(hdr_cust_id, 'disp_set', whgine_hdr, 'vi_finadd3',
	&                  cmf_address3, gold_com)
	if (cmf_address4) then
		xcall s_bld(add_line4,,'%a%a %a',cmf_address4,',',cmf_post_cd)
	else
		add_line4 = cmf_post_cd
	xcall i_putfld(hdr_cust_id,'disp_set',whgine_hdr,'vi_finadd4',
	&                  add_line4,gold_com)

	xcall whgine_set_finance_supacc(whgine_hdr)
	if .not. pass_gen_data.plan_maint
	begin
		xcall i_putfld(inp_wndid, 'disp_set', whgine_hdr, 'fin_finance_supacc',
		&          fin_finance_supacc, gold_com)
		xcall i_putfld(inp_wndid, 'disp_set', whgine_hdr, 'fin_finance_supdes',
		&          fin_finance_supdes, gold_com)
	end

	; reset customer record to that of the customer
	cmf_acc_no = vi_cust
	xcall whgine_get_customer_dets
	xcall m_signal('J_FCUS')
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       set up the vi input fields
.subroutine set_vi_fields

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'wgd_deladd' repository, group='aWgd_del_add'
endparams

	.include 'SRC:VICOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:WQHREC.REC'
	.include 'SRC:FCFREC.REC'

	.include 'SRC:SMFREC.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3
		rep_prompt,     a9
		loop,           d1
		filename,       a D_FILENAME_LEN

	record ifours
		gen_channel,    i4

.proc
	clear whgine_vi_grp, gen, ^i(ifours)

	vi_job=vijob
	vi_iorc=viivcr
	vi_inv_typ=vi_ityp
	xcall whgine_get_inv_type(gold_com, gold_ax, whgine_hdr, whgine_passed)

	vi_narr=vinarr

	vi_cust=vicust
	cmf_acc_no=vi_cust
	xcall whgine_get_customer_dets
	xcall s_bld( rep_prompt,,T$REP_PROMPT, cmf_rep )
	xcall i_prompt(inp_hdr_id,'vi_rep',rep_prompt)

	
	if( cmf_inv_mthd == CMF_INV_MTHD_CASH && vi_cus_name)
	begin
		vi_cusnam = vi_cus_name
		vi_cusadd[] = vi_cus_add[]
	end
	else
	begin
		vi_cusnam = cmf_name
		vi_cusadd[] = cmf_address[]
		if (cmf_address4)
		begin
			xcall s_bld(vi_cusadd[4], , '%a%a %a', cmf_address4, ',', cmf_post_cd)
		end
		else
		begin
			vi_cusadd[4] = cmf_post_cd
		end
	end

	set pass_gen_data.h_vatreg, vi_vatreg=cmf_vat_no
	set pass_gen_data.h_vatable, vi_vatable=cmf_vat

	; special for J Brock & Son - if purchase self bill type, always
	; set related supplier a/c to 1999
	if(cms_user_id.eq.10647.and.vi_not_sb.eq.D_VI_NOT_SB_PUR_SB) then
		pass_chn_data.h_supacc=1999
	else
		pass_chn_data.h_supacc=cmf_pur_acc

	vi_fcus=vifcus
	cmf_acc_no=vi_fcus
	xcall whgine_get_customer_dets

	fin_deposit_status=vi_deposit_status
	fin_deposit_amt=vi_deposit_amt
	fin_deposit_vat=vi_deposit_vat
	fin_deposit_total=vi_deposit_total
	fin_deposit_desc[]=vi_deposit_desc[]
	fin_px_fin_sett=vi_px_fin_sett
	fin_px_fin_supp_d1=vi_px_fin_supp
	fin_px_fin_desc[]=vi_px_fin_desc[]
	fin_dep_inv_no=vi_dep_inv_no
	fin_dep_inv_date=vi_dep_inv_date

	xcall whgine_set_finance_supacc(whgine_hdr)

	; note, if internal holding customer = finance co entered, then take the
	; vat details from that account and not the actual customer.
	if(cms_wg_cus_hold.and.cms_wg_cus_hold.eq.vi_fcus)
	begin
		set pass_gen_data.h_vatreg, vi_vatreg=cmf_vat_no
		set pass_gen_data.h_vatable, vi_vatable=cmf_vat
	end

	vi_finnam=cmf_name
	for loop=1 until 4 do vi_finadd(loop)=cmf_address(loop)

	vi_cord=viord
	vi_req_dt=vi_req_date
	vi_rep=virep
	vi_dep=vi_depot
	xcall get_dep_code(vi_dep,,vi_dep_des,err)
	vi_fpro=vifpro
	vi_fpedat=vi_fp_edate
	vi_idat=viidat
	xcall get_445_inv_date(vi_idat)

	vi_sett=visett
	vi_ddat=viddat

	vi_crst_inp=vi_crst
	vi_cr_chrg_inp=vi_cr_chrg

	vi_not_sbill=vi_not_sb

	; if item has already been invoiced and the set delivery address
	; to customer address flag is set, then if updates done
	; to the delivery address, will need to clear the flag
	if(vistat .ge. D_ADV_INVOICED .and. vi_cmf_add_in_dela) then
		clear wgd_deladd[], wgd_del_postcode
	else
	begin
		wgd_deladd[] = videla[]
		wgd_del_postcode = vi_del_postcode
	end

	vi_stok = vistok
	vi_tigr = vitigr

	vi_def_md_group=vi_md_group
	vi_md_group=vi_def_md_group

	fin_pr_ti_stk[]=vi_prv_ti_stk[]

	vi_i_pm_contract=vi_pm_contract
	vi_comm_buy_sp=vi_comm_buy_split

	clear vi_quo_no, vi_quo_date
	xcall whgine_get_quote_dets(gold_com, vi_quote, vi_quo_date)
	if (vi_quo_date)
		vi_quo_no = vi_quote
	if(vi_quo_no) then
	begin
		xcall i_prompt(inp_hdr_id,'vi_quo_no',  'Quote No:')
		xcall i_prompt(inp_hdr_id,'vi_quo_date','Created:')
	end
	else
	begin
		xcall i_prompt(inp_hdr_id,'vi_quo_no',' ')
		xcall i_prompt(inp_hdr_id,'vi_quo_date',' ')
	end

	if(vistat.lt.D_ADV_INVOICED)
	begin
		if(vi_sell_cur.ne.fcf_code)
			xcall disp_curr(vi_sell_cur)
		vi_cur_cnv=fcf_std_rate
	end
	set inv_curr, pass_gen_data.vi_currency=vi_sell_cur
	pass_gen_data.vi_exch_rate=vi_cur_cnv
	pass_gen_data.h_status=vistat
	pass_gen_data.h_ivcr=viivcr

	h_acc=vi_cust
	h_invtyp=vi_ityp

	cmf_acc_no=vi_cust              ; reset customer details to main customer
	xcall whgine_get_customer_dets

	xcall whgine_set_invoice_to_account(inp_hdr_id, cmf_inv_acc,
	&                                   pass_chn_data.chn(CMF_FILE), whgine_hdr)

	xcall ibc_disable(inp_vi_id, 'vi_job')
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
subroutine whgine_get_quote_dets
	.include 'gold_com' repository, req in group='aGoldCom'
	req in aPassQuoteNo,          a
	req out aReturnDate,          n
	opt out aReturnCust,          a
	opt out aReturnNick,          a
	opt out aReturnStatus,        n
	endparams

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:WQHREC.REC'

	record lGeneral
		lFilename,       a D_FILENAME_LEN
		lWQHChn,    	int
		lError,			int
	endrecord
proc
	init lGeneral
	if (cms_wg_quotations && aPassQuoteNo)
	begin
		lFilename = wqhfile
		lFilename(8:3) = aGoldCom.cur_company, 'XXX'
		xcall u_open(lWQHChn, 'I:I', lFilename,,,lError)
		if (! lError)
		begin
			lError = %xf_file(lWQHChn, wqhrec, aPassQuoteNo, 'RD')
			if (! lError)
			begin
				aReturnDate = wqhrec.wqh_cre_date
				if (%passed(aReturnCust))
					aReturnCust = wqhrec.wqh_cust
				if (%passed(aReturnNick))
					aReturnNick = wqhrec.wqh_cust_nick
				if (%passed(aReturnStatus))
					aReturnStatus = wqhrec.wqh_status
			end
			xcall u_close(lWQHChn)
		end
	end

	xreturn

endsubroutine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_get_inv_type

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:IVTCOM.REC'
	.include 'SRC:CMSCOM.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3
.proc
	clear ivtrec, gen
	err = 1
	if(vi_inv_typ)
	begin
		xcall file(pass_chn_data.chn(IVT_FILE),ivtrec,vi_inv_typ,'RD',err)
		if(err)
		begin
			clear ivtrec
			ivt_desc='Invoice Type Not Found'
		end
		;            if trade used car sales the to all intents and purposes
		;            for this routine, this is used car sales therefore, now
		;            used stored version of prog code
		pass_chn_data.h_prog_code=ivt_prog_code

		if(cms_country.eq.EIRE_VAT) then
			pass_gen_data.h_vat_code=ivt_vat_code
		else
			pass_gen_data.h_vat_code=cms_uk_def_vat

		if(pass_chn_data.h_prog_code.eq.P_U_CAR_SAL_TRD) pass_chn_data.h_prog_code=P_COD_CAR_SAL
		if(pass_gen_data.plan_maint)
		begin
			vi_i_plant_wgd=ivt_pm_plant_link
		end
	end
	xcall set_self_bill_vat_codes(whgine_passed)

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       reads the customer file
.subroutine whgine_get_customer_dets

	.include 'SRC:CMFCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM5REC.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3
		loop,           d1

.proc
	err = TRUE
	if(.not.cmf_acc_no) then
		clear cusrec
	else
	begin
		xcall file(pass_chn_data.chn(CMF_FILE),cusrec,cmf_acc_no,'RD',err,,,,,Q_NO_LOCK)
		if(err) then
		begin
			clear cusrec
			cmf_name='Account not found'
		end
	end
	; if invoice already, and hold fields for vat (or delivery address flag cos this change
	; was added at around the same time as vat store) then take the values
	; from the held values in case the customer details have changed.
	if(cmf_acc_no.and.cmf_acc_no.ne.vifcus.and.
	&       vistat.ge.D_ADV_INVOICED.and.
	&       (vi_cmf_vat.or.vi_cmf_vat_no.or.(viaddr.and.vi_cmf_add_in_dela)))
	begin
		xcall file( g_com_chn, cm5rec, 5, 'RN', err,,,,,D_NO_LOCK)
		if(cm5_wg_orig_add.eq.false) exit

		cmf_vat=vi_cmf_vat
		cmf_vat_no=vi_cmf_vat_no

		if(viaddr.and.vi_cmf_add_in_dela)
		begin
			cmf_name=videla[1]
			clear cmf_address[]
			for loop from 1 thru 4
			begin
				cmf_address[loop]=videla[loop+1]
			end
			cmf_post_cd = vi_del_postcode
		end
	end

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       having established there is a finance a/c, this routine
        ;       reads the supplier record and fills in supplier info which
        ;       is displayed on the header tab (and some that isn't)
.subroutine whgine_set_finance_supacc
	.include 'whgine_hdr' repository, group='whgine_hdr'

	.include 'SRC:CMFCOM.REC'
	.include 'SRC:SMFREC.REC'

	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3

.proc
	fin_finance_supacc=cmf_pur_acc
	clear fin_finance_supdes
	if(fin_finance_supacc)
	begin
		xcall file(pass_chn_data.chn(SMF_FILE),suprec, fin_finance_supacc, 'RD', err)
		if(.not.err) fin_finance_supdes=smf_nam
	end
	if(fin_px_fin_supp_d1.and.fin_px_fin_supp_d1.eq.fin_finance_supacc) then
		fin_px_acc_same='**'
	else
		fin_px_acc_same=
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_invoice_to_account

	inp_vi_id,      n
	inv_to_acc,     a
	cmf_chn,        n
	.include 'whgine_hdr' repository, group='whgine_hdr'
	endparams

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	.include 'cmfrec' repository, record = 'cmfrec'
	.align
	record ids
		tmp_ignore_ivacc,       d1
		err,            i4
.proc
	xcall whgine_set_vi_ignore_ivacc(tmp_ignore_ivacc)

	if(inv_to_acc.and..not.tmp_ignore_ivacc) then
	begin
		xcall i_prompt(inp_vi_id, 'vi_ivacc','Inv A/c:')
		xcall file(cmf_chn, cmfrec, inv_to_acc,'RD', err,,,,,Q_NO_LOCK)
		if(err)
		begin
			cmf_acc_no=inv_to_acc
			cmf_name='INVOICE TO ACCOUNT '+inv_to_acc+' NOT FOUND'
		end
		vi_ivacc=cmf_acc_no
		vi_ivnam=cmf_name
		vi_vatreg=cmf_vat_no
		vi_vatable=cmf_vat
		pass_gen_data.h_vatreg = cmfrec.cmf_vat_no
		pass_gen_data.h_vatable = cmfrec.cmf_vat
	end
	else
	begin
		clear vi_ivacc
		clear vi_ivnam
		xcall i_prompt(inp_vi_id, 'vi_ivacc',' ')
	end
	xcall i_dspfld(inp_vi_id, 'vi_ivacc', vi_ivacc)
	xcall i_dspfld(inp_vi_id, 'vi_ivnam', vi_ivnam)
	xcall i_dspfld(inp_vi_id, 'vi_vatreg', vi_vatreg)
	xcall i_dspfld(inp_vi_id, 'vi_vatable', vi_vatable)
	xreturn
.end

.subroutine whgine_trd_load
	a_listid           ,n
	a_request          ,n
	.include 'whgine_vb' repository, group='whgine_vb'
	a_inpid            ,n
	a_disabled         ,n      ;optional
	a_itemindex        ,n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	;end of argument list

	.include "WND:tools.def"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:PMFREC.REC'
	.include 'SRC:PDFREC.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:HIDREC.REC'
	.include 'SRC:VMREC.REC'

	.include 'SRC:HORT.CMN'

	external function
		f_curr_prt,     d
		f_curr_std,     d
		f_curr_bc,      d
		f_curr_fc,      d

		;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4


	.align
	static record general
		.include 'whgine_lst' repository, group='whgine_lst'
		err,            d3
		search,         d1
		first_time,     d1
		tmp_rate,       d4

	record ids
		loop,           i4

.proc

	xcall i_ldinp(seq_linp_id, g_utlib, 'whgine_lstinp', D_NOPLC, search,,
	&             'whgine_lst')
	case a_request of
	begincase
		;D_LLOADBOT:
		begin
			if a_itemindex .eq. 1
			begin
				clear f_attach
				first_time = true
			end
			call load_trd
		end

		;D_LLOADTOP:
		a_request = D_LEOF

	endcase

	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_trd,
	repeat
	begin
		if .not. f_attach
		begin
			if first_time
			begin
				xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err)
				clear first_time
			end
			else
				xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err)

			; next line is workaround for synergex bug
			xcall lp_setup(a_listid)

			if err then
			begin
				a_request = D_LEOF
				exitloop
			end

			if whgine_lst.lst_ntype .ne. D_VJ_TRADE
				nextloop

			f_attach = attach_ll .nes. ''

			clear whgine_vb ; input screen for trade ins (self billers)
			vb_wg_attach = false
			vb_has_attach = f_attach
			if f_attach
				first_time = true

			vb_tstk = lst_tstk
			vb_sbin = lst_sbin

			vb_grp = lst_grp
			xcall whgine_get_group(vb_grp, vb_grpdes,,,,,
			&       vb_book_wd_p, vb_est_rep_p, vb_est_warr_p)


			vb_mak = lst_mak
			xcall whgine_get_make(vb_mak, vb_makdes)

			vb_code = lst_code
			vb_tmod = lst_model

			vb_used = lst_used
			vb_type = lst_type

			for loop from 1 thru 10
				vb_spec(loop) = lst_spec(loop)

			vb_ser = lst_ser
			vb_reg = lst_reg
			vb_dreg = lst_reg_dat
			vb_clok = lst_clok
			vb_yr = lst_year
			vb_tip_bc = lst_dsp_cost
			vb_tip_fc = lst_cost
			vb_h_tip_bc=vb_tip_bc
			vb_net_bc = lst_dsp_cost-%f_curr_bc( lst_disc, pass_gen_data.vi_exch_rate )
			vb_net_fc = lst_cost-lst_disc
			vb_rrp_fc = lst_retail
			vb_rrp_bc = %f_curr_bc( vb_rrp_fc, pass_gen_data.vi_exch_rate )

			vb_oa_fc = vb_tip_fc - vb_net_fc
			vb_oa_bc = vb_tip_bc - vb_net_bc
			vb_vat = lst_vat
			vb_hide_ln = lst_hide
			vb_hide_att = lst_hide_att
			vb_atd_ord_qty = lst_qty
			vb_wash_comp = lst_wash_comp
			vb_e_repairs_bc=lst_est_repairs
			vb_e_warr_bc=lst_est_warr
			if pass_gen_data.vi_currency .ne. cms_base_cur
			begin
				vb_e_repairs_fc = %f_curr_fc( vb_e_repairs_bc, pass_gen_data.vi_exch_rate)
				vb_e_warr_fc = %f_curr_fc( vb_e_warr_bc, pass_gen_data.vi_exch_rate)
			end

			vb_attach_num = lst_attach_num
			vb_qualify = lst_qual
			vb_prev_batch = lst_prev_batch
			vb_moded = lst_moded
			vb_part_code = lst_tstk + ' ' + lst_code

			vb_est_pdi_cost_bc = lst_est_pdi_cost
			vb_est_prt_pdi_cost_bc = lst_est_prt_pdi_cost
			vb_est_pdi_hours = lst_est_pdi_hours

			pass_chn_data.h_stok = vb_tstk
			xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
		end
		else
		begin
			if first_time then
			begin
				xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
				clear first_time
			end
			else
				xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
			if err
			begin
				clear f_attach, first_time
				nextloop
			end
			vb_atd_ord_qty = vdqty

			if(vd_cost[D_FC].gt.vd_est_cos[D_FC].or.vd_fin_inv) then
			begin
				vb_tip_bc = vd_cost[D_BC]
				vb_tip_fc = vd_cost[D_FC]
				vb_net_bc = vd_cost[D_BC]
				vb_net_fc = vd_cost[D_FC]
			end
			else
			begin
				vb_tip_bc = vd_est_cos[D_BC]
				vb_tip_fc = vd_est_cos[D_FC]
				vb_net_bc = vd_est_cos[D_BC]
				vb_net_fc = vd_est_cos[D_FC]
			end

			vb_wg_attach = true
			vb_has_attach = f_attach
			vb_tstk = vdastk
			vb_astk = vjtstk
			vb_code = vdcode
			vb_rrp_bc = vd_rrp_02
			vb_rrp_fc = vd_rrp_01
			vb_grp = vd_gcod

			xcall whgine_get_group(vb_grp, vb_grpdes)

			vb_mak = vd_make
			xcall whgine_get_make(vb_mak, vb_makdes)
			vb_tmod = vd_model
			vb_ser = vdser
			if (.not. pass_gen_data.h_vatreg .or. .not. pass_gen_data.h_vatable)
			begin
				if (.not.vdvat)
				begin
					if (.not. pass_gen_data.h_vatable) then
						vdvat=pass_gen_data.sb_vat_zero
					else
						vdvat=pass_gen_data.sb_vat_code
				end
				xcall f_vat_rate(vdvat, tmp_rate, true)
				if (tmp_rate)
					vdvat=pass_gen_data.sb_vat_zero
			end
			vb_vat = vdvat
			vb_atd_ord_qty = vdqty
			vb_prev_batch = lst_prev_batch
		end

		xcall i_display(a_inpid,, whgine_vb,,,,,,,,,, gold_com,
		&             gold_ax)
		exitloop
	end
	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       check a vm_record exists
subroutine check_vm_exists

	.include 'whgine_passed' repository, group='whgine_passed'
	a_exists,       a
	a_rfa,          a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3
		lLockRec,		d3
	endrecord
proc
	clear a_exists
	xcall file(pass_chn_data.chn(VM_FILE), vmrec, pass_chn_data.h_stok, 'RD', err, , a_rfa, , , D_NO_LOCK)
	if (err)
	begin
		xcall file(pass_chn_data.chn(HM_FILE), vmrec, pass_chn_data.h_stok, 'RD', err, , a_rfa, , , D_NO_LOCK)
		if(.not.err) a_exists='H'
	end
	else
		a_exists='S'
	if (! a_exists)
		clear vmrec
	else
	begin
		case f_lock_vm of
		begincase
		0:	nop
		1:	begin
				if (a_exists == 'S')
					xcall file(pass_chn_data.chn(VM_FILE), vmrec, pass_chn_data.h_stok, 'RD', err, , , , a_rfa)
				else
					xcall file(pass_chn_data.chn(HM_FILE), vmrec, pass_chn_data.h_stok, 'RD', err, , , , a_rfa)
			end
		2:	begin
				if(a_exists.eq.'S')
					xcall file(pass_chn_data.chn(VM_FILE), vmrec, pass_chn_data.h_stok, 'RD', err, , , lLockRec, a_rfa)
				else
					xcall file(pass_chn_data.chn(HM_FILE), vmrec, pass_chn_data.h_stok, 'RD', err, , , lLockRec, a_rfa)
				if (err || lLockRec)
					clear a_exists
			end
		endcase
	end

	clear f_lock_vm
	xreturn
endsubroutine

.subroutine whgine_proc_trd

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group='whgine_vb'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMREC.REC'
	.include 'SRC:FCFREC.REC'

	external function
		f_format_money, a

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		.include 'vm_user' repository, group='vm_user'
		err,            d3
		disp_line,      a90
		rtn_to_seq,     d1
		edit_opts,      a6
		yes_no_ans,     d1

	record ifours
		req,            i4

.proc
	clear gen, ^i(ifours)
	edit_opts = 'IAD'

	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	if pass_gen_data.adv_mode .eq. D_VEW_MODE then
		edit_opts = 'IADV'
	else
	begin
		if seq_inserting
		begin
			roll_input = D_INS_MODE
			rtn_to_seq = true
			edit_opts = 'IADE'
		end
		if do_find
		begin
			rtn_to_seq = true
			roll_input = D_AMD_MODE
			edit_opts = 'IADE'
		end
	end

	if reseq_req[D_VJ_TRADE+1]
	begin
		xcall lbc_restart(a_wndid)
		reseq_req[D_VJ_TRADE+1] = false
		xcall l_queue( a_wndid, D_LBOTTOM, D_LTOP )
		req = D_LTOP
		call vb_list_process
	end

	if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL .and. .not. (vi_stok .or. vi_tigr))
	begin
		disp_line = 'Warning - Main Washout Stock Number Not Set - Enter Now?'
		yes_no_ans = D_NO
		xcall yes_no(%atrim(disp_line), yes_no_ans, 10)
		if(yes_no_ans .eq. D_YES)
		begin
			xcall whgine_washout_scn(gold_com, gold_ax, whgine_passed,
			&                              whgine_hdr)
			req = D_LRESTORE
			call vb_list_process
		end
	end

	call display_vb_screen

	if do_find then
		req = D_LFIND
	else
		req = D_LNOP
	call vb_list_process

	; allow trade ins in partial inv entry
	fkeys[TRD_FKEYS].fkey[D_FK_NO2].disabled_flg = (.not.
	&   ((line_count .or. pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL)
	&  .and. vi_iorc .ne. D_VIIVCR_PART_CRED)).or.whgine_passed.f_vsp_exists
	if (pass_gen_data.adv_mode == D_VEW_MODE)
	begin
		fkeys[TRD_FKEYS].fkey[D_FK_NO3].disabled_flg = true
		fkeys[TRD_FKEYS].fkey[D_FK_NO4].disabled_flg = true
	end

	call display_vb_screen
	disp_line = 'Trade In'

	if( pass_gen_data.adv_mode .ne. D_VEW_MODE .and.
	&  .not.(cms_country.eq.SAUDI_ARABIA.or.cms_country.eq.NO_VAT))
	begin
		if(.not. pass_gen_data.h_vatable) then
			xcall ibc_message(
			&                       'Warning - VAT is not applicable for this customer')
		else
			; WG7433         if(.not.vi_vatreg.and.cms_country.eq.UK_VAT)
			if(.not.vi_vatreg.and.(cms_country.eq.UK_VAT.OR.cms_country.eq.EIRE_VAT))
			begin
				xcall ibc_message('Warning - '
				&               +'No Vat Registration Number For This Customer. '
				&               +'VAT Will Not Be Applied to Trade Ins.')
			end
	end

	repeat
	begin
		err = %listiad_proc(trd_lst_id, trd_linp_id, whgine_vb,
		&       0, 'vb_inpset',,, 'whgine_trd_init', 'whgine_trd_upd',
		&       'whgine_trd_mnu', 'whgine_trd_prc', roll_input, disp_line, edit_opts,
		&       fkeys[TRD_FKEYS], fkeys[TRD_INP_FKEYS], gold_com, gold_ax, whgine_passed,
		&       fkeys, whgine_lst, whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)
		if err .eq. D_LIST_TERMINATED
			exitloop
		if g_select
		begin
			case g_entnam of
			begincase
				'J_QUIT':         exitloop
			endcase
			else
				exitloop
		end
	end
	xcall ibctab_highlight(tabset_id, false)
	if rtn_to_seq
		xcall m_signal('SEQ_TAB')
	clear do_find, seq_inserting, rtn_to_seq, roll_input
	if(fkeys[TRD_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[TRD_FKEYS].fkmnu_id)
	if(fkeys[TRD_INP_FKEYS].fkmnu_id)
		xcall ibc_column(D_REMOVE, fkeys[TRD_INP_FKEYS].fkmnu_id)
	xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	vb_list_process,

	xcall l_process(trd_lst_id, req, whgine_vb,, gold_com, gold_ax,
	&               fkeys[TRD_FKEYS], whgine_passed, fkeys, whgine_lst,
	&               whgine_hdr, whgine_inv_tab, add_part_passed, invoice_totals)

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	display_vb_screen,
	xcall i_snapshot(D_LOAD, pass_gen_data.inp_vb_id, trd_snap)

	if(.not.f_wg_mv_comm) then
	begin
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_full_set',
		&            'vb_book_wd_bc')

		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_full_set',
		&            'vb_e_repairs_bc,vb_e_warr_bc')
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_inpset',
		&            'vb_e_repairs_bc,vb_e_warr_bc')
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_full_set',
		&           'vb_book_wd_p,vb_est_rep_p,vb_est_warr_p')
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_rrp_bc','Retail Price:')

		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_book_wd_bc','')
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_e_repairs_bc','')
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_e_warr_bc','')
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_book_wd_p','')
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_est_rep_p','')
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_est_warr_p','')
	end
	else
	begin
		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_rrp_bc','Market Value(RRP):')

		xcall i_prompt(pass_gen_data.inp_vb_id,'vb_net_bc','Net Book Value:')
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_inpset',  'vb_net_bc')
	end

	if pass_gen_data.vi_currency .eq. cms_base_cur then
	begin
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_full_set',
		&            'vb_tip_fc')
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_inpset',
		&            'vb_tip_fc')
	end
	else
	begin
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_full_set',
		&            'vb_tip_bc')
		xcall i_setdel(pass_gen_data.inp_vb_id, 'vb_inpset',
		&            'vb_tip_bc')

	end
	xcall i_display(pass_gen_data.inp_vb_id, 'vb_full_set', whgine_vb,,,,,,,,,, gold_com )

	xcall whgine_calc_oa(gold_com, whgine_passed, whgine_vb)
	xcall evaluate_vb_hide_attach(whgine_vb, whgine_passed)

	xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)
	return

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_disp_vb_curr_vals

	.include 'gold_com' repository, group='gold_com'
	.include 'WHGINE_VB' repository, group='whgine_vb'
	.include 'whgine_passed' repository, group='whgine_passed'


	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	external function
		f_curr_bc,      d
		f_curr_fc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
.proc

	if(pass_gen_data.vi_currency.ne.cms_base_cur)
	begin
		vb_tip_bc = %f_curr_bc(vb_tip_fc, pass_gen_data.vi_exch_rate)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_tip_bc', vb_tip_bc, gold_com)
	end

	vb_oa_bc = vb_tip_bc - vb_net_bc

	if(pass_gen_data.vi_currency.ne.cms_base_cur)
	begin
		if(f_wg_mv_comm) then
		begin
			vb_book_wd_fc = %f_curr_fc(vb_book_wd_bc, pass_gen_data.vi_exch_rate)
			vb_e_repairs_fc = %f_curr_fc(vb_e_repairs_bc, pass_gen_data.vi_exch_rate)
			vb_e_warr_fc = %f_curr_fc(vb_e_warr_bc, pass_gen_data.vi_exch_rate)

			xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_book_wd_fc', vb_book_wd_fc, gold_com)
			xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_e_repairs_fc', vb_e_repairs_fc, gold_com)
			xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_e_warr_fc', vb_e_warr_fc, gold_com)

			vb_net_fc = vb_book_wd_fc - vb_e_repairs_fc - vb_e_warr_fc
		end
		else
			vb_net_fc = %f_curr_fc(vb_net_bc, pass_gen_data.vi_exch_rate)

		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_net_fc', vb_net_fc, gold_com)
		vb_oa_fc = vb_tip_fc - vb_net_fc
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_oa_fc', vb_oa_fc, gold_com)

		vb_rrp_fc= %f_curr_fc(vb_rrp_bc, pass_gen_data.vi_exch_rate)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_rrp_fc', vb_rrp_fc, gold_com)

	end
	else
	begin
		clear vb_tip_fc, vb_net_fc, vb_oa_fc, vb_rrp_fc
		clear vb_e_repairs_fc, vb_e_warr_fc, vb_book_wd_fc

		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_book_wd_fc', vb_book_wd_fc, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_e_repairs_fc', vb_e_repairs_fc, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_e_warr_fc', vb_e_warr_fc, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_oa_fc', vb_oa_fc, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_net_fc', vb_net_fc, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_tip_fc', vb_tip_fc, gold_com)
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_rrp_fc', vb_rrp_fc, gold_com)

	end

	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_book_wd_bc', vb_book_wd_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_e_repairs_bc', vb_e_repairs_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_e_warr_bc', vb_e_warr_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_oa_bc', vb_oa_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_net_bc', vb_net_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_tip_bc', vb_tip_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_est_pdi_cost_bc', vb_est_pdi_cost_bc, gold_com)
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_est_prt_pdi_cost_bc', vb_est_prt_pdi_cost_bc, gold_com)

	vb_h_tip_bc=vb_tip_bc
	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       read group file
.subroutine whgine_get_group

	a_grp_code,             a
	a_grp_desc,             a
	a_err,                  n
	a_nomacc,               a
	a_comm,                 a
	a_non_stk,              d
	; market value commission
	a_vg_wc_book_wd_p,      n
	a_vg_wc_est_rep_p,      n
	a_vg_wc_est_warr_p,     n



	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VGREC.REC'
	.include 'SRC:PMGREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3

.proc
	err=1
	if(pass_gen_data.plan_maint)
	begin
		clear pmgrec
		pmgrec.pmg_group_code = a_grp_code
		pmgrec.pmg_depot = vi_depot
		if(a_grp_code)
			xcall file(pass_chn_data.chn(PMG_FILE),pmgrec,pmgrec.pmg_key0,'RD',err)
		if(err)
			pmg_description='Group not found'
		vgdes=pmg_description
		xreturn
	end
	if(a_grp_code) then
	begin
		vgcode = a_grp_code
		vg_adepot = vi_depot
		xcall file(pass_chn_data.chn(VGF_FILE),vgrec,vgkey,'RD',err)
		if(err)
		begin
			clear vgrec
			vgdes='Group not found'
		end
	end
	else
		clear vgrec
	if %passed(a_grp_desc)
		a_grp_desc = vgdes
	if %passed(a_err)
		a_err = err
	if %passed(a_nomacc)
		a_nomacc = vgsale
	if %passed(a_comm)
		a_comm = vgcomm
	if %passed(a_non_stk)
		a_non_stk = vgf_non_stock

	if(%passed(a_vg_wc_book_wd_p))
		a_vg_wc_book_wd_p=vg_wc_book_wd_p
	if(%passed(a_vg_wc_est_rep_p))
		a_vg_wc_est_rep_p=vg_wc_est_rep_p
	if(%passed(a_vg_wc_est_warr_p))
		a_vg_wc_est_warr_p=vg_wc_est_warr_p
	if(%passed(a_vg_wc_est_warr_p))
		a_vg_wc_est_warr_p=vg_wc_est_warr_p

	pass_gen_data.f_vg_pm_link = vgf_planned_maint_link
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       get the group description
.subroutine whgine_get_make
	a_mak_code,             a
	a_mak_desc,             a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:PREREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3

.proc
	err = 1
	if(a_mak_code) then
	begin
		pre_prefix = a_mak_code
		xcall file(pass_chn_data.chn(PRE_FILE),prerec,pre_prefix,'RD',err)
		if(err)
			pre_desc='Make not found'
	end
	else
		clear pre_desc
	a_mak_desc = pre_desc
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for parts
;
.subroutine whgine_trd_upd
	a_listid,       n
	a_inpwndid,     n
	.include 'whgine_vb' repository, group='whgine_vb'
	a_mode,         a
	a_filechn,      n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_curr_fc,  d
		f_yes_no,	d
	endexternal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		at_bottom,      d1
		err,            d3
		key_ref,        d1
		stkno,          a8
		loop,           d2
		tmp_rate,       d4

	record ifours
		req,            i4
		linp_id,        i4
		trdlinp_id,     i4
		gen_channel,    i4
		lReturnValue,	int
	endrecord
.proc
	clear lReturnValue
	req = D_LRESTORE
	xcall l_process( seq_lst_id, req , whgine_lst,, gold_com,
	&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
	if (a_mode == D_LISTIAD_DEL && vb_tstk && vb_tstk != T$AUTO)
	begin
		data lWarnMess,		a30
		xcall file(pass_chn_data.chn(HM_FILE), vmrec, vb_tstk, 'RE', err,,,,, Q_NO_LOCK)
		if (err)
		begin
			xcall file(pass_chn_data.chn(VM_FILE), vmrec, vb_tstk, 'RE', err,,,,, Q_NO_LOCK)
			if (err)
				clear vmrec
		end
		if (! err && (vmrec.vmcust || vmrec.vmsold))
		begin
			if (vmrec.vmsold)
				lWarnMess = 'WARNING - Trade in Sold'
			else
				lWarnMess = 'WARNING - Trade in Allocated'
			err = %f_yes_no(%atrim(lWarnMess) + ' - Continue with Deletion?',,,, false)
			if (err != true)
				xreturn D_USER_ABORT
		end
	end

	xcall l_status(seq_lst_id, D_LINPID, linp_id)
	xcall l_status(trd_lst_id, D_LINPID, trdlinp_id)
	if(pass_gen_data.vi_currency.eq.cms_base_cur)
	begin
		vb_tip_fc=vb_tip_bc
		vb_net_fc=vb_net_bc
		vb_oa_fc=vb_oa_bc
		vb_rrp_fc=vb_rrp_bc
	end

	; message only if input id is fr main trade in (not for attachments)
	if(a_mode.ne.D_LISTIAD_DEL.and.a_inpwndid.eq.pass_gen_data.inp_vb_id)
	begin
		xcall f_vat_rate( vb_vat, tmp_rate )
		if(tmp_rate .and.
		&  ((.not.pass_gen_data.h_vatable.or..not.pass_gen_data.h_vatreg).or.
		&  ((cms_country.eq.UK_VAT.OR.cms_country.eq.EIRE_VAT).and.vb_used.and..not.vb_qualify)))
		begin
			xcall ibc_message('Invalid - Vat Rate '
			&               + %string(vb_vat)
			&               +' Non Zero.  Re-enter')
			xcall i_next(a_inpwndid,'vb_inpset' ,'vb_vat')
			xreturn D_REINPUT_ENTRY
		end
	end
	case a_mode of
	begincase
		D_LISTIAD_INS:
		begin
			if(cms_gnavsk .and. vb_tstk .eq. T$AUTO)
			begin
				while(vb_tstk .eq. T$AUTO)
				begin
					xcall stk_seq(vb_tstk, err, vi_depot)
				end
			end

			xcall l_queue(seq_lst_id, D_LBOTTOM)
			xcall l_process( seq_lst_id, req = D_LAPPEND, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			clear whgine_lst
			lst_sb_type = true
			list_type=T$TRADE_IN
			lst_ntype = D_VJ_TRADE
			set lst_tstk, lst_stkno = vb_tstk
			lst_disp_stkno=lst_stkno
			lst_code = vb_code
			lst_model = vb_tmod
			lst_mak = vb_mak
			lst_grp = vb_grp
			lst_ser = vb_ser
			lst_reg = vb_reg
			lst_reg_dat = vb_dreg
			lst_clok = vb_clok

			for loop from 1 thru 10
				lst_spec(loop) = vb_spec(loop)

			lst_sbin = vb_sbin
			lst_used = vb_used
			lst_type = vb_type
			lst_qual = vb_qualify
			lst_year = vb_yr
			lst_wash_comp = vb_wash_comp
			set vb_atd_ord_qty = 1
			set lst_qty = 1.000                           ; V9.1 CMO
			set lst_dsp_cost = vb_tip_bc
			set lst_cost = vb_tip_fc
			lst_disc = vb_oa_fc
			lst_pur_cost = vb_tip_bc
			lst_retail = vb_rrp_fc

			lst_tot_cost = lst_cost
			lst_tot_retail = lst_retail
			lst_est_repairs=vb_e_repairs_bc
			lst_est_warr=vb_e_warr_bc

			lst_est_pdi_cost = vb_est_pdi_cost_bc
			lst_est_prt_pdi_cost = vb_est_prt_pdi_cost_bc
			lst_est_pdi_hours = vb_est_pdi_hours

			lst_vat = vb_vat
			set vb_prev_batch, lst_prev_batch = false
			lst_vm_exists = vb_vm_exists
			lst_vm_rfa = vb_vm_rfa
			lst_attach_num = vb_attach_num
			lst_trd_cmnt = true
			lst_moded = true
			vb_moded = true
			vb_has_attach = f_attach
			xcall i_display(trdlinp_id,, whgine_vb,,,,,,,,,, gold_com, gold_ax)
			req = D_LNOP
			xcall l_process(trd_lst_id, req, whgine_vb,,
			&               gold_com, gold_ax, fkeys, whgine_passed,
			&               fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
			&               add_part_passed, invoice_totals)
			stkno = vb_tstk
			if(vistat.ge.D_ADV_INVOICED) then
			begin
				vkkey = vijob + vb_astk
				xcall file(pass_chn_data.chn(VK_FILE),vdrec,vkkey,'FI',err)
				gen_channel = pass_chn_data.chn(VK_FILE)
				key_ref = 0
			end
			else
			begin
				xcall file(pass_chn_data.chn(VD_FILE),vdrec,vb_tstk,'FI',err,1)
				gen_channel = pass_chn_data.chn(VD_FILE)
				key_ref = 1
			end
			repeat
			begin
				xcall file(gen_channel,vdrec, vb_tstk,'RS', err,
				&                key_ref,,,, D_NO_LOCK)
				if err .or. vdstok .ne. stkno
					exitloop
				if .not. attach_ll
					xcall ll_open(attach_ll, ^size(vdrec))
				req = D_LAPPEND
				xcall ll_process(attach_ll, D_LL_APPEND, vdrec)
				xcall l_process(trd_lst_id, req, whgine_vb,,
				&                   gold_com, gold_ax, fkeys, whgine_passed,
				&                   fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
				&                   add_part_passed, invoice_totals)
				vb_wg_attach = true
				vb_has_attach = f_attach
				vbjob = vijob
				vb_tstk = vdastk
				vb_astk = vjtstk
				vb_code = vdcode

				vb_atd_ord_qty = vdqty

				if(vd_cost[D_FC].gt.vd_est_cos[D_FC].or.vd_fin_inv) then
				begin
					vb_tip_bc = vd_cost[D_BC]
					vb_tip_fc = vd_cost[D_FC]
					vb_net_bc = vd_cost[D_BC]
					vb_net_fc = vd_cost[D_FC]
				end
				else
				begin
					vb_tip_bc = vd_est_cos[D_BC]
					vb_tip_fc = vd_est_cos[D_FC]
					vb_net_bc = vd_est_cos[D_BC]
					vb_net_fc = vd_est_cos[D_FC]
				end
				vb_rrp_fc = vd_rrp_01
				vb_rrp_bc = vd_rrp_02
				vb_grp = vd_gcod
				xcall whgine_get_group(vb_grp, vb_grpdes)
				vb_mak = vd_make
				xcall whgine_get_make(vb_mak, vb_makdes)
				vb_tmod = vd_model
				vb_ser = vdser
				if (.not. pass_gen_data.h_vatreg .or. .not. pass_gen_data.h_vatable)
				begin
					if (.not.vdvat)
					begin
						if (.not. pass_gen_data.h_vatable) then
							vdvat=pass_gen_data.sb_vat_zero
						else
							vdvat=pass_gen_data.sb_vat_code
					end
					xcall f_vat_rate(vdvat, tmp_rate, true)
					if (tmp_rate)
						vdvat=pass_gen_data.sb_vat_zero
				end
				vb_vat = vdvat
				vb_prev_batch = false
				vb_moded = true
				xcall i_display(trdlinp_id,, whgine_vb,,,,,,,,,, gold_com, gold_ax)
				req = D_LNOP
				xcall l_process(trd_lst_id, req, whgine_vb,,
				&                   gold_com, gold_ax, fkeys, whgine_passed,
				&                   fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
				&                   add_part_passed, invoice_totals)

			end
			xcall reset_attch_vals(whgine_lst)
			xcall set_qty_dp(linp_id, lst_qty_dp)
			xcall i_display(linp_id,, whgine_lst)
			if .not. lst_spec
			begin
				f_lock_vm=false
				pass_chn_data.h_stok=vb_tstk
				xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
				xcall whgine_spec(gold_com, gold_ax, vb_tstk, (vmsold.ne.0),,,
				&                   pass_gen_data.adv_mode .eq. D_VEW_MODE, vb_vm_exists .eqs. ' ')
				vb_spec[] = vmspec[]
				vbtspc[] = vmspec[]
			end
			xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
		end
		D_LISTIAD_AMD:
		begin
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			repeat
			begin
				if lst_ntype .eq. D_VJ_TRADE .and. lst_stkno .eq. vb_tstk
				begin
					lst_code = vb_code
					lst_model = vb_tmod
					lst_mak = vb_mak
					lst_grp = vb_grp
					lst_ser = vb_ser
					lst_reg = vb_reg
					lst_reg_dat = vb_dreg
					lst_clok = vb_clok
					for loop from 1 thru 10
						lst_spec(loop) = vb_spec(loop)
					lst_sbin = vb_sbin
					lst_used = vb_used
					lst_type = vb_type
					lst_year = vb_yr
					lst_wash_comp = vb_wash_comp
					lst_disc = vb_oa_fc
					lst_pur_cost = vb_tip_bc
					set lst_dsp_cost = vb_tip_bc
					set lst_cost = vb_tip_fc
					lst_retail = vb_rrp_fc
					lst_tot_cost = lst_cost
					lst_tot_retail = lst_retail
					lst_est_repairs=vb_est_repairs
					lst_est_warr=vb_est_warr

					lst_est_pdi_cost = vb_est_pdi_cost_bc
					lst_est_prt_pdi_cost = vb_est_prt_pdi_cost_bc
					lst_est_pdi_hours = vb_est_pdi_hours

					lst_vat = vb_vat
					lst_moded = true
					xcall i_display(linp_id,, whgine_lst)
					xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
					&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
		D_LISTIAD_DEL:
		begin
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			repeat
			begin
				if lst_ntype .eq. D_VJ_TRADE .and. lst_stkno .eq. vb_tstk
				begin
					whgine_lst.lst_ti_del_opt = true
					if vb_prev_batch
						xcall ll_process( pass_chn_data.lst_cntrl, D_LL_INSERT, whgine_lst, err )

					if (vb_has_attach)
					begin
						req = D_LDELITEM        ; delete main wg
						xcall l_process(trd_lst_id, req, whgine_vb,,
						&               gold_com, gold_ax, fkeys, whgine_passed,
						&               fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
						&               add_part_passed, invoice_totals)
						xcall l_status(trd_lst_id, D_LATBOTTOM, at_bottom)
						while (vb_wg_attach)
						begin
							req = D_LDELITEM    ; delete attachment
							xcall l_process(trd_lst_id, req, whgine_vb,,
							&               gold_com, gold_ax, fkeys, whgine_passed,
							&               fkeys_grp, whgine_lst, whgine_inv_tab, whgine_hdr,
							&               add_part_passed, invoice_totals)
							if at_bottom
								exitloop
							xcall l_status(trd_lst_id, D_LATBOTTOM, at_bottom)
						end
						lReturnValue = D_USER_ABORT
					end
					xcall l_process( seq_lst_id, req = D_LDELITEM, whgine_lst,,
					&                gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
					&                whgine_passed, invoice_totals)

					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
	endcase
	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab, add_part_passed, invoice_totals)
	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab)
	set vb_moded, items_moded = true

	xreturn lReturnValue
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_ivt_display, ^val, reentrant

	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	ivt_desc_chng,          n

	.include "SRC:OPSCOM.REC"

	.include 'SRC:IVTCOM.REC'               ; !!!

	record gen
		filename,       a D_FILENAME_LEN
		err,            d3

	record ifours
		ivt_chn,        i4

.proc
	clear gen, ^i(ifours)
	if .not. ivt_desc_chng
	begin
		filename = itfile
		filename(8:3) = gold_com.cur_company, 'XXX'
		xcall u_fndfil(filename,, ivt_chn)
		if ivt_chn
		begin
			xcall file(ivt_chn, ivtrec, a_data_stored, 'RD', err)
			if err
				clear ivtrec
			xcall i_putfld(inp_wndid, 'adv_set', whgine_hdr, 'vi_narr',
			&              ivt_desc)
			xcall set_self_bill_vat_codes(whgine_passed)
		end
	end
	freturn TRUE
.end

.function whgine_ivt_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		vm_rfa,         a6
.proc
	a_pending_status = %ivt_change( a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr )

	if( (g_select .and. (g_entnam .eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL') ) .or.
	&   a_pending_status .ne. D_OK )      ; Menu entry
		freturn a_pending_status

	if(a_data_stored)
	begin
		vi_inv_typ = a_data_stored
		xcall whgine_get_inv_type(gold_com, gold_ax, whgine_hdr,
		&                         whgine_passed)
		if(f_wg_md_disc.ne.D_CM5_WG_MD_NO.and.pass_chn_data.h_prog_code.eq.
		&        P_COD_WGD_VAT_INC)
		begin
			xcall ibc_message('Invalid - This is a vat inclusive invoice type'
			&        +' which may not be used if multi discounts are in use')
			freturn D_EMITTEDERR
		end
		if(pass_gen_data.plan_maint.and.pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC)
		begin
			xcall ibc_message('Invalid - This is a vat inclusive invoice type'
			&        +' which may not be used for Planned Maintenance Sales Invoices.')
			freturn D_EMITTEDERR
		end
	end

	freturn a_pending_status
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_vi_cord_change ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMFCOM.REC'
.proc
	if(cmf_force_ord.and..not.a_data_entered)
	begin
		xcall ibc_message('Order Number is a required field for this customer')
		freturn D_EMITTEDERR
	end
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       the following subroutine checks whether customer order
        ;       number is required and set the field accordingly.  Also, as
        ;       fldmod seems to initialise the applicable field, it is
        ;       first stored and then reset to original value afterwards
.subroutine whgine_vi_cord_set_reqd
	pass_cmf_force_ord,     n
	.include 'whgine_hdr' repository, group='whgine_hdr'
	pass_wndid,             n
	.include 'gold_com' repository, group='gold_com'

	record general
		h_vi_cord,      a10

.proc

	; before field mod to ma`ke the following field required or otherwise
	; store the2 current contents of the field
	h_vi_cord=vi_cord
	if( pass_cmf_force_ord ) then
		xcall i_fldmod( pass_wndid, 'vi_cord',,,D_ON, D_FLD_REQUIRED )
	else
		xcall i_fldmod( pass_wndid, 'vi_cord',,,D_OFF, D_FLD_REQUIRED )
	if(h_vi_cord)
		xcall i_putfld(pass_wndid,, whgine_hdr, 'vi_cord',
		&          h_vi_cord, gold_com)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
function whgine_vi_idat_change,	^val
	a_data_entered       ,a
	a_data_stored        ,d
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	endparams

	external function
		f_last_day8,    d
		f_first_day8,   d
		julian,         d
	endexternal

	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMSCOM.REC'

	record general
		h_date, d8
	endrecord

proc
	a_pending_status = %acc_date_change(a_data_entered,  a_data_stored, a_pending_status, inputinfo,
	&	whgine_hdr, gold_com)

	if (a_pending_status != D_OK || (g_select && g_entnam != 'I_OK' && g_entnam != 'J_QUIT' && g_entnam != 'TS_TAB'))
		freturn a_pending_status

	if (a_data_stored)
	begin
		h_date = %f_get_date(a_data_stored)

		; special for doe - if user access level 37 (therefore do not
		; allow invoice date to be entered outside of current sales ledger
		; period)
		if (whgine_passed.f_idat_in_sal_per_only && cmsrec.cms_sal_per)
		begin
			if (h_date < %f_first_day8(D_POST_SAL) || h_date > %f_last_day8(D_POST_SAL))
			begin
				xcall ibc_message('Invalid - '+%f_alpha8_date(h_date)
				&   +' is not in Sales Ledger current period.\n'
				&   +'Sales Ledger current period is '
				&   +%string(cmsrec.cms_sal_per)
				&   +' - '+%f_alpha8_date(%f_first_day8(D_POST_SAL))
				&   +' to '+%f_alpha8_date(%f_last_day8(D_POST_SAL)), D_ERROR)
				a_pending_status= D_EMITTEDERR
			end
		end

		if (cms_country == SAUDI_ARABIA && h_date < %ndate)
		begin
			xcall ibc_message('Invalid - Invoice Date must not be less than today')
			a_pending_status= D_EMITTEDERR
		end

		if (a_pending_status == D_OK)
		begin
			if (vi_idat != h_date)
			begin
				xcall ibc_message('Warning - Invoice Date Overridden to ' + %f_alpha8_date(h_date))
			end

			a_data_stored = h_date
			vi_ddat = %julian(%julian(h_date)+vi_sett,1)
			xcall i_display(inp_wndid, 'date_set', whgine_hdr )
		end
	end

	freturn a_pending_status
endfunction

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
function whgine_vi_sett_change,	^val
	a_data_entered       ,a
	a_data_stored        ,d
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	endparams

	external function
		julian,         d
	endexternal

	.include "SRC:OPSCOM.REC"

proc
	a_pending_status = %stored_date_change(a_data_entered,  a_data_stored, a_pending_status, inputinfo, whgine_hdr)

	if (a_pending_status != D_OK || (g_select && g_entnam != 'I_OK' && g_entnam != 'J_QUIT' && g_entnam != 'TS_TAB'))
		freturn a_pending_status

	if (a_pending_status == D_OK)
	begin
		vi_ddat = %julian(%julian(vi_idat) + a_data_stored, 1)
		xcall i_display(inp_wndid, 'date_set', whgine_hdr )
	end

	freturn a_pending_status
endfunction

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
function whgine_vi_ddat_change,	^val
	a_data_entered       ,a
	a_data_stored        ,d
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	endparams

	external function
		julian,         d
	endexternal

	.include "SRC:OPSCOM.REC"

proc
	a_pending_status = %stored_date_change(a_data_entered,  a_data_stored, a_pending_status, inputinfo, whgine_hdr)

	if (a_pending_status != D_OK || (g_select && g_entnam != 'I_OK' && g_entnam != 'J_QUIT' && g_entnam != 'TS_TAB'))
		freturn a_pending_status

	if (a_data_stored)
	begin
		if (a_data_stored < vi_idat)
		begin
			xcall ibc_message(T$INVAL_SETDAT, D_ERROR)
			a_pending_status= D_EMITTEDERR
		end

		if (a_pending_status == D_OK)
		begin
			vi_sett = %julian(a_data_stored) - %julian(vi_idat)
			xcall i_display(inp_wndid, 'date_set', whgine_hdr )
		end
	end

	freturn a_pending_status
endfunction

.function whgine_prt_mnu, ^val

	a_entnam,       a

	a_listid,       n

	a_inpwndid,     n

	.include 'add_part_str' repository, group='part_data'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'

	.include 'SRC:OPSCOM.REC'

	external function
		f_calc_val,     d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal


	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		ret_val,        d1
		err,            d3
		at_bottom,      d1

	record ifours
		no_items,       i4
		linp_id,        i4
		req,            i4

.proc
	clear gen, ^i(ifours)
	ret_val = true
	using a_entnam select
		('CALC_TOT'),
		begin
			xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed,
			&                         whgine_hdr, whgine_inv_tab,
			&                         add_part_passed, invoice_totals)
			xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed,
			&                            whgine_hdr, whgine_inv_tab)
		end
		('DISP_TOT'),
		begin
			xcall l_status( a_listid, D_LLASTITM, no_items, D_LINPID, linp_id )
			if( no_items )
			begin
				xcall l_data(a_listid, D_LFIRST, linp_id, part_data,, err)
				while .not. err
				begin
					repeat
					begin
						if lst_ntype .eq. D_VJ_PART .and. lst_tstk .eq. part_wgstk
						begin
							lst_disc_pcnt = part_disc
							clear lst_disc, lst_dsp_disc, lst_vi_disc
							if part_disc
								lst_disc = %f_calc_val(part_sold_qty, part_retail_fc) -
								& %f_calc_val(part_sold_qty, part_retail_fc, part_disc)
							lst_dsp_disc=lst_disc
							lst_vi_disc=lst_disc
							if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC) then
							begin
								xcall whgine_vat_calc(lst_dsp_disc, lst_vat,
								&       vt_vat_code, vt_vrat, lst_dsp_disc,
								&       D_RET_VAT_INC, D_RET_VAT_EXC)
							end
							else
							begin
								if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
									nop
								else
									xcall whgine_vat_calc(lst_vi_disc, lst_vat,
									&        vt_vat_code, vt_vrat, lst_vi_disc,
									&        D_RET_VAT_EXC, D_RET_VAT_INC)

							end

							lst_moded = true
							xcall i_display(linp_id,, whgine_lst,,,,,,,,,, gold_com)
							xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,,
							&                gold_com, gold_ax,a_fkeys[SEQ_FKEYS],
							&                whgine_passed, invoice_totals)
							exitloop
						end
						if at_bottom
							exitloop
						xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
						&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
						xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
					end

					xcall l_data( a_listid, D_LNEXT, linp_id, part_data,, err)
				end
			end

			xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed,
			&                         whgine_hdr, whgine_inv_tab,
			&                         add_part_passed, invoice_totals)
			xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed,
			&                            whgine_hdr, whgine_inv_tab)
		end
	endusing
	freturn ret_val
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.function whgine_trd_mnu, ^val
	a_entnam,       a
	a_listid,       n
	a_inpwndid,     n
	.include 'whgine_vb' repository, group='whgine_vb'
	a_mode,         a
	a_filechn,      n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'add_part_passed' repository, group = 'add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_curr_bc,      d
		f_curr_fc,      d
		f_yn_only,      d
		f_yes_no,       d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record whgine_copy              ; copy {wholegd} (sb only)
		copy_wgnum,     a8                      ; selected {wholegd} to copy
		copy_opts,      d1                      ; copy attachments ?

	record gen
		ret_val,        d2
		yes_no_ans,     d1
		reject,         d1
		err,            d3
		f_copy_wg_ok,   d1
		done,           d1
		quitting,       d1
		.include 'vm_user' repository, group = 'vm_user'
		.include 'whgine_lst' repository, group = 'lst_data'
		.include 'vmrec' repository, group = 'hld_vmrec', nofields
		disp_line,      a80
		no_items,       d3
		a_vm_exists,    a1
		a_vm_rfa,       a6
		tmp_rate,       d4
		lHldPord,		a10

	record ifours
		copy_id,        i4
		linp_id,        i4

.proc
	ret_val = false
	case a_entnam of
	begincase
		'GET_INPID':
		if a_mode .eq. D_LISTIAD_AMD .or. a_mode .eq. D_LISTIAD_VIEW then
		begin
			if vb_wg_attach then
				freturn vb_atd_id
			else
				freturn pass_gen_data.inp_vb_id
		end
		else
			freturn pass_gen_data.inp_vb_id
		'J_SPC_WGD':
		begin
			f_lock_vm=false
			pass_chn_data.h_stok=vb_tstk
			xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
			xcall whgine_spec(gold_com, gold_ax, vb_tstk, (vmsold.ne.0),,,
			&                 pass_gen_data.adv_mode .eq. D_VEW_MODE, vb_vm_exists .eqs. ' ')
			vb_spec[] = vmspec[]
			vbtspc[] = vmspec[]
		end
		'TRD_STK':
		begin
			call new_trade_in_setup
		end
		'J_COPY': begin
			if(g_fldnam.eq.'VB_TSTK') then
			begin
				trd_create=true
				clear vb_tstk
				clear vb_vm_exists
				call new_trade_in_setup
				; save a copy of purchase order no created by whgine_write_vm otherwise will be overwritten by item copied from
				lHldPord = vmpord
				call wg_copy
				clear g_fldnam
				if(f_copy_wg_ok) done=TRUE
			end
			else
			begin
				; to copy wholegood (only applies to trade ins) must be new entry and the
				; stock number field must have already been entered (or auto selected).
				if(.not. trd_create) then; H or S
					xcall ibc_message('This Option is Only Available When '
					&              +'Creating a New Self Biller')
				else
				begin
					call wg_copy
					clear g_fldnam
					if(f_copy_wg_ok) done=TRUE
				end
			end
		end
		'J_SER_AMD':
		begin
			xcall serial_no_screen(whgine_passed, vb_tstk, vb_vm_exists, vb_vm_rfa,
			&     vb_ser, vb_reg, vb_dreg, vb_clok, vb_yr)
			xcall i_display(a_inpwndid, 'vb_inpset', whgine_vb,
			&   'vb_ser,vb_reg,vb_dreg,vb_clok, vb_yr',,,,,,,,, gold_com)
		end
		; WG7465 - REPLACE J_OVER WITH J_NEW_MOD 	IE. O'ride with New Mod
		; WG7465	'J_OVER': begin
		'J_NEW_MOD': 			; WG7465
		begin
			freturn D_OK
		end
		'J_PDI_INSTR':
		begin
			call enter_trd_pdi_instructions
			freturn D_OK
		end
		'J_PDI_CRT':
		begin
			call create_pdi_job
		end
		'J_W_STKNO':
		begin
			xcall whgine_washout_scn(gold_com, gold_ax, whgine_passed,
			&                          whgine_hdr)
		end
	endcase
	else
	begin
		xcall m_signal(a_entnam)    ; resignal back to tab proc
		ret_val = true
	end

	freturn ret_val
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	new_trade_in_setup,
	clear reject
	clear vbrec
	call validate_trade_in_wg
	if (.not. reject)
	begin
		vb_attach_num = %bld_attach_list(vb_tstk,,,invoice_totals)
		vb_attach_tot = %get_attach_tot(vb_tstk,TRUE,whgine_passed, invoice_totals)
		call initialise_vb_from_vm
		xcall ibc_enable(D_SET, a_inpwndid, 'vb_inpset')
		if pass_gen_data.vi_currency .eq. cms_base_cur
			xcall ibc_disable(a_inpwndid, 'vb_tip_fc')
		else
			xcall ibc_disable(a_inpwndid, 'vb_tip_bc')

		if (vmrec.vmsold && vmrec.vmivno)
			xcall ibc_disable(a_inpwndid, 'vb_rrp_bc')
		else
			xcall ibc_enable(a_inpwndid, 'vb_rrp_bc')

		xcall evaluate_vb_hide_attach(whgine_vb, whgine_passed)
		ifkeys.fkey[D_FK_NO4].disabled_flg = FALSE
		ifkeys.fkey[D_FK_NO5].disabled_flg = FALSE
		ifkeys.fkey[D_FK_NO6].disabled_flg = FALSE
		xcall ibc_fkeys(a_inpwndid,ifkeys)
		xcall i_next(a_inpwndid,'vb_inpset','vb_mak')
		;	    xcall i_next(a_inpwndid,'vb_inpset','vb_code')
		if (.not. vb_code)
			xcall i_init(a_inpwndid,'vb_inpset',whgine_vb,'vb_code')
		if (.not. vb_grp)
			xcall i_init(a_inpwndid,'vb_inpset',whgine_vb,'vb_grp')
		if (.not. vb_mak)
			xcall i_init(a_inpwndid,'vb_inpset',whgine_vb,'vb_mak')
	end
	ret_val = reject
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       attempt to create pdi job but only if details are up to date
	create_pdi_job,

	; if invoice type only
	if(viivcr.ne.D_VIIVCR_INVOICE)
	begin
		xcall ibc_message('Invalid - this option is only available for main Invoice type advices')
		return
	end

	if(.not. vb_vm_exists.or..not.vmgrp.or..not.vm_depot)
	begin
		xcall ibc_message('Update the advice before selecting this option')
		return
	end
	pass_chn_data.h_stok=vb_tstk
	xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)

	if(vm_est_pdi_cost != vb_est_pdi_cost_bc || vm_est_prt_pdi_cost != vb_est_prt_pdi_cost_bc ||
	&  vm_est_pdi_hours != vb_est_pdi_hours)
	begin
		xcall ibc_message('The trade in PDI details differ to that for the wholegood record.'
		&   +'  You need to update the advice before attempting to create a PDI advice from here.')
		return
	end
	;;;err = %pdi_refurb_create(vmstok,,true)                       ; WG7652b
	err = %pdi_refurb_create(vmstok,,true,whgine_passed.h_acc)   ; WG7652b

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       job instructions for pdi job
	enter_trd_pdi_instructions,
	csp_comtype = CMNT_WG_WSJ_INST
	csp_comacc = vb_tstk
	if(pass_gen_data.adv_mode .eq. D_VEW_MODE) then
		csp_comview = 9
	else
		csp_comview = false
	csp_comscrex=false
	if(.not.vb_tstk.or.vb_tstk.eq.'?'.or.vb_tstk.eq.T$AUTO)
	begin
		xcall ibc_message('Invalid - the trade in stock number needs to be set before you can enter instructions')
		return
	end

	if(pass_gen_data.adv_mode != D_VEW_MODE)
		xcall ScratchPadEdit(CMNT_WG_WSJ_INST,vb_tstk)
	if %ScratchPadCheck(CMNT_WG_WSJ_INST,vb_tstk) then
		xcall ibc_fkeys_set_txt('PdiIns*',D_FK_NO8,ifkeys, true)
	else
		xcall ibc_fkeys_set_txt('PdiIns ',D_FK_NO8,ifkeys, true)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       validate self bill wholegood
	validate_trade_in_wg,
	; first check if wgd already entered on this advice

	if (pass_chn_data.line_mode == D_INS_MODE && vb_tstk)
	begin
		xcall l_status(seq_lst_id, D_LLASTITM, no_items)
		if no_items
		begin
			xcall i_ldinp(linp_id, g_utlib, 'whgine_totinp', D_NOPLC,,,
			&             'whgine_lst')
			xcall l_data( seq_lst_id, D_LFIRST, linp_id, lst_data,, err )
			while( .NOT. err )
			begin
				; AP100808 - WG7418 & WG7419 - CRASH AFTER INVALIDATING SELECTION.  THE
				; PROBLEM WAS THAT THE STOCK NO HAS N0T BEEN SET YET FOR THE TRADE IN AND THAT
				; THE LST_STKNO WAS NOT SET FOR THE PART RECORD
				; AP100809                  if vb_tstk .eq. lst_data.lst_stkno
				if vb_tstk .eq. lst_data.lst_tstk           ; AP100808 - WG7418 & WG7419
				begin
					xcall ibc_message('Invalid - {WHOLEGD} already in use on this advice')
					xcall ibc_window(D_DELETE, linp_id)
					goto invalid_sb_wg
				end
				xcall l_data( seq_lst_id, D_LNEXT, linp_id, lst_data,, err )
			end
			xcall ibc_window(D_DELETE, linp_id)
		end
	end

	f_create_wg=false
	clear whgine_lst.lst_vm_exists
	clear pass_chn_data.h_stok
	if(vb_tstk) then
	begin
		pass_chn_data.h_stok = vb_tstk
		xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
	end
	else
		clear vb_vm_exists

	if(.not.vb_vm_exists)
	begin
		; WGD_CREATE set by vm_.....
		if(trd_create)
		begin
			if(cms_gnavsk.and..not.vb_tstk)
				xcall stk_seq(vb_tstk, err, vi_dep)
			if(.not. cms_gnavsk .and. .not. vb_tstk)
				vb_tstk = pass_chn_data.h_stok
			if(.not. vb_tstk)
			begin
				xcall ibc_message('A stock number must be entered')
				goto invalid_sb_wg
			end
			f_create_wg=TRUE
			clear vb_vm_exists
			pass_chn_data.h_stok = vb_tstk
		end
	end

	if(.not. vb_vm_exists)
	begin
		clear vmrec
		xcall initialise_vm_fields(whgine_hdr, whgine_passed, whgine_vb)
		vmstok = vb_tstk
		xcall whgine_write_vm(vb_vm_exists, vb_vm_rfa)
		return      ;if new then no need to validate further
	end
	; wholegood validation

	; check if the wholegood has already been uised for this advice
	vjjob=vijob
	vjtstk=vb_tstk
	xcall file(pass_chn_data.chn(VJ_FILE),vjrec,vjstok,'RD',err,1,,,,D_NO_LOCK)
	if (err)
	begin
		vbjob=vijob
		vbtstk=vb_tstk
		xcall file(pass_chn_data.chn(VB_FILE),vbrec,vbstok,'RD',err,1,,,,D_NO_LOCK)
		clear vbrec
	end
	if (.not.err)
	begin
		xcall ibc_message('This stock number has already been used for this '
		&               +'advice')
		goto invalid_sb_wg
	end

	f_tx_type=viivcr
	if (%WHGINE_Check_Trade_In_Ok(f_tx_type, vmrec, virec))
		goto invalid_sb_wg

	if (vmass.eq.D_WG_CONSIGN)
	begin
		xcall ibc_message('Invalid - This {WHOLEGD} is on consignment')
		goto invalid_sb_wg
	end

	if(vmpacc.ne. %atrim(vi_cust))
	begin
		yes_no_ans=D_NO
		if(vm_pur_cur.ne.vi_sell_cur)
		begin
			xcall ibc_message('Invalid - Purchase currency for {WHOLEGD} '
			&                 +'different to advice currency')
			goto invalid_sb_wg
		end
		xcall yes_no('Warning - This {WHOLEGD} Supplied By Customer '+
		&                 vmpacc+' - Continue?',yes_no_ans)
		if (yes_no_ans.ne.D_YES)
			goto invalid_sb_wg
	end

	if (vmass.ne.D_WG_ON_ORDER.and..not.viivcr)
	begin
		xcall ibc_message('Invalid - This {WHOLEGD} Has Already Been Traded In')
		goto invalid_sb_wg
	end

	if(viivcr.eq.D_VIIVCR_CREDIT)
	begin
		xcall whgine_check_sb_int_jobs(yes_no_ans, vb_tstk)
		if (yes_no_ans.ne.D_YES)
			goto invalid_sb_wg
	end

	if (vb_vm_exists.eq.'H') then
		xcall file(pass_chn_data.chn(HM_FILE),vmrec,vb_tstk,'RD',err)
	else
		xcall file(pass_chn_data.chn(VM_FILE),vmrec,vb_tstk,'RD',err)
	return

	invalid_sb_wg,
	g_fldnam='VB_TSTK'
	g_setsts=1                      ; to stop done
	reject=TRUE
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	initialise_vb_from_vm,
	if (pass_chn_data.line_mode.eq.D_INS_MODE.or..not.vbtvat)
	begin
		if (cms_country.eq.EIRE_VAT) then
			vbtvat=pass_gen_data.sb_vat_code
		else
			vbtvat=vmvat
	end

	; IF INSERT MODE AND WE ARE CREATING A WG AND THIS IS UK AND USED VEHICLE
	; TYPE THEN SET DEFAULT QUAL TYPE TO BE FALSE

	if (pass_chn_data.line_mode == D_INS_MODE && ! whgine_lst.lst_vm_exists)
	begin
		if((cms_country == UK_VAT || cms_country == EIRE_VAT) && vmnu == 'U' && (! pass_gen_data.h_vatreg || vmtype))
		begin
			vm_qualifying = false
		end
		else
		begin
			vm_qualifying = true
		end
	end
	vb_qual = vm_qualifying
	; special for rickerbys - always set qual = true
	; as the special vat on used car sales non applicable for them
	if (cms_user_id.eq.10436)
		vb_qual = true

	if (.not. pass_gen_data.h_vatreg .or. .not. pass_gen_data.h_vatable.or.vb_qual.eq.false)
	begin
		if (.not.vbtvat)
		begin
			if (.not. pass_gen_data.h_vatable) then
				vbtvat=pass_gen_data.sb_vat_zero
			else
				vbtvat=pass_gen_data.sb_vat_code
		end
		xcall f_vat_rate(vbtvat, tmp_rate)
		if (tmp_rate)
			vbtvat=pass_gen_data.sb_vat_zero
	end

	if (vmgrp.eq.cms_wg_wsj_grp)
		clear vmgrp
	vbtgrp=vmgrp
	vbtmak=vmmak
	vbcode=vmcode
	vbtmod=vmmodl

	set vb_spec[], vbtspc[] = vmspec[]

	vbtser = vmser
	vbtclk = vmclok
	vbtreg = vmreg
	vbtdat = vmdreg
	vb_year = vm_year
	vb_trade_prc(D_FC)=vm_tip(D_FC)
	vb_trade_prc(D_BC)=vm_tip(D_BC)

	vb_est_repairs=vm_est_repairs
	vb_est_warr=vm_est_warr
	vbtnsp=vb_trade_prc(D_BC)-vmoa

	if (vm_rrp(D_FC))
		vbtrrp = vm_rrp(D_FC)
	else
		vbtrrp = vmmrrp

	vb_wash=vm_wash

	if .not. f_create_wg
		vb_tstk = vmstok

	vb_sbin = vbsbin

	vb_est_pdi_cost_bc = vm_est_pdi_cost
	vb_est_prt_pdi_cost_bc = vm_est_prt_pdi_cost
	vb_est_pdi_hours = vm_est_pdi_hours

	vb_grp = vbtgrp
	xcall whgine_get_group(vb_grp, vb_grpdes,,,,,
	&       vb_book_wd_p, vb_est_rep_p, vb_est_warr_p)

	vb_mak = vbtmak
	xcall whgine_get_make(vb_mak, vb_makdes)

	vb_code = vbcode
	vb_tmod = vbtmod

	if (vmnu.eq.'U') then
		vb_used = 1
	else
		vb_used = 0
	vb_type = vmtype

	vb_ser = vbtser
	vb_reg = vbtreg
	vb_dreg = vbtdat
	vb_clok = vbtclk
	vb_yr = vb_year

	; IF EIRE AND QUALIFYING THEN INFLATE HELD TIP PRICE TO BE VAT INCLUSIVE
	; WG7433        if (cms_country .eq. EIRE_VAT .and. vb_qual) then
	; WG7433          begin
	; WG7433            vb_tip_fc = vb_f_vin_tip
	; WG7433          end
	; WG7433        else
	vb_tip_fc = vb_trade_prc(D_FC)

	vb_tip_bc = %f_curr_bc(vb_tip_fc,pass_gen_data.vi_exch_rate)
	vb_e_repairs_bc=vb_est_repairs
	vb_e_warr_bc=vb_est_warr

	if(pass_gen_data.vi_currency.ne.cms_base_cur) then
	begin
		vb_e_repairs_fc = %f_curr_fc(vb_e_repairs_bc,pass_gen_data.vi_exch_rate)
		vb_e_warr_fc = %f_curr_fc(vb_e_warr_bc,pass_gen_data.vi_exch_rate)
	end
	else
		clear vb_e_repairs_fc, vb_e_warr_fc

	vb_net_bc = vbtnsp

	vb_rrp_bc = vbtrrp
	vb_vat = vbtvat
	vb_hide_ln = vb_hide
	vb_hide_att = vb_hide_attach

	vb_wash_comp = vb_wash

	vb_qualify = vb_qual

	f_attach = FALSE
	if (.not. f_create_wg)
	begin
		vkkey = vijob+vb_tstk
		if(vistat .ge. D_ADV_INVOICED) then
			xcall file(pass_chn_data.chn(VK_FILE), vdrec, vkkey, 'FI', err)
		else
			xcall file(pass_chn_data.chn(VD_FILE), vdrec, vb_tstk, 'FI', err, 1)
		repeat
		begin
			if(vistat .ge. D_ADV_INVOICED) then
				xcall file(pass_chn_data.chn(VK_FILE), vdrec,, 'RS', err)
			else
				xcall file(pass_chn_data.chn(VD_FILE), vdrec,, 'RS', err,,,,, D_NO_LOCK)
			if (err .or. vb_tstk .ne. vdstok .or.
			&                       (vistat .ge. D_ADV_INVOICED .and. vdgrn .ne. vijob))
				exitloop
			; THERE IS AT LEAST ONE CUSTOMER SUPPLIED ATTACHMENT FOR THE TRADE IN AND
			; THEREFORE SOMETHING TO VIEW
			if (.not. vd_sup_cus)
			begin
				f_attach = TRUE
				exitloop
			end
		end
	end
	xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)
	xcall i_display(a_inpwndid,, whgine_vb,,,,,,,,,, gold_com)
	if .not. vb_code
		xcall i_init(a_inpwndid, 'vb_inpset', whgine_vb, 'vb_code')
	if .not. vb_grp
		xcall i_init(a_inpwndid, 'vb_inpset', whgine_vb, 'vb_grp')
	if .not. vb_mak
		xcall i_init(a_inpwndid, 'vb_inpset', whgine_vb, 'vb_mak')

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       check to see if wholegood is ok to select as self bill
	check_trade_in_ok,
	err = 0
	if %check_vm_depot
	begin
		err = 1
		return
	end

	if(vmstok.eq.vi_stok)
	begin
		xcall ibc_message('Invalid - The trade in must not be the same as '
		&               +'the main washout stock no')
		err=1
		return
	end

	if(vm_sb_adv)
	begin
		xcall ibc_message('Invalid - Trade-In {WHOLEGD} '+vmstok+
		&        ' has already been selected for Invoicing. See advice no '+vm_sb_advno)
		err=1
		return
	end

	if(vmpsys.ne.'C')
	begin
		xcall ibc_message('Invalid - Trade-in Stock no. '+vmstok+
		&                       ' is not customer supplied.')
		err=1
		return
	end

	if((.not.f_tx_type.and.vmass.eq.D_WG_IN_STOCK).or.
	&               (f_tx_type.and.vmass.ne.D_WG_IN_STOCK))
	begin
		xcall ibc_message('Invalid - Trade-in Stock no. '+vmstok+
		&                       ' is not the correct status.')
		err=1
		return
	end

	; if credit and self billers not in use, check the wg to make sure no
	; cost postings made.
	if(.not.cms_wg_sb_in_use.and.f_tx_type.and.vi_not_sb.eq.D_VI_NOT_SB_PUR_INV)
	begin
		if(.not.vm_fin_inv)
		begin
			inval_purch_ti,
			xcall ibc_message('Invalid - cost postings must be reversed first')
			err=1
			return
		end
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,vmstok,'FI',err,1)
		repeat
		begin
			xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',err,,,,,D_NO_LOCK)
			if(err.or.vdstok.ne.vmstok) exitloop
			if(.not.vd_fin_inv) goto inval_purch_ti
		end
		clear err
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       allow user to copy wholegood details from another wholegood
        ;       this applies to self billers only and only where a wholegood
        ;       is selected for creation.
	wg_copy,
	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )
	xcall ibc_ldinp( copy_id, g_utlib, 'whgine_copy', D_NOPLC )

	clear vm_user, ^i(vm_user.vm_user_mh)
	vm_user.usr_all=TRUE
	vm_user.chk_option=D_ALL_WG
	vm_user.chk_cust=vi_cust
	clear vm_user.vm_user_mh
	xcall i_user(copy_id, 'copy_wgnum',, vm_user )

	xcall ibc_window( D_PLACE, copy_id, 7, 15 )

	xcall i_init(copy_id, , whgine_copy)
	xcall i_next( copy_id,,'*FRST*' )
	do
	begin
		xcall ibc_input( copy_id, , whgine_copy,gold_inp_id,gold_sel_id, ,
		&             D_NOTERM ,, a_fkeys[INP_FKEYS],gold_com,gold_ax, whgine_passed)
		if g_select then
		begin
			case g_entnam of
			begincase
				'J_QUIT':           quitting = true
			endcase
		end
		else
			done = true
	end
	until( quitting .OR. done )

	if( .NOT. quitting )
		call action_copy

	if(quitting)
	begin
		clear vmrec
		xcall initialise_vm_fields(whgine_hdr, whgine_passed, whgine_vb)
	end

	set done, quitting, reject = false
	clear ^i(a_fkeys[INP_FKEYS].fkmnu_id)
	xcall e_exit
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	action_copy,
	quitting=TRUE
	disp_line='Please Confirm {WHOLEGD}'
	if(copy_opts) disp_line(%trim(disp_line)+2:19)='And Its Attachments'
	disp_line(%trim(disp_line)+2:14)='To Be Copied'
	if(.not.(%f_yn_only(%atrim(disp_line),22) .EQ. D_YES)) return
	pass_chn_data.h_stok=vmstok
	xcall check_vm_exists(whgine_passed, a_vm_exists, a_vm_rfa)
	clear vb_same_machine
	if(a_vm_exists.eq.'H')
		vb_same_machine = %f_yes_no( T$SAME_MACHINE,,,,false,false )
	if( vb_same_machine .EQ. D_USER_ABORT )
		return

	; if same machine then follow the selected wg next wg pointer until end of chain
	; and use the last in the chain as the basis for the copy (this should be
	; the latest version anyway).

	vb_prev_stk=vmstok
	if(vb_same_machine.and.vmnstk)
	begin
		pass_chn_data.h_stok = vmnstk
		do
		begin
			xcall check_vm_exists(whgine_passed, a_vm_exists, a_vm_rfa)
			if(.not.a_vm_exists) then               ; end of chain because of read error
			begin                 ; so restore to last successful read
				pass_chn_data.h_stok = copy_wgnum
				xcall check_vm_exists(whgine_passed, a_vm_exists,
				&                     a_vm_rfa)
				if(.not.a_vm_exists)
				begin
					xcall ibc_message('An error has occurred in {WHOLEGD} '
					&                         +'record chain - cannot proceed with copy',D_BELL)
					return
				end
			end
			else
			begin
				xcall flash('CHANGING TO LATER VERSION OF {WHOLEGD}')
				sleep 1
				copy_wgnum = vmstok
				pass_chn_data.h_stok=vmnstk
				xcall i_dspfld(copy_id, 'copy_wgnum',copy_wgnum)
				disp_line='{WHOLEGD} Stock No '+vmstok+' is a later version'
				&                       +' of '+vb_prev_stk+'. Continue?'
				if(.not.(%f_yn_only(%atrim(disp_line),22) .EQ. D_YES))
					return
			end
		end
		until(.not. pass_chn_data.h_stok)
		vb_prev_stk=copy_wgnum
	end

	quitting=false
	xcall initialise_vm_fields(whgine_hdr, whgine_passed, whgine_vb)
	call initialise_vb_from_vm
	set pass_chn_data.h_stok, vmstok = vb_tstk
	vmpord = lHldPord
	hld_vmrec = vmrec
	f_lock_vm = true
	xcall check_vm_exists(whgine_passed, vb_vm_exists, vb_vm_rfa)
	vmrec = hld_vmrec
	xcall whgine_write_vm(vb_vm_exists, vb_vm_rfa)
	vb_hide_att = false
	if(copy_opts)   ; create attachments
	begin
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,vb_prev_stk,'FI',err,1)
		repeat
		begin
			xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',err,,,,,
			&                                       D_NO_LOCK)
			if(err.or.vdstok.ne.vb_prev_stk) exitloop
			vdstok = vb_tstk

			vd_sup_cus=false

			clear vd_est_cos(D_BC), vd_rrp(D_BC)
			clear vd_est_cos(D_FC), vd_rrp(D_FC)
			clear vd_cost(D_BC), vd_cost(D_FC)

			clear vdgrn, vd_fin_inv, vd_recv_date

			clear vd_conf_sold
			clear vd_date_wrt, vd_orig_cost, vd_amt_wrt
			if(vdcode.eq.cms_wg_att_code) then
				vd_hide = true
			else
				clear vd_hide

			if(.not. vb_same_machine)
				clear vdser
			vdpord = vmpord
			err = 1
			while(err) xcall att_seq(vdastk, err, vi_depot)
			xcall file(pass_chn_data.chn(VD_FILE), vdrec, vdastk, 'ST', err)
			incr vb_attach_num
		end

		vb_attach_tot = %get_attach_tot(vb_tstk, true, whgine_passed, invoice_totals)
		xcall i_display(a_inpwndid,, whgine_vb, 'vb_attach_num, vb_attach_tot',,,,,,,,,
		&               gold_com)

	end
	if (vb_attach_num)
		xcall ibc_enable(a_inpwndid, 'vb_hide_att')
	else
		xcall ibc_disable(a_inpwndid, 'vb_hide_att')

	f_copy_wg_ok=TRUE
	return


.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_vj_curr_vals ; general currency value display

	.include 'gold_com' repository, group = 'gold_com'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	a_wndid,        n
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       when not base currency, the screen is split into two columns
        ;       of values and this routine is responsible for maintaining
        ;       the non input fields
.proc
	xcall whgine_set_vj_curr_flds(whgine_vj, whgine_passed, invoice_totals)

	if(f_wg_md_disc)
	begin
		xcall i_dspfld(a_wndid,'vj_fc_disc',vj_fc_disc, gold_com)
		xcall i_dspfld(a_wndid,'vj_fc_vi_disc',vj_fc_vi_disc, gold_com)
		xcall i_dspfld(a_wndid,'vj_fc_sett',vj_fc_sett, gold_com)
	end

	if(pass_gen_data.vi_currency.ne.cms_base_cur) then
	begin
		if(wg_security.ne.ACC_NO_COST_DISP.and..not. pass_gen_data.plan_maint)
		begin
			xcall i_dspfld(a_wndid,'vj_fc_ecos',vj_fc_ecos, gold_com)
			xcall i_dspfld(a_wndid,'vj_bc_cost',vj_bc_cost, gold_com)
			xcall i_dspfld(a_wndid,'vj_fc_cost',vj_fc_cost, gold_com)
		end
		if(.not. pass_gen_data.plan_maint) then
			xcall i_dspfld(a_wndid,'vj_d_bc_mrrp',vj_d_bc_mrrp, gold_com)
		else
			xcall i_dspfld(a_wndid,'VJ_DSP_PM_BC_CHARGE',vj_dsp_pm_bc_charge, gold_com)
		xcall i_dspfld(a_wndid,'vj_bc_rrp',vj_bc_rrp, gold_com)
		xcall i_dspfld(a_wndid,'vj_bc_disc',vj_bc_disc, gold_com)
		if(.not. pass_gen_data.plan_maint)
			xcall i_dspfld(a_wndid,'vj_bc_vi_disc',vj_bc_vi_disc, gold_com)
		xcall i_dspfld(a_wndid,'vj_bc_sett',vj_bc_sett, gold_com)
	end

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       set display currency fields.  These are base currecy for any
;       sales values and foreign currency costs for costs.  Note that
;       these foreign currency costs are represented in the selling
;       currency at the current exchange rate even if they were bought
;       in a different currency.  The reason for this is that the
;       display is shown in two columns ie. selling currency and base
.subroutine whgine_set_vj_curr_flds
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	external function
		f_curr_bc,      d
		f_curr_fc,      d

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		.include 'vwrec' repository, group='vwrec'

.proc
	if(f_wg_md_disc)
	begin
		vwrec.vw_md_group=vj_inp_md_group
		xcall wg_md_disc_display(,vwrec,vj_fc_rrp,,,vj_fc_disc, vj_fc_sett)
		if(vj_vat) then
			xcall whgine_vat_calc(vj_fc_vi_disc, vj_vat,
			&        vt_vat_code, vt_vrat, vj_fc_disc,
			&        D_RET_VAT_EXC, D_RET_VAT_INC)
		else
			vj_fc_vi_disc=vj_fc_disc
	end
	if(pass_gen_data.vi_currency.ne.cms_base_cur) then
	begin
		vj_bc_ecos=%f_curr_bc(vj_fc_ecos,pass_gen_data.vi_exch_rate)
		vj_fc_cost=%f_curr_fc(vj_bc_cost,pass_gen_data.vi_exch_rate)
		vj_bc_trd_price=%f_curr_bc(vj_fc_trd_price,pass_gen_data.vi_exch_rate)
		vj_bc_mrrp=%f_curr_bc(vj_fc_mrrp,pass_gen_data.vi_exch_rate)
		vj_d_bc_mrrp=%f_curr_bc(vj_d_fc_mrrp,pass_gen_data.vi_exch_rate)
		vj_bc_rrp= %f_curr_bc(vj_fc_rrp, pass_gen_data.vi_exch_rate)
		vj_bc_vi_rrp=%f_curr_bc(vj_fc_vi_rrp,pass_gen_data.vi_exch_rate)
		vj_bc_disc=%f_curr_bc(vj_fc_disc,pass_gen_data.vi_exch_rate)
		vj_bc_vi_disc=%f_curr_bc(vj_fc_vi_disc,pass_gen_data.vi_exch_rate)
		vj_bc_sett=%f_curr_bc(vj_fc_sett,pass_gen_data.vi_exch_rate)
		if(pass_gen_data.plan_maint)
			vj_dsp_pm_bc_charge= %f_curr_bc(wg_pm_contract_charge, pass_gen_data.vi_exch_rate)
	end
	else
	begin
		vj_bc_ecos=vj_fc_ecos
		vj_bc_cost=vj_fc_cost
		vj_bc_disc=vj_fc_disc
		vj_bc_vi_disc=vj_fc_vi_disc
		vj_bc_sett=vj_fc_sett
		vj_bc_rrp=vj_fc_rrp
		vj_bc_vi_rrp=vj_fc_vi_rrp
	end
	if(pass_gen_data.plan_maint) then
		clear vj_dsp_cost, vj_fc_ecos, vj_fc_cost
	else
		vj_dsp_cost = %max(vj_fc_ecos, vj_fc_cost)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       reads currency record (disp_curr)
.subroutine reset_currency

	.include 'gold_com' repository, group = 'gold_com'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if(cms_currency)
	begin
		gold_com.currency_code = pass_gen_data.vi_currency
		xcall disp_curr(pass_gen_data.vi_currency)
		xcall s_bld(curr_desc,,T$BRACKETS,pass_gen_data.vi_currency)
		gold_com.cur_dp[D_FC]=fcf_dp
	end
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for customer field
.function whgine_vj_rrp_change, ^val

	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:CM4REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	external function
		f_curr_fc,      d
		f_curr_bc,      d
		f_format_money, a

	record gen
		disp_line,      a80
		err,            d3
		c_journal,      d10
		old_qty,        d10
		h_inv_val,      d10                     ; total invoice value
		loop,           d2
		fldnam,         a20
.proc
	clear gen
	a_pending_status = %currency_na_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj, gold_com, gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status

	if(.not.vj_wg_attach)
	begin
		if(vjnstk .eq. D_VJ_WGD .and. viivcr .eq. D_VIIVCR_PART_CRED .and.
		&  ^d(a_data_stored) .ge. vm_rrp(D_FC))
		begin
			xcall ibc_message('Invalid - Partial credit value must be '
			&                       +'less than invoice value')

			freturn D_EMITTEDERR
		end
	end
	; NOTE THE CURRENT FIELD MAY BE EITHER VAT INCLUSIVE OR EX VAT
	; DEPENDING ON INVOICE TYPE
	fldnam = %i_getstring( inp_wndid, inp_fldnam )

	xcall i_putfld(inp_wndid,'*CURR*', whgine_vj, fldnam,
	&              ^d(a_data_stored), gold_com)
	; want to either populate the vat inclusive value or ex vat price
	; depending on invoice type (vat inc or otherwise)

	if(fldnam(%trim(fldnam)-5:6).eq.'VI_RRP') then
	begin
		xcall whgine_vat_calc(vj_fc_rrp, vj_vat,
		&       vt_vat_code, vt_vrat, vj_fc_vi_rrp,
		&       D_RET_VAT_INC, D_RET_VAT_EXC)
		xcall i_dspfld(inp_wndid,'vj_fc_rrp',vj_fc_rrp, gold_com)

	end
	else
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
			vj_fc_vi_rrp=vj_fc_rrp
		else
			xcall whgine_vat_calc(vj_fc_vi_rrp, vj_vat,
			&       vt_vat_code, vt_vrat, vj_fc_rrp,
			&       D_RET_VAT_EXC, D_RET_VAT_INC)
		xcall i_dspfld(inp_wndid,'vj_fc_vi_rrp',vj_fc_vi_rrp, gold_com)
	end
	if(cms_currency.and.pass_gen_data.vi_currency.ne.cms_base_cur)
	begin
		vj_bc_vi_rrp = %f_curr_bc(vj_fc_vi_rrp, pass_gen_data.vi_exch_rate)
		xcall i_dspfld(inp_wndid,'vj_bc_vi_rrp',vj_bc_vi_rrp, gold_com)
		vj_bc_rrp = %f_curr_bc(vj_fc_rrp, pass_gen_data.vi_exch_rate)
		xcall i_dspfld(inp_wndid,'vj_bc_rrp',vj_bc_rrp, gold_com)
	end
	if(vj_wg_attach)
	begin
		vj_atd_t_rrp = vj_fc_rrp * vj_atd_ord_qty
		vj_atd_t_vi_rrp = vj_fc_vi_rrp * vj_atd_ord_qty
		xcall i_dspfld(inp_wndid,'vj_atd_t_rrp',vj_atd_t_rrp, gold_com)
		xcall i_dspfld(inp_wndid,'vj_atd_t_vi_rrp',vj_atd_t_vi_rrp, gold_com)
		if(cms_currency.and.pass_gen_data.vi_currency.ne.cms_base_cur)
		begin
			vj_atd_t_brrp = vj_bc_rrp * vj_atd_ord_qty
			vj_atd_t_vi_brrp = vj_bc_vi_rrp * vj_atd_ord_qty
			xcall i_dspfld(inp_wndid,'vj_atd_t_brrp',vj_atd_t_brrp, gold_com)
			xcall i_dspfld(inp_wndid,'vj_atd_t_vi_brrp',vj_atd_t_vi_brrp, gold_com)
		end
		freturn D_OK
	end
	; check if the price entered is below minimum held on the
	; standard model file.  if it is then warning message only
	if(vj_fc_rrp.and.vjnstk.eq.D_VJ_WGD.and.vmnu.ne.'U'.and.
	&               viivcr.ne.D_VIIVCR_PART_CRED.and.viivcr.ne.D_VIIVCR_PART_INV)
	begin
		if(cms_calc_wg_pric)
			call check_vm_price_below_min
	end

	if(f_wg_md_disc) then
	begin
		xcall whgine_disp_vj_curr_vals(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)
	end
	else
		xcall set_settlement_default(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)
	freturn a_pending_status

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section is only called when the cms_calc_wg_pric parameter
        ;       is set
        ;       the section checks the current selling price against a minimum
        ;       calculated from %ages of cost price held on model file
        ;       a warning is display if the price is below that minimum
        ;       the section reuses variables rather than new ones being created
        ;       specifically for the section
	check_vm_price_below_min,
	; check model file
	xcall file(pass_chn_data.chn(VW_FILE),vwrec,vmcode,'RD',err,,,,, D_NO_LOCK)
	; if there is an error (model doesn't exist) then use defaults from cm4
	if(err) vw_sale_perc[]=cm4_wg_sal_pri_perc[]

	if(vj_fin_inv.or.vj_bc_cost.gt.vj_bc_ecos)
		c_journal=vj_bc_cost
	else
		c_journal=vj_bc_ecos
	c_journal=%f_curr_fc(c_journal,pass_gen_data.vi_exch_rate)

	; note setting old_qty

	clear err
	old_qty=9999999999

	for loop from 1 thru 4
	begin
		; test for text and > 0 value ie. ignore
		; 0 and possible negatives.  negatives may
		; represent percentage of cost
		if(cm4_wg_sal_pri_txt(loop).and.vw_sale_perc(loop).gt.0)
		begin
			h_inv_val=(c_journal*(10000+vw_sale_perc(loop)) )#4
			if(vj_fc_rrp.lt.h_inv_val.and.h_inv_val.lt.old_qty)
			begin
				err=loop
				old_qty=h_inv_val
			end
		end
	end
	if(err)
	begin
		xcall s_bld(disp_line,,T$SELL_PRI_WARN, cm4_wg_sal_pri_txt(err),
		&                %string(old_qty,%f_format_money(12,fcf_dp,D_NEG_REQD)))
		xcall ibc_message(disp_line)
	end
	return

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       routine to calculate vat related values
.subroutine whgine_vat_calc
	out req rtn_val,                n               ; compulsory
	in  req vat_code,            	n               ; compulsory
	inout  req vat_codes,        [*]n               ; compulsory
	inout  req vat_rates,        [*]n               ; compulsory
	in  req pass_val,               n               ; passed inclusive or exclusive value
	in  req pass_type,              n               ; 1=exclusive of vat
                                                    ; 2=inclusive of vat
	in  req calc_type,              n               ; 0=return vat val
                                                    ; 1=return excl of vat val
                                                    ; 2=return incl of vat val

	.align
	record general
		vloop,		i4
		err,            i4

.proc
	rtn_val=pass_val

	for vloop from 1 thru 10
	begin
		if (vat_codes[vloop] == vat_code && vat_rates[vloop])
			exitloop
		; may redo the following a number of times when zero rate used.  This is
		; better than never setting it because vat_codes[]
		if (! vat_codes[vloop] || (vat_codes[vloop] == vat_code && ! vat_rates[vloop]))
		begin
			vat_codes[vloop] = vat_code
			err = %f_vat_rate( vat_code, vat_rates[vloop] )
			exitloop
		end
	end
	if( vloop.gt.10 )
	begin
		xcall ibc_message('Too many VAT rates')
		vloop = 10
	end

	case calc_type of
	begincase
		D_RET_VAT_VAL:
		if(pass_type.eq.D_RET_VAT_INC)
			xcall f_calc_vatexc( pass_val, , , rtn_val, vat_rates[vloop] )
		else
			xcall f_calc_vat( pass_val, , rtn_val, vat_rates[vloop] )
		D_RET_VAT_EXC:
		if(pass_type.ne.D_RET_VAT_EXC)
			xcall f_calc_vatexc( pass_val, , rtn_val, , vat_rates[vloop] )
		D_RET_VAT_INC:
		if(pass_type.ne.D_RET_VAT_INC)
			xcall f_calc_vatinc( pass_val, , rtn_val, , vat_rates[vloop] )
	endcase
	xreturn
.end

.subroutine whgine_vat_reconcile
	a_vat_inc,              n               ; passed in with
	a_vat_exc,              n
	a_vat_rate,             n
	a_inp_wndid,            n
	a_fldnam,                       a
	.include 'gold_com' repository, group = 'gold_com'

.proc
	a_vat_exc=((a_vat_inc*100000)/(1000+a_vat_rate))#2
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for hide attach on wgd
;
.function whgine_aft_hide_att, ^val
	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group = 'whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group = 'fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:CM4REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

.proc

	f_hide_attach = a_data_stored

	freturn D_OK
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_disp_vj_curr_vals    ; general currency value display

	.include 'gold_com' repository, group='gold_com'
	.include 'whgine_vj' repository, group='whgine_vj'
	a_wndid,        n
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       when not base currency, the screen is split into two columns
        ;       of values and this routine is responsible for maintaining
        ;       the non input fields
.proc
	xcall whgine_set_vj_curr_flds(whgine_vj, whgine_passed, invoice_totals)

	if(f_wg_md_disc)
	begin
		xcall i_dspfld(a_wndid,'vj_fc_disc',vj_fc_disc, gold_com)
		xcall i_dspfld(a_wndid,'vj_fc_sett',vj_fc_sett, gold_com)
	end

	if(pass_gen_data.vi_currency .ne. cms_base_cur) then
	begin
		if(wg_security .ne. ACC_NO_COST_DISP.and..not. pass_gen_data.plan_maint)
		begin
			xcall i_dspfld(a_wndid,'vj_fc_ecos',vj_fc_ecos, gold_com)
			xcall i_dspfld(a_wndid,'vj_fc_cost',vj_fc_cost, gold_com)
		end
		if(.not. pass_gen_data.plan_maint) then
			xcall i_dspfld(a_wndid,'vj_d_bc_mrrp',vj_d_bc_mrrp, gold_com)
		else
			xcall i_dspfld(a_wndid,'vj_dsp_pm_bc_charge',vj_dsp_pm_bc_charge, gold_com)
		xcall i_dspfld(a_wndid,'vj_bc_rrp',vj_bc_rrp, gold_com)
		xcall i_dspfld(a_wndid,'vj_bc_disc',vj_bc_disc, gold_com)
		xcall i_dspfld(a_wndid,'vj_bc_sett',vj_bc_sett, gold_com)
	end

	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for vj discount field
.function whgine_vj_disc_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:CM4REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

	external function
		f_curr_bc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		fldnam,         a20

.proc
	a_pending_status = %currency_na_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj, gold_com, gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status

	; NOTE THE CURRENT FIELD MAY BE EITHER VAT INCLUSIE OR EX VAT
	; DEPENDING ON INVOICE TAB
	fldnam = %i_getstring( inp_wndid, inp_fldnam )

	if(vj_fc_rrp.ge.0.and.
	&  ((fldnam(%trim(fldnam)-6:7).eq.'VI_DISC'.and.
	&  ^d(a_data_stored) .gt. vj_fc_vi_rrp).or.
	&  (fldnam(%trim(fldnam)-6:7).ne.'VI_DISC'.and.
	&  ^d(a_data_stored) .gt. vj_fc_rrp)))
	begin
		xcall ibc_message('Invalid - Discount Value may not be > '
		&                       +'Retail Value')
		freturn D_EMITTEDERR
	end

	; NOTE THE CURRENT FIELD MAY BE EITHER VAT INCLUSIE OR EX VAT
	; DEPENDING ON INVOICE TYPE PROGRAM CODE

	xcall i_putfld(inp_wndid,'*CURR*', whgine_vj, fldnam,
	&               ^d(a_data_stored), gold_com)

	; want to either populate the vat inclusive value or ex vat price
	; depending on invoice type (vat inc or otherwise)

	if(fldnam(%trim(fldnam)-6:7).eq.'VI_DISC') then
	begin
		xcall whgine_vat_calc(vj_fc_disc, vj_vat,
		&        vt_vat_code, vt_vrat, vj_fc_vi_disc,
		&        D_RET_VAT_INC, D_RET_VAT_EXC)
		xcall i_dspfld(inp_wndid,'vj_fc_disc',vj_fc_disc, gold_com)
	end
	else
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
			vj_fc_vi_disc=vj_fc_disc
		else
			xcall whgine_vat_calc(vj_fc_vi_disc, vj_vat,
			&        vt_vat_code, vt_vrat, vj_fc_disc,
			&        D_RET_VAT_EXC, D_RET_VAT_INC)
		if(.not. pass_gen_data.plan_maint)
			xcall i_dspfld(inp_wndid,'vj_fc_vi_disc',vj_fc_vi_disc, gold_com)
	end
	if(cms_currency.and.pass_gen_data.vi_currency.ne.cms_base_cur)
	begin
		vj_bc_vi_disc = %f_curr_bc(vj_fc_vi_disc, pass_gen_data.vi_exch_rate)
		if(.not. pass_gen_data.plan_maint)
			xcall i_dspfld(inp_wndid,'vj_bc_vi_disc',vj_bc_vi_disc, gold_com)
		vj_bc_disc = %f_curr_bc(vj_fc_disc, pass_gen_data.vi_exch_rate)
		xcall i_dspfld(inp_wndid,'vj_bc_disc',vj_bc_disc, gold_com)
	end

	xcall set_settlement_default(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)
	freturn D_OK
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for vj settlement field
function whgine_vj_sett_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:CM4REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

	external function
		f_curr_bc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

proc
	a_pending_status = %currency_na_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj, gold_com, gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status

	if(cms_user_id .eq. 10060 .and. pass_gen_data.no_sett .and. ^d(a_data_stored))
	begin
		xcall ibc_message(T$MSF_NO_SETT,D_BELL)
		clear a_data_stored
	end

	a_pending_status = %WHGINE_Sett_Valid(^d(a_data_stored), (vj_fc_rrp - vj_fc_disc))
	if (a_pending_status == D_OK)
	begin
		vj_fc_sett = ^d(a_data_stored)
		if(cms_currency.and.pass_gen_data.vi_currency.ne.cms_base_cur)
		begin
			vj_bc_sett = %f_curr_bc(vj_fc_sett, pass_gen_data.vi_exch_rate)
			xcall i_dspfld(inp_wndid,'vj_bc_sett',vj_bc_sett, gold_com)
		end

		if(cms_currency.and.pass_gen_data.vi_currency.ne.cms_base_cur)
		begin
			vj_bc_sett = %f_curr_bc(vj_fc_sett, pass_gen_data.vi_exch_rate)
			xcall i_dspfld(inp_wndid,'vj_bc_sett',vj_bc_sett, gold_com)
		end

		xcall whgine_disp_vj_curr_vals(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)
	end
	freturn a_pending_status
endfunction

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; validate settlement discount
function WHGINE_Sett_Valid, ^val
	req in	aSettDisc,				n	; settlement value
	req	in	aRetailLessDiscount,	n	; retail less discount
	endparams

	record lGeneral
		aReturnError,	int
	endrecord
proc
	if (aSettDisc && aSettDisc >= aRetailLessDiscount)
	begin
		xcall ibc_message('Invalid - Settlement Discount may not be >= Retail less Discount Value')
		aReturnError = D_EMITTEDERR
	end
	else
		aReturnError = D_OK
	freturn aReturnError
endfunction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for standard warranty start date
function whgine_vj_warr_sdat_chg, ^val
	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'aWhgine_VJ'
    endparams

	.include 'SRC:OPSCOM.REC'

proc
	if (a_data_stored && a_data_stored < %ndate)
	begin
		xcall ibc_message('Warning - Standard Warranty Start Date earlier than today')
	end
	else
	begin
		if (aWhgine_VJ.vj_warr_edat && a_data_stored  > aWhgine_VJ.vj_warr_edat)
			xcall ibc_message('WARNING - Standard Warranty Start Date Later than Standard Warranty End Date')
	end
	freturn D_OK
endfunction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for standard warranty end date
function whgine_vj_warr_edat_chg, ^val
	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'aWhgine_VJ'
    endparams

	.include 'SRC:OPSCOM.REC'

proc
	a_pending_status = D_OK

	if (a_data_stored  < aWhgine_VJ.vj_warr_sdat)
	begin
		a_pending_status = D_EMITTEDERR
		xcall ibc_message('Invalid - Standard Warranty End Date earlier than start date')
	end
	else
	begin
		if (a_data_stored && a_data_stored < %ndate)
		begin
			xcall ibc_message('Warning - Standard Warranty End Date earlier than today')
		end
		else
		begin
			if (aWhgine_VJ.vj_ex_warr_edat && a_data_stored > aWhgine_VJ.vj_ex_warr_edat)
				xcall ibc_message('WARNING - Extended Warranty End Date earlier than Standard Warranty End Date')
		end
	end
	freturn a_pending_status
endfunction
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for extended warranty end date
.function whgine_vj_ex_warr_edat_chg, ^val

	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'

	.include 'SRC:OPSCOM.REC'

.proc
	if(a_data_stored.and.a_data_stored.lt.vj_warr_edat)
	begin
		xcall ibc_message('Invalid - Extended Warranty End Date earlier than Standard Warranty End Date')
		freturn D_EMITTEDERR
	end
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       This subroutine checks settelement value and if > 20% og
        ;       sales values displays warning message.  This is a very high
        ;       percentage and it is designed to warn of he potential problem
        ;       where the user think they should enter tyhe settlement value
        ;       rather than settlement discount.
        ;       Also, warns if margin for the line is < 0
.subroutine whgine_check_vj_marg
	.include 'whgine_vj' repository, group = 'whgine_vj'

.proc
	if(vj_fc_sett.and.vj_fc_rrp.gt.0.and.vj_fc_sett .gt. (vj_fc_rrp - vj_fc_disc) * 0.2)
		xcall ibc_message('Warning - Settlement Discount Value Greater'
		&                 +' Than 20% of Retail')

	if(vj_fc_rrp.gt.0.and.
	&       (vj_fc_rrp - vj_fc_disc - vj_fc_cost - vj_fc_sett .lt. 0))
		xcall ibc_message('Warning - Total Costs Exceed Invoice Value For '
		&                 +'This Line')

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_check_crlim, ^val
	a_mode,         a
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'add_part_passed' repository, group='add_part_passed'

	.include 'SRC:OPSCOM.REC'
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		tmp_bal,        i8
		tmp_new_line_val,i8
.proc
	if(crlim_pass_ent) freturn D_OK

	if(pass_gen_data.h_ivcr.eq.D_VIIVCR_CREDIT.or.pass_gen_data.h_ivcr.eq.D_VIIVCR_PART_CRED)
		freturn D_OK
	if(a_mode.eq.D_LISTIAD_DEL)
		freturn D_OK
	tmp_bal=adv_t_retail

	if(a_mode.ne.D_LISTIAD_INS)     ; subtract old val
		tmp_bal-=lst_tot_retail-lst_dsp_disc

	set tmp_new_line_val=vj_fc_rrp-vj_fc_disc

	tmp_bal+=tmp_new_line_val
	if(h_cm4_cred_wg)
		clear tmp_bal
	freturn %check_crlim(h_acc, tmp_bal,crlim_pass_ent)
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_cust_check, ^val
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	crlim_pass_ent,         n

	.include 'SRC:OPSCOM.REC'
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		reject, i4
		cr_check,i4
.proc

	cr_check=(pass_gen_data.adv_mode.eq.D_VEW_MODE)
	if(h_cm4_cred_wg.or.pass_gen_data.adv_mode.eq.D_VEW_MODE.or.crlim_pass_ent.ge.1) then
		xcall cust_check(vi_cust, reject,,,,true,(pass_gen_data.adv_mode.eq.D_VEW_MODE)
		&           ,,(adv_t_retail*(1-h_cm4_cred_wg)),cr_check,aged_bals_grp, crlim_pass_ent)
	else
		xcall cust_check(vi_cust, reject,,,,,,,(adv_t_retail*(1-h_cm4_cred_wg)),cr_check
		&           ,aged_bals_grp, crlim_pass_ent)
	freturn reject
.end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       This section evaluates whether or not the hide attachments
;       option is relevant and sets prompt, field accordingly
.subroutine evaluate_vj_hide_attach
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if (f_attach) then
	begin
		if (pass_gen_data.adv_mode.ne.D_VEW_MODE) then
		begin
			if (vj_hide_ln) then
			begin
				vj_hide_att = vj_hide_ln
				xcall ibc_disable(pass_gen_data.inp_vj_id,'vj_hide_att')
			end
			else
			begin
				xcall ibc_enable(pass_gen_data.inp_vj_id,'vj_hide_att')
			end
		end
		xcall i_dspfld(pass_gen_data.inp_vj_id,'vj_hide_att',vj_hide_att)
	end
	else
		xcall ibc_disable(pass_gen_data.inp_vj_id,'vj_hide_att')

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for vj settlement field
.function whgine_vj_hide_ln_change, ^val

	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'

.proc
	if a_pending_status .eq. D_OK .and. g_entnam .ne. 'J_QUIT'
	begin
		vj_hide_ln = a_data_stored
		xcall evaluate_vj_hide_attach(whgine_vj, whgine_passed)
	end

	freturn a_pending_status
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for customer field
.function whgine_trd_tstk_change, ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'

	.include 'SRC:OPSCOM.REC'

.proc
	a_pending_status = %vm_change(a_data_entered,a_data_stored,
	&       a_pending_status,inputinfo,whgine_vb)

	if (g_select .and. (g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL') .or.
	&   a_pending_status .ne. D_OK)      ; Menu entry
		freturn a_pending_status

	trd_create = g_entnam .eq. 'WGD_CREATE'

	xcall m_signal('TRD_STK')

	freturn a_pending_status
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : arrive method for trade ins
;
.subroutine whgine_trd_arv
	a_status,       n
	a_listid,       n
	a_win_event,    n
	.include 'whgine_vb' repository, group = 'whgine_vb'
	a_inpid,        n
	a_disabled,     n
	a_index,        n
	a_row,          n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'fkeys' repository, group='temp_fkeys'    ; new
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
.proc

	xcall whgine_trd_tab_set_fkeys(a_listid, whgine_vb, fkeys, whgine_passed, whgine_inv_tab)
	xcall ibc_fkeys(a_listid, fkeys, true)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : pre-process method for trade ins
;
.subroutine whgine_trd_prc
	a_listid,       n
	a_inpwndid,     n
	.include 'whgine_vb' repository, group='whgine_vb'
	a_mode,         a
	a_filechn,      n
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	a_dummy_fkeys,          a
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'add_part_passed' repository, group='add_part_passed'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

.proc

	xcall whgine_trd_tab_set_fkeys(a_listid, whgine_vb, fkeys, whgine_passed, whgine_inv_tab)

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
subroutine whgine_trd_tab_set_fkeys
	a_listid,       n
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'

	endparams

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		no_items,       d3
	endrecord
proc

	xcall l_status(a_listid, D_LLASTITM, no_items)
	if (pass_gen_data.adv_mode != D_VEW_MODE)
	begin
		fkeys.fkey[D_FK_NO2].disabled_flg = ((!
		&   ((line_count || pass_chn_data.h_prog_code == P_COD_SEL_BILL)
		&  && pass_gen_data.h_ivcr != D_VIIVCR_PART_CRED)) || whgine_passed.f_vsp_exists)

		if (vb_wg_attach || no_items == 0)
		begin
			fkeys.fkey[D_FK_NO3].disabled_flg = true
			fkeys.fkey[D_FK_NO4].disabled_flg = true

			fkeys.fkey[D_FK_NO7].disabled_flg = true
		end
		else
		begin
			fkeys.fkey[D_FK_NO3].disabled_flg = false
			fkeys.fkey[D_FK_NO4].disabled_flg = false

			fkeys.fkey[D_FK_NO7].disabled_flg =
			&  (! sb_line_count
			&   ||  pass_gen_data.h_ivcr != D_VIIVCR_INVOICE
			&   ||  pass_gen_data.adv_mode == D_VEW_MODE
			&   ||  vb_wg_attach)
		end
	end
	else
	begin
		fkeys.fkey[D_FK_NO2].disabled_flg = true
		fkeys.fkey[D_FK_NO3].disabled_flg = true
		fkeys.fkey[D_FK_NO4].disabled_flg = true

		fkeys.fkey[D_FK_NO7].disabled_flg = true
	end
	xreturn

endsubroutine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Desc : Insertion initialisation routine for wholegood
;
.function whgine_trd_init, ^val
	a_listid,       n
	a_inpwndid,     n
	.include 'whgine_vb' repository, group = 'whgine_vb'
	a_mode,         a
	a_filechn,      n
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'fkeys' repository, group = 'fkeys'
	.include 'fkeys' repository, group = 'ifkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group = 'fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'add_part_passed' repository, group = 'add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'

	external function
		f_format_money, a
		f_yes_no,       d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		.include 'vmrec' repository, group='lVMRec'
		.include 'vm_user' repository, group='vm_user'
		.include 'vw_user' repository, group='vw_user'
		err,            d2
		tmp_rate,       d4
		lChr,			a1
	endrecord

.proc
	unlock pass_chn_data.chn(HM_FILE)
	unlock pass_chn_data.chn(VM_FILE)
	clear gen
	xcall set_line_mode(a_mode)
	if (.not. vb_wg_attach) then
	begin
		case a_mode of
		begincase
			D_LISTIAD_INS:
			begin
				xcall i_init( a_inpwndid )
				xcall ibc_disable(D_SET, a_inpwndid, 'vb_inpset')
				xcall ibc_enable(a_inpwndid, 'VB_TSTK')
				vb_used = true
				ifkeys.fkey[D_FK_NO2].disabled_flg = FALSE
				ifkeys.fkey[D_FK_NO3].disabled_flg = FALSE
				ifkeys.fkey[D_FK_NO4].disabled_flg = TRUE
				ifkeys.fkey[D_FK_NO5].disabled_flg = TRUE
				; WG7460                ifkeys.fkey[D_FK_NO6].disabled_flg = TRUE
				vjnstk = D_VJ_TRADE
			end
			D_LISTIAD_AMD:
			begin
				if (%xf_file(pass_chn_data.chn(HM_FILE), lVMRec, vb_tstk, 'RD',,, Q_NO_TLOCK))
					clear lVMRec
				xcall ibc_enable(D_SET, a_inpwndid, 'vb_inpset')
				xcall ibc_disable(a_inpwndid, 'VB_TSTK')
				if pass_gen_data.vi_currency .eq. cms_base_cur
					xcall ibc_disable(a_inpwndid, 'vb_tip_fc')
				else
					xcall ibc_disable(a_inpwndid, 'vb_tip_bc')
				if (lVMRec.vmsold && lVMRec.vmivno)
					xcall ibc_disable(a_inpwndid, 'vb_rrp_bc')
				else
					xcall ibc_enable(a_inpwndid, 'vb_rrp_bc')
				if pass_gen_data.adv_mode .eq. D_VEW_MODE then
				begin
					ifkeys.fkey[D_FK_NO6].disabled_flg = TRUE
				end
				else
				begin
					ifkeys.fkey[D_FK_NO2].disabled_flg = FALSE
					ifkeys.fkey[D_FK_NO3].disabled_flg = FALSE
					ifkeys.fkey[D_FK_NO4].disabled_flg = FALSE
					ifkeys.fkey[D_FK_NO5].disabled_flg = FALSE
					ifkeys.fkey[D_FK_NO6].disabled_flg = FALSE
				end

				if .not. vb_wg_attach then
					vb_attach_tot = %get_attach_tot(vb_tstk, false, whgine_passed, invoice_totals)
				else
					clear vb_attach_tot
				xcall whgine_calc_oa(gold_com, whgine_passed, whgine_vb)
				xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)
				if pass_gen_data.adv_mode .ne. D_VEW_MODE.and..not.vb_wg_attach
				begin
					call check_upd_qual_and_vat
					if(err) freturn(err)
				end
				xcall i_display(a_inpwndid, 'vb_full_set', whgine_vb,,,,,,,,,,
				&                   gold_com, gold_ax)
			end
		endcase
		xcall i_user( pass_gen_data.inp_vb_id, 'vb_tstk',vm_user )
		if vm_user.vm_user_mh
			vm_user.vm_user_mh = %mem_proc(DM_FREE, vm_user.vm_user_mh)
		clear vm_user, vm_user.vm_user_mh
		vm_user.chk_option = D_ON_ORD_ONLY
		vm_user.chk_allow_create = true
		xcall i_user( pass_gen_data.inp_vb_id, 'vb_tstk',,vm_user )
		clear vw_user
		vw_user.allow_new = true
		xcall i_user(pass_gen_data.inp_vb_id, 'vb_code',, vw_user)

		if .not. vb_code
			xcall i_init(a_inpwndid, 'vb_inpset', whgine_vb, 'vb_code')
		if .not. vb_grp
			xcall i_init(a_inpwndid, 'vb_inpset', whgine_vb, 'vb_grp')
		if .not. vb_mak
			xcall i_init(a_inpwndid, 'vb_inpset', whgine_vb, 'vb_mak')

		call format_vb
		if .not. vb_wg_attach then
			vb_attach_tot = %get_attach_tot(vb_tstk,true, whgine_passed, invoice_totals)
		else
			clear vb_attach_tot

		; SET QUAL FIELD
		xcall whgine_set_vb_qualifying_field(a_inpwndid, whgine_vb)
		xcall whgine_set_trd_vat_code(a_inpwndid, whgine_vb)

		xcall evaluate_vb_hide_attach(whgine_vb, whgine_passed)
		xcall i_next(a_inpwndid, 'vb_inpset', '*FRST*')
	end
	else
	begin
		if (pass_gen_data.vi_currency.ne.cms_base_cur)
			set vb_atd_cost_curr, vb_atd_ecos_curr = base_desc
		if (pass_gen_data.vi_currency.ne.cms_base_cur)
			set vb_atd_cost_curr, vb_atd_ecos_curr = base_desc
		if (pass_gen_data.vi_currency .ne. cms_base_cur)
			vb_atd_rrp_curr = curr_desc

		vb_atd_t_ecost = vb_net_fc * vb_atd_ord_qty
		vb_atd_t_cost = vb_tip_fc * vb_atd_ord_qty
		vb_atd_t_rrp = vb_rrp_fc * vb_atd_ord_qty

		xcall i_display(vb_atd_id,'wgd_fullset',whgine_vb,,,,,,,,,,
		&                 gold_com )
		xcall i_frames(vb_atd_id, 'wgd_fullset')

		xcall ibc_disable(D_ALL, vb_atd_id)

		ifkeys.fkey[D_FK_NO2].disabled_flg = TRUE
		ifkeys.fkey[D_FK_NO3].disabled_flg = TRUE
		ifkeys.fkey[D_FK_NO4].disabled_flg = TRUE
		ifkeys.fkey[D_FK_NO5].disabled_flg = TRUE
		ifkeys.fkey[D_FK_NO6].disabled_flg = TRUE
		ifkeys.fkey[D_FK_NO7].disabled_flg = TRUE
		ifkeys.fkey[D_FK_NO8].disabled_flg = TRUE
	end

	csp_comtype = CMNT_WG_WSJ_INST
	csp_comacc = vb_tstk
	csp_comview = 9
	csp_comscrex=false
	if vb_tstk && %ScratchPadCheck(CMNT_WG_WSJ_INST,vb_tstk) then
		xcall ibc_fkeys_set_txt('PdiIns*',D_FK_NO8,ifkeys, true)
	else
		xcall ibc_fkeys_set_txt('PdiIns ',D_FK_NO8,ifkeys, true)
	csp_comview = FALSE                                                     ; allow amend

	xcall ibc_fkeys(a_inpwndid, ifkeys)

.ifndef D_GUI
	if (vb_wg_attach)
		xcall ibc_chr(lChr, vb_atd_id, , , , , ifkeys)

.endc

	freturn D_NO_ERROR

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       loads the vehine_vj input window after opening environment
        ;       Also, formats money fields
	format_vb,
	call draw_vb_lines

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       draws lines for multicurrency transaction
	draw_vb_lines,
	if (.not.cms_currency.or.pass_gen_data.vi_currency.eq.cms_base_cur)
		return
	if (.not.vb_line1_id)
	begin
		xcall w_proc(WP_CREATE, vb_line1_id, 'window_vb1',1, 25)
		xcall w_proc(WP_CREATE, vb_line2_id, 'window_vb2',7, 1)
	end
	xcall SetParent(a_inpwndid, vb_line1_id)
	xcall SetParent(a_inpwndid, vb_line2_id)
	.ifdef D_GUI
		xcall w_proc(WP_PLACE, vb_line1_id,  4, 54)
		xcall w_proc(WP_PLACE, vb_line2_id,  5, 66)
	.else
		xcall w_proc(WP_PLACE, vb_line1_id,  4, 54)
		xcall w_proc(WP_PLACE, vb_line2_id,  5, 66)
	.endc
	xcall w_disp(vb_line1_id, WD_VLINE, 1,14,1, WD_HLINE, 1,1,25 )
	xcall w_disp(vb_line1_id, WD_POS, 1, 8, WD_FIELD, base_desc )
	xcall w_disp(vb_line1_id, WD_POS, 1, 21, WD_FIELD, curr_desc)
	xcall w_disp(vb_line2_id, WD_VLINE, 1,14,7)
	xcall w_brdr(vb_line1_id,WB_OFF)
	xcall w_brdr(vb_line2_id,WB_OFF)

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       check qualifying flag and vat code against customer vat reg no
        ;       if vat reg no and qual no or vat no then question this and
        ;       offer option to reset.
	check_upd_qual_and_vat,
	clear err
	if(a_mode.eq.D_LISTIAD_AMD.and.
	&        vi_vatreg.and.(cms_country.eq.UK_VAT.or.cms_country.eq.EIRE_VAT))
	begin
		if(vb_qualify.eq.false) then
		begin
			;1234567890123456789012345678901234567890123456789012345678901234567890
			case
			& %f_yes_no( 'WARNING - This item has the Qualifying field set to No (VAT\n'
			&           +'Margin Scheme).  Normally, this would be set to Yes for a\n'
			&           +'VAT Registered customer. It may be that when the item was\n'
			&           +'entered, the VAT Reg No was unknown but has since been set.\n'
			&           +'Would you like to set this to yes now?'
			&                ,,,true,false) of
			begincase
			D_USER_ABORT:   err=D_USER_ABORT
			D_NO:           nop
			D_YES:          begin
				vb_qualify=D_TRUE
				vb_vat = pass_gen_data.sb_vat_code
			end
			endcase
		end
		else
		begin
			xcall f_vat_rate( vb_vat, tmp_rate )
			if(! tmp_rate)
			begin
				;1234567890123456789012345678901234567890123456789012345678901234567890
				case
				& %f_yes_no ('WARNING - This item has a zero rated VAT Code.\n'
				&           +'Normally, this would not be set to zero for a VAT \n'
				&           +'Registered customer. It may be that when the item was\n'
				&           +'entered, the VAT Reg No was unknown but has since been set.\n'
				&           +'Would you like to set this to non zero now?'
				&                ,,,true,false) of

				begincase
				D_USER_ABORT:   err=D_USER_ABORT
				D_NO:           nop
				D_YES:          begin
					vb_vat = pass_gen_data.sb_vat_code
				end
				endcase
			end
		end
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgineleave_vbType_NU, ^val ,reentrant
	.include "WND:inpinf.def"       ; Group argument of input info
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'GOLD_COM'     repository, group = 'gold_com'
	.include 'GOLD_AX'      repository, group = 'gold_ax'

	.include "WND:tools.def"
	.include 'SRC:CMSCOM.REC'

.proc
	xcall whgine_set_vb_qualifying_field(inp_wndid, whgine_vb)
	xcall whgine_set_trd_vat_code(inp_wndid, whgine_vb)

	freturn D_OK

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ROUTINE TO SET QUALIFY FLAG ON TRADE IN (CORRESPONDS TO VM_QUALIFY)
; Note that the rukles are, the field is always available for entry if
; Eire.  If uk then only available if user vehicle unless Rickerbies (10436)
; where always true and not entered.
.subroutine whgine_set_vb_qualifying_field
	inp_wndid,              n
	.include 'whgine_vb' repository, group='whgine_vb'
endparams

.include 'SRC:CMSCOM.REC'
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if (vb_used && cms_user_id != 10436)
	begin
		xcall ibc_enable(inp_wndid, 'vb_qualify')
		if (pass_chn_data.line_mode == D_INS_MODE && (cms_country == UK_VAT || cms_country == EIRE_VAT))
		begin
			if (! pass_gen_data.h_vatreg || vb_type)
			begin
				vb_qualify = false
			end
			else
			begin
				vb_qualify = true
			end
		end
	end
	else
	begin
		if (! vb_qualify_alw)
		begin
			vb_qualify = true
		end
		xcall ibc_disable(inp_wndid, 'vb_qualify')
	end
	xcall i_dspfld(inp_wndid, 'vb_qualify', vb_qualify)
	
	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ROUTINE TO SET TRADE IN VAT CODE DEPENDING ON VARIOUS OTHER SETTINGS
.subroutine whgine_set_trd_vat_code
	inp_wndid,              n
	.include 'whgine_vb' repository, group='whgine_vb'
	pass_vat,               n       ; optional - default code


	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record
		tmp_rate,   d4

.proc
	xcall f_vat_rate( vb_vat, tmp_rate, D_YES )
	if(.not.vb_vat.or.(vb_vat.and. tmp_rate))
	begin
		if((.not.pass_gen_data.h_vatable.or..not.pass_gen_data.h_vatreg).or.
		&  ((cms_country.eq.UK_VAT.or.cms_country.eq.EIRE_VAT).and.
		&  vb_used.and..not.vb_qualify))
		begin
			vb_vat=pass_gen_data.sb_vat_zero
		end
	end
	if(.not.vb_vat)
	begin
		if (cms_country.eq.EIRE_VAT) then
			vb_vat=pass_gen_data.sb_vat_code
		else
		begin
			if(%passed(pass_vat).and.pass_vat)
				vb_vat=pass_vat
		end
	end
	if (.not. vb_vat)
		vb_vat = pass_gen_data.sb_vat_code
	xcall i_dspfld(inp_wndid,'vb_vat',vb_vat)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       process the trade in price.  Different processing depending on
        ;       currency selected
.subroutine whgine_valid_trd_pri

	.include 'WND:inpinf.def'       ; layout for a_inpinfo
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group = 'dummy_fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'

	external function
		f_curr_bc,      d

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		fldnam,         a15


.proc
	xcall whgine_trd_vb_gen_leave(inputinfo, whgine_vb, gold_com, gold_ax,
	&                             dummy_fkeys, whgine_passed)

	if(pass_gen_data.vi_currency.ne.cms_base_cur)
		vb_tip_bc=%f_curr_bc(vb_tip_fc,pass_gen_data.vi_exch_rate)

	fldnam = %i_getstring(inp_wndid, inp_fldnam )
	if((vb_tip_bc.and.fldnam.eq.'VB_TIP'.and.vb_tip_bc.ne.vb_h_tip_bc)
	&  .or.fldnam.eq.'VB_VAT'.or.fldnam.eq.'VB_QUALIFY')
	begin
		vb_net_bc=vb_tip_bc
		xcall i_dspfld(pass_gen_data.inp_vb_id,'vb_net_bc',vb_net_bc, gold_com, gold_ax)
	end
	xcall whgine_calc_oa(gold_com, whgine_passed, whgine_vb)
	xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)

	; if there is a max value for which to write off trade ins and the tip is
	; greater than this and washout complete set then override and assume user
	; does not want to do this

	if(cms_wgc_value.and.vb_tip_bc.gt.cms_wgc_value.and.vb_wash_comp)
	begin
		xcall ibc_message('The Washout Complete Indicator is set '
		&                       +'but the trade in price is greater than maximum '
		&                       +'write off value - Will reset but you may override '
		&                       +' this if required.')
		clear vb_wash_comp
		xcall i_dspfld(pass_gen_data.inp_vb_id,'vb_wash_comp',vb_wash_comp)
	end

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       calculate over allowance based on tip - net stock price
.subroutine whgine_calc_oa

	.include 'gold_com' repository, group='gold_com'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_vb' repository, group = 'whgine_vb'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if(f_wg_mv_comm)
	begin
		vb_book_wd_bc=(vb_rrp_bc * (10000-VB_BOOK_WD_P))#4
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_book_wd_bc', vb_book_wd_bc, gold_com)

		vb_net_bc = vb_book_wd_bc - vb_e_repairs_bc - vb_e_warr_bc
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_net_bc', vb_net_bc, gold_com)
	end

	; IF EIRE AND QUALIFYING THEN INFLATE HELD TIP PRICE TO BE VAT INCLUSIVE
	vb_oa_bc = vb_tip_bc - vb_net_bc
	xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_oa_bc', vb_oa_bc, gold_com)

	xreturn
.end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       process the trade in price.  Different processing depending on
        ;       currency selected
.subroutine whgine_vb_rrp_leave

	.include 'WND:inpinf.def'       ; layout for a_inpinfo
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys_grp'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'

.proc
	xcall whgine_trd_vb_gen_leave(inputinfo, whgine_vb, gold_com, gold_ax,
	&                             fkeys_grp, whgine_passed)

	xcall whgine_calc_oa(gold_com, whgine_passed, whgine_vb)
	xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for part
;
.subroutine whgine_prt_preprc
	a_listid,	n
	a_inpwndid,	n
	.include 'add_part_str' repository, group='part_data'
	a_mode,		a
	a_filechn,	n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	a_chn,		n
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	endparams

	.include 'SRC:OPSCOM.REC'

.proc
	if (adv_type == POS_CRN_TYPE)
		xcall i_fldmod(a_inpwndid, 'part_sold_qty', , , D_FLD_CHANGE, 'whgine_parts_sold_change')

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for wholegood
;
.function whgine_prt_init, ^val

	a_listid,       n

	a_inpwndid,     n

	.include 'add_part_str' repository, group='part_data'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	a_chn,          n
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'

	.include 'SRC:OPSCOM.REC'
.proc
	xcall set_line_mode(a_mode)

	tot_inv[D_FC] = inv_total
	set tot_prtlab[D_FC], tot_prtlab[D_BC], tot_nett[D_FC] = adv_tot_retail

	freturn D_NO_ERROR
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : arrive method for trade ins
;
.subroutine whgine_wgd_arv

	a_status,       n
	a_listid,       n
	a_win_event,    n
	.include 'whgine_vj' repository, group = 'whgine_vj'
	a_inpid,        n
	a_disabled,     n
	a_index,        n
	a_row,          n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'

	.include 'SRC:OPSCOM.REC'

.proc
	xcall whgine_wgd_tab_set_fkeys(a_listid, whgine_vj, fkeys)
	xreturn
.end

.subroutine whgine_proc_inv_cmnt

	a_wndid ,n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'

	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		lScratchPadIdentifier,	a22

.proc
	.ifndef D_GUI
		xcall ibc_disp_fkeys
	.endc
	xcall ibctab_highlight(tabset_id, true, tabhdr_id)
	fkeys[INV_CMNT_FKEYS].fkey[D_FK_NO3].disabled_flg =
	&       (vistat .ge. D_ADV_INVOICED .or. pass_gen_data.adv_mode .eq. D_VEW_MODE)
	lScratchPadIdentifier = vi_job
	if vi_job .eq. T$AUTO
	begin
		if .not. tmp_job_no
			tmp_job_no = %jbno
		lScratchPadIdentifier = tmp_job_no
	end
	xcall ScratchPadTab(CMNT_WG_INV_STY,lScratchPadIdentifier,a_wndid,fkeys[INV_CMNT_FKEYS],'No Comment')
	xcall ibctab_highlight(tabset_id, false)

	xreturn
.end

function whgine_parts_sold_change,	^val
		a_data_entered		,a	; A buffer containg the field data as
								;  entered by the user.
		a_data_stored		,n	; A buffer for the final storage of the
								;  data.
		a_pending_status	,n	; The result of Toolkit's field
								;  validations.
		.include "WND:inpinf.def"	; Group argument of input info
		.include 'add_part_str' repository, group='part_data'
		;  calling input routine.
		.include 'gold_com' repository, group='gold_com'
		.include 'gold_ax' repository, group='gold_ax'
		.include 'fkeys' repository, group='fkeys'
		.include 'add_part_passed' repository, group='add_part_passed'
		.include 'invoice_totals' repository, group='invoice_totals'
		a_chn,          n
		.include 'whgine_passed' repository, group='whgine_passed'
		group a_fkeys,  [MAX_FKEYS] a
			.include 'fkeys' repository, group='fkeys_grp'
		endgroup
		.include 'whgine_lst' repository, group='whgine_lst'
		.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
		.include 'whgine_hdr' repository, group='whgine_hdr'
		endparams

		.include 'SRC:OPSCOM.REC'
		.include 'SRC:VICOM.REC'

		record lLocal
			lError,			int
			lVIChannel,		int
			lVJChannel,		int
.include 'virec' repository, group = 'inv_virec'
			lMaxCredit,		d9.3
			group vikey5
				vik5_invno,		a6
				vik5_idate,		d8
			endgroup
		endrecord

proc
		a_pending_status = %part_sold_change(a_data_entered, a_data_stored, a_pending_status, inputinfo, part_data,
		&	gold_com, gold_ax, fkeys, add_part_passed, invoice_totals)

		if (a_pending_status != D_OK || (g_select && g_entnam != 'I_OK' && g_entnam != 'I_PREV' && g_entnam != 'I_PREV'))
			freturn a_pending_status

		if (adv_type == POS_CRN_TYPE && virec.vi_orig_invo)
		begin
			lVIChannel = %get_chn(gold_com, VIFILE, 'I:I')
			lVJChannel = %get_chn(gold_com, VJFILE, 'I:I')
			vik5_invno = virec.vi_orig_invo
			vik5_idate = virec.vi_orig_idat
			lError = %xf_file(lVIChannel, inv_virec, vikey5, 'RD', 5)

			clear vjrec
			vjrec.vjjob = inv_virec.vijob
			vjrec.vjtstk = 'part'
			vjrec.vj_line = part_data.part_line
			lError = %xf_file(lVJChannel, vjrec, vjstok, 'RD', 1)
			if (!lError)
			begin
				lMaxCredit = vjsold - vj_qty_credit - vj_qty_cred_wip + part_orig_line_qty
				if (^d(a_data_stored,3) > lMaxCredit)
				begin
					xcall ibc_message('Quantity exceeds maximum credit allowed on this Invoice',  D_ERROR)
					a_pending_status = D_EMITTEDERR
				end
			end
		end

		freturn a_pending_status
endfunction

.subroutine update_virec

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3
.proc
	xcall whgine_set_vi_ignore_ivacc(vi_ignore_ivacc)

	xcall file(pass_chn_data.chn(VI_FILE), virec,vijob,'WR',err)
	if(err) xcall ibc_message('Update error on virec')
	xcall file(pass_chn_data.chn(VI_FILE), virec,vijob,'RD',err)
	if(err)
	begin
		xcall ibc_message('Failure re reading virec after write')
	end
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_vi_ignore_ivacc
	pass_vi_ignore_ivacc,   n

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM5REC.REC'

	record gen
		err,            d3
.proc
	; initially tried to test for .not.cm5rec but even when blank seems
	; to be set to something - therefore check the flag we are
	; interested in specifically - if true, this will cut down on reads.
	if(.not.cm5rec.cm5_wg_ign_inv_to)
	begin
		xcall file(g_com_chn, cm5rec, 5, 'RN', err,,,,,D_NO_LOCK)
		unlock g_com_chn
	end
	pass_vi_ignore_ivacc = cm5_wg_ign_inv_to
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for wholegood
;
.function whgine_nstk_ini, ^val

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:FCFREC.REC'

	.include 'SRC:PMHREC.REC'
	.include 'SRC:PMLREC.REC'

	external function
		f_format_money, a

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		.include 'vm_user' repository, group='vm_user'
		.include 'pmh_user' repository, group='pmh_user'
		input_set,      a12
		non_stk,        d1

.proc
	clear gen
	xcall set_line_mode(a_mode)
	case a_mode of
	begincase
		D_LISTIAD_INS:
		begin
			if(cms_gnavsk)
				vj_tstk=T$AUTO
			if(pass_gen_data.plan_maint)
			begin
				xcall whgine_pm_equip_init(inp_nstk_id, vi_i_pm_contract)
			end
			vjnstk = D_VJ_NSTK
			xcall time(vj_tim_id)
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL) then
			begin
				vj_used = 1             ; used
				vj_type = 1             ; vehicle
			end
			else
			begin
				vj_used = 0             ; new
				vj_type = 0             ; {wholegd}
			end
			vj_vat = %f_vat_get_code(vj_vat, pass_gen_data.h_vatable, cmf_def_vat, cmsrec, ivtrec)
			xcall i_init( a_inpwndid )
		end
	endcase

	call format_vj
	input_set = 'nstk_inpset3'

	if(.not.cms_gnavsk.and..not. pass_gen_data.plan_maint)
	begin
		if(a_mode.eq.D_LISTIAD_INS) then
			xcall ibc_enable(a_inpwndid,'VJ_TSTK')
		else
			xcall ibc_disable(a_inpwndid,'VJ_TSTK')
	end
	if(pass_gen_data.plan_maint) then
	begin
		if(a_mode.eq.D_LISTIAD_INS) then
			xcall ibc_enable(a_inpwndid,'WG_PM_EQUIP_NO')
		else
			xcall ibc_disable(a_inpwndid,'WG_PM_EQUIP_NO')
	end
	else
	begin
		xcall whgine_enable_rrp(cms_currency,pass_chn_data.h_prog_code, a_inpwndid)
		xcall whgine_enable_disc(cms_currency,pass_chn_data.h_prog_code, a_inpwndid)
	end

	xcall i_display(a_inpwndid, 'nstk_fullset', whgine_vj,,,,,,,,,, gold_com,
	&               gold_ax)
	if(.not. vj_tstk.and..not. pass_gen_data.plan_maint)
		xcall i_init(a_inpwndid, input_set, whgine_vj, 'vj_tstk')
	if(.not. pass_gen_data.plan_maint) then
	begin
		if .not. vj_code
			xcall i_init(a_inpwndid, input_set, whgine_vj, 'vj_code')
		if .not. vj_grp
			xcall i_init(a_inpwndid, input_set, whgine_vj, 'vj_grp')
		if .not. vj_mak
			xcall i_init(a_inpwndid, input_set, whgine_vj, 'vj_mak')
		if a_mode .eq. D_LISTIAD_INS
			xcall i_init(a_inpwndid, input_set, whgine_vj, 'vj_used')
	end
	else
	begin
		if .not. whgine_vj.vj_inp_pm_group.wg_pm_equip_no
			xcall i_init(a_inpwndid, input_set, whgine_vj, 'WG_PM_EQUIP_NO')
		if(whgine_vj.vj_inp_pm_group.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING) then
		begin
			xcall whgine_read_pmh_pml(vi_i_pm_contract, whgine_vj, pass_chn_data.chn(PMH_FILE), pass_chn_data.chn(PML_FILE), pmhrec, pmlrec)
			xcall ibc_window( D_PLACE, inp_nstk_clk_id, 6,1)
			xcall i_display(inp_nstk_clk_id,, whgine_vj,,,,,,,,,,gold_com ,gold_ax, pmhrec,pmlrec)
		end
		else
			xcall ibc_window( D_REMOVE,inp_nstk_clk_id)
	end

	xcall i_next(a_inpwndid, input_set, '*FRST*')
	if(pass_gen_data.plan_maint)
	begin
		if(whgine_vj.vj_inp_pm_group.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
			ifkeys.fkey[D_FK_NO3].disabled_flg = false
		else
			ifkeys.fkey[D_FK_NO3].disabled_flg = true
		xcall ibc_fkeys(a_inpwndid, ifkeys)
	end

	freturn D_NO_ERROR

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       loads the vehine_vj input window after opening environment
        ;       Also, formats money fields
	format_vj,
	; if costs allowed to be amended then enable
	if(.not. pass_gen_data.plan_maint)
	begin
		xcall ibc_disable(a_inpwndid,'vj_bc_cost')
		xcall ibc_disable(a_inpwndid,'vj_fc_cost')

		if(wg_security.eq.ACC_DISP_AMEND.and.vj_grp)
		begin
			xcall whgine_get_group(vj_grp,,,,, non_stk)
			if non_stk
			begin
				if(pass_gen_data.vi_currency.ne.cms_base_cur) then
					xcall ibc_enable(a_inpwndid,'vj_bc_cost')
				else
					xcall ibc_enable(a_inpwndid,'vj_fc_cost')
			end
		end

		; EURO TRAILERS SPECIAL (10204) CHANGE PROMPTS
		if(cms_user_id.eq.10204)
		begin
			xcall i_prompt(a_inpwndid,'vj_ser','Chassis No.')
			xcall i_prompt(a_inpwndid,'vj_reg','Ministry')
		end
		call draw_vj_lines
	end
	else
		call draw_pm_lines
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       draws lines for multicurrency transaction
	draw_vj_lines,
	if(.not.cms_currency.or.pass_gen_data.vi_currency.eq.cms_base_cur) return
	if(.not.vj_line1_id)
	begin
		xcall w_proc(WP_CREATE, vj_line1_id, 'window_vj1',1, 20)
		xcall w_proc(WP_CREATE, vj_line2_id, 'window_vj2',8, 1)
	end
	xcall SetParent(a_inpwndid, vj_line1_id)
	xcall SetParent(a_inpwndid, vj_line2_id)

	xcall w_proc(WP_PLACE, vj_line1_id,  4, 59)
	xcall w_proc(WP_PLACE, vj_line2_id,  5, 65)

	xcall w_disp(vj_line1_id, WD_VLINE, 1,7,1, WD_HLINE, 1,1,16 )
	xcall w_disp(vj_line1_id, WD_POS, 1, 2, WD_FIELD, base_desc )
	xcall w_disp(vj_line1_id, WD_POS, 1, 16, WD_FIELD, curr_desc)
	xcall w_disp(vj_line2_id, WD_VLINE, 1,7,8)
	xcall w_brdr(vj_line1_id,WB_OFF)
	xcall w_brdr(vj_line2_id,WB_OFF)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       draws lines for multicurrency transaction
	draw_pm_lines,
	if(.not.cms_currency.or.pass_gen_data.vi_currency.eq.cms_base_cur) return
	if(.not.vj_line1_id)
	begin
		xcall w_proc(WP_CREATE, vj_line1_id, 'window_vj1',1, 25)
		xcall w_proc(WP_CREATE, vj_line2_id, 'window_vj2',3, 1)
	end
	xcall SetParent(a_inpwndid, vj_line1_id)
	xcall SetParent(a_inpwndid, vj_line2_id)

	xcall w_proc(WP_PLACE, vj_line1_id,  9, 54)
	xcall w_proc(WP_PLACE, vj_line2_id,  11, 65)

	xcall w_disp(vj_line1_id, WD_VLINE, 1,12,1, WD_HLINE, 1,1,25 )
	xcall w_disp(vj_line1_id, WD_POS, 1, 7, WD_FIELD, base_desc )
	xcall w_disp(vj_line1_id, WD_POS, 1, 21, WD_FIELD, curr_desc)
	xcall w_disp(vj_line2_id, WD_VLINE, 1,12,4)
	xcall w_brdr(vj_line1_id,WB_OFF)
	xcall w_brdr(vj_line2_id,WB_OFF)
	return

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_pm_equip_init
	inp_nstk_id,    n
	contract_no,    a

	record general
		.include 'pmh_user' repository, group='pmh_user'

.proc
	; NEEDS TO BE CLEARED
	xcall i_user(inp_nstk_id, 'WG_PM_EQUIP_NO', pmh_user)
	if(pmh_user.pmh_user_mh.GT.1000000)
	begin
		clear pmh_user, pmh_user_mh
		xcall i_user(inp_nstk_id, 'WG_PM_EQUIP_NO',, pmh_user)
	end

	xcall pmh_user_clr(inp_nstk_id,'WG_PM_EQUIP_NO')
	xcall i_user(inp_nstk_id, 'WG_PM_EQUIP_NO', pmh_user)
	pmh_user.chk_contract=contract_no
	pmh_user.chk_equip='EQUIP2'
	pmh_user.chk_type=1
	xcall i_user(inp_nstk_id, 'WG_PM_EQUIP_NO',, pmh_user)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       NOTE - THIS CODE REDUNDANT AS AT 06/10/09 AS THERE IS A MORE GENERAL
;       CHANGE METHOD TO  USE
;       HOWEVER, MOST OF THE CODE HAS BEEN PLACED INTO A NEW ROUTINE
;       WHGINE_SET_NSTK_MODEL_DETAILS
.function whgine_model_change ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'invoice_totals' repository, req inout group='invoice_totals'
	endparams

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

	external function
		f_file,         d
		f_curr_fc,      d
		f_curr_bc,      d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		loop,           d2
		non_stk,        d1
.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER'))
		freturn a_pending_status

	a_pending_status = %vw_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj, gold_com, gold_ax)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT')
		freturn a_pending_status

	if a_data_stored
	begin
		if(.not. (%f_file(pass_chn_data.chn(VW_FILE), vwrec, a_data_stored, 'RD',,,
		&  D_NO_LOCK)))
		begin
			xcall whgine_set_nstk_model_details(inp_wndid, whgine_vj, gold_com, gold_ax, whgine_passed, vwrec, whgine_hdr, invoice_totals)

			clear f_new_model
			for loop from 1 thru 10
				vj_spec[loop] = vwspec(loop)
			vj_model = vwmodl

			xcall std_non_stk_costs(a_data_stored, whgine_vj, whgine_passed, invoice_totals)
			if .not. cms_gnavsk
				clear vj_fc_ecos, vj_bc_ecos

			if(pass_gen_data.h_vatable) then
			begin
				if(cms_country .eq. EIRE_VAT) then
					vj_vat = pass_gen_data.h_vat_code
				else
					vj_vat = vwvat
			end
			else
			begin
				if (cmf_def_vat)
					vj_vat = cmf_def_vat
				else
				begin
					if (cms_country == EIRE_VAT)
						vj_vat = ivt_vat_zero
					else
						vj_vat = cms_uk_zero_vat
				end
			end

			if (! vj_vat)
			begin
				if(cms_country == EIRE_VAT)
					vj_vat = pass_gen_data.h_vat_code
				else
					vj_vat = cms_uk_def_vat
			end

			vj_grp = vwgrp
			xcall whgine_get_group(vj_grp, vj_grpdes,,,, non_stk)
			if(wg_security .ne. ACC_NO_COST_DISP)
			begin
				if non_stk
				begin
					if(pass_gen_data.vi_currency .ne. cms_base_cur) then
						xcall ibc_enable(inp_wndid,'vj_bc_cost')
					else
						xcall ibc_enable(inp_wndid,'vj_fc_cost')
				end
			end

			; WHOLEGOOD MULTIPLE DISCOUNTS
			case f_wg_md_disc of
			begincase
				D_CM5_WG_MD_NO:     nop                         ; 0 - not in use
				D_CM5_WG_MD_YES_MODEL:                          ; 1 - Yes - default from wg model
				begin
					vwrec.vw_md_group=vj_inp_md_group
					xcall wg_md_get_disc(vwcode, vwrec)
					vj_inp_md_group=vwrec.vw_md_group
				end
				D_CM5_WG_MD_YES_ADV_HDR:
				begin                       ; 2 - Yes - default from wg advice header
					vj_inp_md_group=vi_def_md_group
				end
			endcase
			vj_mak=vwmake
			xcall whgine_get_make(vj_mak, vj_makdes)

			xcall i_display(inp_wndid, 'nstk_fullset', whgine_vj,,,,,,,,,,
			&               gold_com, gold_ax)
		end
		else
			f_new_model = true
	end
	freturn D_OK



.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       NOTE - THIS CODE REDUNDANT AS AT 06/10/09 AS THERE IS A MORE GENERAL
;       CHANGE METHOD TO  USE
;       HOWEVER, MOST OF THE CODE HAS BEEN PLACED INTO A NEW ROUTINE
;       WHGINE_SET_NSTK_MODEL_DETAILS
.subroutine whgine_set_nstk_model_details
	inp_wndid,      n
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'vwrec' repository, group = 'vwrec'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'invoice_totals' repository, req inout group='invoice_totals'
	endparams

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		loop,           d2
		non_stk,        d1
.proc

	clear f_new_model
	vj_spec[] = vwspec[]
	vj_grp = vwgrp
	vj_model = vwmodl

	xcall std_non_stk_costs(vj_code, whgine_vj, whgine_passed, invoice_totals)
	if .not. cms_gnavsk
		clear vj_fc_ecos, vj_bc_ecos

	if(pass_gen_data.h_vatable) then
	begin
		if(cms_country .eq. EIRE_VAT) then
			vj_vat = pass_gen_data.h_vat_code
		else
			vj_vat = vwvat
	end
	else
	begin
		if (cmf_def_vat)
			vj_vat = cmf_def_vat
		else
		begin
			if (cms_country == EIRE_VAT)
				vj_vat = ivt_vat_zero
			else
				vj_vat = cms_uk_zero_vat
		end
	end

	if (! vj_vat)
	begin
		if(cms_country == EIRE_VAT)
			vj_vat = pass_gen_data.h_vat_code
		else
			vj_vat = cms_uk_def_vat
	end

	vj_grp = vwgrp
	xcall whgine_get_group(vj_grp, vj_grpdes,,,, non_stk)
	; WG7507 - After changing group code on insetion, the cost field
	; was disabled.  Found that the user was set to display costs
	; only and that the code below should have only been allowing cost
	; enabling if user allowed to amend costs.
	; WG7507    if(wg_security .ne. ACC_NO_COST_DISP)
	if(wg_security.eq.ACC_DISP_AMEND)	; WG7507
	begin
		if non_stk
		begin
			if(pass_gen_data.vi_currency .ne. cms_base_cur) then
				xcall ibc_enable(inp_wndid,'vj_bc_cost')
			else
				xcall ibc_enable(inp_wndid,'vj_fc_cost')
		end
	end

	; WHOLEGOOD MULTIPLE DISCOUNTS
	case f_wg_md_disc of
	begincase
		D_CM5_WG_MD_NO:     nop                         ; 0 - not in use
		D_CM5_WG_MD_YES_MODEL:                          ; 1 - Yes - default from wg model
		begin
			vwrec.vw_md_group=vj_inp_md_group
			xcall wg_md_get_disc(vwcode, vwrec)
			vj_inp_md_group=vwrec.vw_md_group
		end
		D_CM5_WG_MD_YES_ADV_HDR:
		begin                       ; 2 - Yes - default from wg advice header
			vj_inp_md_group=vi_def_md_group
		end
	endcase
	;ap0601009          vj_mak=vwmake
	;ap0601009          xcall whgine_get_make(vj_mak, vj_makdes)
	xcall whgine_get_make(vj_mak, vj_makdes)

	xcall i_display(inp_wndid, 'nstk_fullset', whgine_vj,,,,,,,,,,
	&           gold_com, gold_ax)
	xreturn

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_nstk_mnu, ^val

	a_entnam,       a

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:PMLREC.REC'
	.include 'SRC:PMHREC.REC'
	.include 'SRC:PMCREC.REC'
	;               global areas for list processing and the like
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		ret_val,        d1
		start_date,     d8
		end_date,       d8
		h_contract_charge, d10
		err,    i4
		err2,   i4
		req,    i4
.proc
	ret_val = false         ; set to true if invalid value entered
	case a_entnam of
	begincase
		'PML_EQUIP_CHG':
		begin
			call read_pml_pmh_record
			if(err)
				goto vj_tstk_error

			; before anything else, ensure that this line is not already on
			; this advice.  The equipment and series no should be unique
			; enough for this purpose.
			call CheckIfEquipOnAdviceAlready
			if(err)
				goto vj_tstk_error

			xcall file(pass_chn_data.chn(PMC_FILE), pmcrec, pmm_charge_code, 'RD',    err)
			if(err) clear pmcrec

			h_contract_charge=pmlrec.pml_pmmrec_grp.pmm_contract_charge
			xcall pminvx_set_inv_dates(start_date, end_date,
			&         pmc_interval, pmc_frequency , pmhrec, pmlrec, vi_idat, pmc_charge_type,
			&         h_contract_charge, err, 2,,, whgine_hdr.vi_iorc)
			if(err) goto vj_tstk_error

			if(end_date.le.start_date)
			begin
				if(end_date.le.start_date) then
					xcall ibc_message('Default End Invoice Date less than start date')
				else
					xcall ibc_message('Default End Invoice Date same as start date')
			end

			if(.not.vi_cur_cnv) vi_cur_cnv=pass_gen_data.vi_exch_rate
			virec.vi_cr_chrg = whgine_hdr.vi_cr_chrg_inp
			virec.vi_crst=whgine_hdr.vi_crst_inp
			xcall pminvx_set_vjrec_details(vj_tstk,vjrec, pmhrec, pmlrec,
			& pmcrec,virec,ivtrec,cusrec, start_date, end_date,
			& h_contract_charge, err, 2, vi_idat)
			if(err) goto vj_tstk_error

			; having set the majority of the detail in the vjrec rather
			; than whgine_vj record, now need to set whgine_vj
			xcall whgine_init_vj_inp_from_vjrec(whgine_vj,whgine_passed, invoice_totals)

			; costs - price - discounts required
			xcall whgine_display_nstk_screen(gold_com, gold_ax, whgine_vj, whgine_passed, invoice_totals)
			if(pml_sal_date_fr.gt.%ndate)
			begin
				xcall ibc_message('Warning - Contract Start Date later than today')
			end
			if(whgine_vj.vj_inp_pm_group.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
				ifkeys.fkey[D_FK_NO3].disabled_flg = false
			else
				ifkeys.fkey[D_FK_NO3].disabled_flg = true

			xcall ibc_fkeys(a_inpwndid, ifkeys)
			xcall ibc_enable(D_SET, a_inpwndid, 'nstk_inpset3')
			xcall i_next(a_inpwndid, 'nstk_inpset3', 'WG_PM_DESC')

			if false
			begin
				vj_tstk_error,
				if(pass_gen_data.plan_maint)
				begin
					xcall whgine_pm_equip_init(inp_nstk_id, vi_i_pm_contract)
				end
				ret_val = D_ERROR
			end
		end
		'J_SPC_WGD':
		xcall whgine_nstk_spec(gold_com, gold_ax, whgine_vj,,,
		&                      pass_gen_data.adv_mode .eq. D_VEW_MODE, pass_gen_data.plan_maint)
		'J_CLOCK':
		begin
			call read_pml_pmh_record
			xcall file(pass_chn_data.chn(PMC_FILE), pmcrec, pmm_charge_code, 'RD',      err)
			if(err) clear pmcrec
			xcall whgine_pm_clock_entry(gold_com, gold_ax, whgine_vj,
			&        pass_gen_data.adv_mode .eq. D_VEW_MODE, whgine_passed,
			&        invoice_totals, pmhrec, pmlrec, pmcrec)
		end
		"J_CHG_DISC":           ; MULTIPLE DISCOUNTS
		begin
			if(vj_code) then
				xcall whgine_multiple_discount_entry(whgine_vj, gold_com, gold_ax,
				&         whgine_passed, a_inpwndid, whgine_hdr, invoice_totals)
			else
				xcall ibc_message('Invalid - Model Code must be entered first')
		end
	endcase

	freturn ret_val
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ensure that this line is not already on this advice.  The equipment
; and series no should be unique enough for this purpose.
	CheckIfEquipOnAdviceAlready,

	err=false
	xcall l_remove(seq_lst_id)
	xcall l_data(seq_lst_id, D_LFIRST, seq_linp_id, whgine_lst,, err2)
	while .not. err2
	begin
		if(whgine_lst.lst_ntype .eq. D_VJ_NSTK)
		begin
			if(whgine_lst.lst_wg_pm_group.wg_pm_equip_no.eq.pmlrec.pml_equip_no.and.
			&  whgine_lst.lst_wg_pm_group.wg_pm_service_series.eq.pmlrec.pmm_service_series)
			begin
				xcall ibc_message('Invalid - this equipment/series combination has already been selected')
				err=true
				exitloop
			end
		end
		xcall l_data(seq_lst_id, D_LNEXT, seq_linp_id, whgine_lst,, err2)
	end
	xcall l_process(seq_lst_id, req = D_LRESTORE, whgine_lst,,
	&               gold_com, gold_ax,, whgine_passed, invoice_totals)

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	read_pml_pmh_record,

	err=%whgine_read_pmh_pml(vi_i_pm_contract, whgine_vj, pass_chn_data.chn(PMH_FILE), pass_chn_data.chn(PML_FILE), pmhrec, pmlrec)
	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
function whgine_read_pmh_pml,	^val
	pass_contract,          a
	.include 'whgine_vj' repository, group='whgine_vj'
	pmh_chn,        n
	pml_chn,        n
	.include 'pmhrec' repository, group='pmhrec'
	.include 'pmlrec' repository, group='pmlrec'
	opt in aShowErrors,	boolean

	record general
		group pml_k1
			pml_k1_equip,   a8
			pml_k1_contract,a8
			pml_k1_srv_series,d4
		endgroup
		lShowErrors,	boolean
	endrecord
	record i4s
		lError,		i4
		lPMLError,	i4
		lPMHError,	i4
	endrecord

proc
	lShowErrors=true
	if ^passed(aShowErrors)
		lShowErrors=aShowErrors
	pml_k1_contract=pass_contract
	pml_k1_equip=whgine_vj.vj_inp_pm_group.wg_pm_equip_no
	pml_k1_srv_series=whgine_vj.vj_inp_pm_group.wg_pm_service_series
	xcall file(pml_chn, pmlrec, pml_k1, 'RD', lPMLError,1,,,,D_NO_LOCK)
	if(lPMLError && lShowErrors)
		xcall ibc_message('Error reading PML contract line')
	pmh_contract=pml_contract
	pmh_site_add_no=pml_site_add_no
	xcall file(pmh_chn, pmhrec, pmh_key0, 'RD', lPMHError,,,,,D_NO_LOCK)
	if(lPMHError && lShowErrors)
		xcall ibc_message('Error reading PMH contract line')
	lError=(lPMHError || lPMLError)
	freturn lError
endfunction

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Insertion initialisation routine for parts
;
.function whgine_nstk_upd, ^val

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

	external function
		f_yes_no,       d
		f_curr_bc,      d
		f_curr_fc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		at_bottom,      d1
		err,            d3
		loop,           d2
		done_pm_ask,    d1
		replicate_pm_clock,     d1
		req,            i4
		linp_id,        i4
		ret_val,        i4

.proc
	init gen
	replicate_pm_clock=true
	if(%whgine_check_crlim(a_mode, whgine_vj, whgine_lst, whgine_passed,
	&  whgine_inv_tab,add_part_passed))
		freturn D_CLEAR_ENTRY

	req = D_LRESTORE
	xcall l_process( seq_lst_id, req , whgine_lst,, gold_com,
	&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

	if (a_mode != D_LISTIAD_DEL)
	begin
		ret_val = %WHGINE_Sett_Valid(vj_fc_sett, (vj_fc_rrp - vj_fc_disc))
		if (ret_val)
		begin
			xcall i_next(a_inpwndid, '*CURR*', 'VJ_FC_RRP')
			freturn D_REINPUT_ENTRY
		end
	end

	ret_val = D_NO_ERROR
	xcall l_status(seq_lst_id, D_LINPID, linp_id)
	case a_mode of
	begincase
		D_LISTIAD_INS:
		begin
			if(f_wg_md_disc.and..not. pass_gen_data.plan_maint)
			begin
				xcall whgine_multiple_discount_entry(whgine_vj, gold_com, gold_ax,
				&               whgine_passed, a_inpwndid, whgine_hdr, invoice_totals)
			end

			if cms_gnavsk .and. vj_tstk .eq. T$AUTO
			begin
				vjtstk = T$AUTO
				while(vjtstk .eq. T$AUTO)
				begin
					xcall nstk_seq(vj_tstk, err, vi_depot)
					if(.not.err)
						vjtstk = vj_tstk
				end
			end
			xcall whgine_check_vj_marg(whgine_vj)
			call update_extra_text

			if .not. seq_inserting then
				xcall pos_b4_trade(gold_com, gold_ax, a_fkeys, whgine_passed,
				&                  whgine_lst, invoice_totals)
			else
				reseq_req[D_VJ_NSTK+1] = true

			xcall l_process( seq_lst_id, req = D_LAPPEND, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			clear whgine_lst
			list_type=T$NON_STK
			lst_ntype = D_VJ_NSTK
			set lst_stkno, lst_tstk = vj_tstk
			vj_disp_tstk=lst_tstk
			lst_code = vj_code
			lst_model = vj_model
			lst_qty = 1
			xcall whgine_get_cost(vj_dsp_cost, whgine_vj, whgine_passed)
			lst_tot_cost = vj_dsp_cost
			lst_dsp_cost=%f_curr_bc(lst_tot_cost, pass_gen_data.vi_exch_rate)
			set lst_pur_cost = vj_bc_ecos
			set lst_cost = vj_fc_cost

			call set_line_discount

			lst_sett = vj_fc_sett
			set lst_tot_retail, lst_retail = vj_fc_rrp
			lst_vi_retail = vj_fc_vi_rrp
			lst_orig_price = vj_fc_rrp
			lst_rrp = vj_fc_mrrp
			lst_trd_price = vj_fc_trd_price
			lst_tim_id = vj_tim_id
			lst_vat=vj_vat
			lst_used = vj_used
			lst_grp = vj_grp
			lst_mak = vj_mak
			for loop from 1 thru 10
				lst_spec(loop) = vj_spec(loop)
			lst_ser = vj_ser
			lst_reg = vj_reg
			lst_reg_dat = vj_reg_date
			lst_clok = vj_clok
			lst_hide_att = vj_hide_att
			lst_hide = vj_hide_ln

			lst_warr_sdat = vj_warr_sdat
			lst_warr_edat = vj_warr_edat
			lst_warr_end_clock = vj_warr_end_clock
			lst_ex_warr_edat = vj_ex_warr_edat
			lst_ex_warr_end_clock = vj_ex_warr_end_clock
			lst_vj_vmdeld = vj_vmdeld
			lst_vj_vm_extra_comm = vj_vm_extra_comm
			lst_fin_inv = vj_fin_inv
			lst_recv_dat = vj_recv_date
			lst_trd_cmnt = false
			; WG7433            if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL) then
			; WG7433              lst_type = 1
			; WG7433            else
			lst_type = vj_type

			set lst_ucar = false
			; WG7433            if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.lst_used.and.lst_type
			; WG7433&               .and.vj_qual.eq.false)
			if(pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL.and.lst_used
			&               .and.vj_qual.eq.false)
			begin
				lst_ucar=TRUE
			end
			lst_qual=vj_qual
			lst_wg_md_group=vj_inp_md_group
			lst_disp_stkno=lst_stkno
			if(pass_gen_data.plan_maint)
			begin
				lst_extra_text=whgine_vj.vj_extra_text
				whgine_lst.lst_wg_pm_group=whgine_vj.vj_inp_pm_group
				if(whgine_vj.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING.and.vj_inp_act_clock)
				begin
					; if non zero mileage do calc
					if(whgine_lst.wg_pm_curr_clock-whgine_lst.wg_pm_last_clock)
						vj_f_orig_price=vj_f_orig_price/(whgine_lst.wg_pm_curr_clock-whgine_lst.wg_pm_last_clock)
				end
				if(whgine_vj.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING.and.vj_inp_act_clock)
				begin
					vj_f_orig_price=vj_f_orig_price*(whgine_vj.wg_pm_curr_clock-whgine_vj.wg_pm_last_clock)
				end
				lst_orig_price = vj_f_orig_price

				lst_disp_stkno=whgine_lst.lst_wg_pm_group.wg_pm_equip_no
				whgine_lst.list_desc=whgine_lst.lst_wg_pm_group.wg_pm_desc
				lst_inp_act_clock=vj_inp_act_clock
				lst_inp_act_clock_date=vj_inp_act_clock_date
			end
			set vj_prev_batch, lst_prev_batch = false
			lst_moded = true
			xcall set_qty_dp(linp_id, lst_qty_dp)
			xcall i_display(linp_id,, whgine_lst)
			xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			if .not. lst_spec
			begin
				xcall whgine_nstk_spec(gold_com, gold_ax, whgine_vj,,,
				&                        pass_gen_data.adv_mode .eq. D_VEW_MODE, pass_gen_data.plan_maint)
				for loop from 1 thru 10
					lst_spec(loop) = vj_spec(loop)
			end
			if .not.pass_gen_data.plan_maint.and.cms_wg_std_model .and. f_new_model
			begin
				if %f_yes_no('Create New Model Record ? ',,,, false, true) .eq.
				&       D_YES
				begin
					vwcode = vj_code
					vwmake = vj_mak
					vwgrp = vj_grp
					vwmodl = vj_model
					for loop from 1 thru 10
						vwspec(loop) = vj_spec(loop)
					vwrrp = vj_fc_rrp
					vwcost = vj_fc_cost
					vwvat=vj_vat
					if(f_wg_md_disc.eq.D_CM5_WG_MD_YES_MODEL)
					begin
						vw_md_group=vj_inp_md_group
					end

					xcall file(pass_chn_data.chn(VW_FILE), vwrec, vwcode, 'ST', err)
					if err
						xcall ibc_message('Error storing Model Record')
				end
			end
		end
		D_LISTIAD_AMD:
		begin
			xcall whgine_check_vj_marg(whgine_vj)
			clear at_bottom
			call update_extra_text
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			repeat
			begin
				if lst_ntype .eq. D_VJ_NSTK .and. lst_stkno .eq. vj_tstk
				begin
					lst_code = vj_code

					xcall whgine_get_cost(vj_dsp_cost, whgine_vj, whgine_passed)
					lst_tot_cost = vj_dsp_cost
					lst_dsp_cost=%f_curr_bc(lst_tot_cost, pass_gen_data.vi_exch_rate)
					set lst_pur_cost = vj_bc_ecos
					set lst_cost = vj_fc_cost
					call set_line_discount
					lst_sett = vj_fc_sett
					set lst_tot_retail, lst_retail = vj_fc_rrp
					lst_vi_retail = vj_fc_vi_rrp
					lst_rrp = vj_fc_mrrp
					lst_trd_price = vj_fc_trd_price
					lst_vat=vj_vat
					lst_used = vj_used
					lst_type = vj_type
					lst_code = vj_code
					lst_model = vj_model
					lst_grp = vj_grp
					lst_mak = vj_mak
					for loop from 1 thru 10
						lst_spec(loop) = vj_spec(loop)
					lst_ser = vj_ser
					lst_reg = vj_reg
					lst_reg_dat = vj_reg_date
					lst_clok = vj_clok
					lst_hide_att = vj_hide_att
					lst_hide = vj_hide_ln
					lst_warr_sdat = vj_warr_sdat
					lst_warr_edat = vj_warr_edat
					lst_warr_end_clock = vj_warr_end_clock
					lst_ex_warr_edat = vj_ex_warr_edat
					lst_ex_warr_end_clock = vj_ex_warr_end_clock
					lst_vj_vmdeld = vj_vmdeld
					lst_vj_vm_extra_comm = vj_vm_extra_comm
					lst_fin_inv = vj_fin_inv
					lst_recv_dat = vj_recv_date
					lst_moded = true
					lst_wg_md_group=vj_inp_md_group
					lst_disp_stkno=lst_stkno
					if(pass_gen_data.plan_maint)
					begin
						lst_extra_text=whgine_vj.vj_extra_text
						if(whgine_vj.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING.and.vj_inp_act_clock)
						begin
							vj_f_orig_price=vj_f_orig_price/(whgine_lst.wg_pm_curr_clock-whgine_lst.wg_pm_last_clock)
						end
						whgine_lst.lst_wg_pm_group=whgine_vj.vj_inp_pm_group
						if(whgine_vj.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING.and.vj_inp_act_clock)
						begin
							vj_f_orig_price=vj_f_orig_price*(whgine_vj.wg_pm_curr_clock-whgine_vj.wg_pm_last_clock)
						end
						lst_orig_price = vj_f_orig_price
						lst_inp_act_clock=vj_inp_act_clock
						lst_inp_act_clock_date=vj_inp_act_clock_date

						whgine_lst.lst_wg_pm_group=whgine_vj.vj_inp_pm_group
						lst_disp_stkno=whgine_lst.lst_wg_pm_group.wg_pm_equip_no
						whgine_lst.list_desc=whgine_lst.lst_wg_pm_group.wg_pm_desc
					end
					xcall i_display(linp_id,, whgine_lst)
					xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,,
					&                gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
					&                whgine_passed, invoice_totals)
					if .not. ( pass_gen_data.plan_maint .and. vj_inp_act_clock .and. replicate_pm_clock )
						exitloop
				end
				if pass_gen_data.plan_maint .and. vj_inp_act_clock
					if lst_ntype .eq. D_VJ_NSTK .and. lst_stkno .ne. vj_tstk
						if whgine_lst.lst_disp_stkno == whgine_vj.vj_inp_pm_group.wg_pm_equip_no
							if whgine_lst.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING
							begin
								if .not. done_pm_ask
								begin
									done_pm_ask=true
									if %f_yes_no('update clock reading for all lines\non this advice note for equipment '+whgine_vj.vj_inp_pm_group.wg_pm_equip_no) != D_YES
										clear replicate_pm_clock
								end
								if replicate_pm_clock
								begin
									lst_orig_price=lst_orig_price/(whgine_lst.wg_pm_curr_clock-whgine_lst.wg_pm_last_clock)
									whgine_lst.lst_wg_pm_group.wg_pm_idle_time= whgine_vj.vj_inp_pm_group.wg_pm_idle_time
									whgine_lst.lst_wg_pm_group.wg_pm_clock= whgine_vj.vj_inp_pm_group.wg_pm_clock
									whgine_lst.lst_wg_pm_group.wg_pm_curr_clock= whgine_vj.vj_inp_pm_group.wg_pm_curr_clock
									whgine_lst.lst_wg_pm_group.wg_pm_curr_clock_date= whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_date
									lst_orig_price=lst_orig_price*(whgine_lst.wg_pm_curr_clock-whgine_lst.wg_pm_last_clock)
									lst_inp_act_clock=vj_inp_act_clock
									lst_inp_act_clock_date=vj_inp_act_clock_date
									lst_retail=(whgine_vj.wg_pm_curr_clock-whgine_vj.wg_pm_last_clock-whgine_vj.wg_pm_idle_time)*whgine_vj.wg_pm_contract_charge
									lst_moded = true
									xcall l_process( seq_lst_id, req = D_LNOP, whgine_lst,,
									&                  gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
									&                  whgine_passed, invoice_totals)
								end
								;recalc_values and update list
							end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
			if done_pm_ask .and. replicate_pm_clock
				xcall whgine_pm_eqplst_clk_upd(a_listid,whgine_vj,gold_com,gold_ax,
				&        ifkeys,whgine_passed, invoice_totals,vj_tstk)
		end
		D_LISTIAD_DEL:
		begin
			clear at_bottom
			xcall l_process( seq_lst_id, req = D_LTOP, whgine_lst,, gold_com,
			&            gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
			repeat
			begin
				if lst_ntype .eq. D_VJ_NSTK .and. lst_stkno .eq. vj_tstk
				begin
					if vj_prev_batch
						xcall ll_process( pass_chn_data.lst_cntrl, D_LL_INSERT, whgine_lst, err )
					xcall l_process( seq_lst_id, req = D_LDELITEM, whgine_lst,,
					&                  gold_com, gold_ax, a_fkeys[SEQ_FKEYS],
					&                  whgine_passed, invoice_totals)

					exitloop
				end
				if at_bottom
					exitloop
				xcall l_process( seq_lst_id, req = D_LDOWN, whgine_lst,, gold_com,
				&                gold_ax, a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)
				xcall l_status(seq_lst_id, D_LATBOTTOM, at_bottom)
			end
		end
	endcase
	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab, add_part_passed, invoice_totals)
	xcall whgine_disp_inv_vals(gold_com, gold_ax, whgine_passed, whgine_hdr,
	&                         whgine_inv_tab)
	set vj_moded, items_moded = true
	freturn ret_val
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_line_discount,

	vj_dsp_disc=vj_fc_disc
	if(.not.vj_fc_vi_disc.and.vj_fc_disc)
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
			vj_fc_vi_disc=vj_fc_disc
		else
			xcall whgine_vat_calc(vj_fc_vi_disc, vj_vat,
			&        vt_vat_code, vt_vrat, vj_fc_disc,
			&        D_RET_VAT_EXC, D_RET_VAT_INC)
	end
	lst_disc = vj_fc_disc
	lst_vi_disc = vj_fc_vi_disc
	lst_dsp_disc = vj_dsp_disc
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	update_extra_text,
	if(pass_gen_data.plan_maint.and.whgine_vj.vj_inp_pm_group.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING)
	begin
		whgine_vj.vj_extra_text='CLK='+%string(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock)
		if(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_est)
			whgine_vj.vj_extra_text=%atrim(whgine_vj.vj_extra_text)+'E'
	end
	return
.end

subroutine whgine_pm_eqplst_clk_upd
	a_listid,       n
	.include 'whgine_vj' repository, group='whgine_vj_passed', nofields
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	a_tstk, a

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		.include 'whgine_vj' repository, group='whgine_vj'
		.include 'wg_pm_group' repository, group='l_pm_group'
		current_item,   i4
		at_bottom,      i4
		linp_id,        i4
		req,    d3
proc
	whgine_vj=whgine_vj_passed
	l_pm_group=whgine_vj.vj_inp_pm_group
	xcall l_status(a_listid,D_LCURITM, current_item)
	xcall l_status(a_listid,D_LINPID, linp_id)
	req=D_LTOP
	repeat
	begin
		xcall l_process( a_listid, req, whgine_vj,,
		&                gold_com, gold_ax, ifkeys,
		&                whgine_passed)
		if vj_tstk != a_tstk .and. l_pm_group.wg_pm_equip_no == whgine_vj.vj_inp_pm_group.wg_pm_equip_no
			if whgine_vj.wg_pm_charge_type.eq.PMC_CHARGE_CLOCK_READING
			begin
				whgine_vj.vj_f_orig_price=whgine_vj.vj_f_orig_price/(whgine_vj.wg_pm_curr_clock-whgine_vj.wg_pm_last_clock)
				whgine_vj.vj_inp_pm_group.wg_pm_idle_time= l_pm_group.wg_pm_idle_time
				whgine_vj.vj_inp_pm_group.wg_pm_clock= l_pm_group.wg_pm_clock
				whgine_vj.vj_inp_pm_group.wg_pm_curr_clock= l_pm_group.wg_pm_curr_clock
				whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_date= l_pm_group.wg_pm_curr_clock_date
				whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_est=l_pm_group.wg_pm_curr_clock_est
				whgine_vj.vj_f_orig_price=whgine_vj.vj_f_orig_price*(whgine_vj.wg_pm_curr_clock-whgine_vj.wg_pm_last_clock)
				whgine_vj.vj_fc_rrp=(whgine_vj.wg_pm_curr_clock-whgine_vj.wg_pm_last_clock-whgine_vj.wg_pm_idle_time)*whgine_vj.wg_pm_contract_charge
				xcall whgine_vat_calc(vj_fc_vi_rrp, vj_vat,
				&         vt_vat_code, vt_vrat, vj_fc_rrp,
				&         D_RET_VAT_EXC, D_RET_VAT_INC)
				xcall whgine_vj_curr_vals(gold_com, whgine_vj, pass_gen_data.inp_vj_id, whgine_passed, invoice_totals)
				whgine_vj.vj_extra_text='CLK='+%string(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock)
				if(whgine_vj.vj_inp_pm_group.wg_pm_curr_clock_est)
					whgine_vj.vj_extra_text=%atrim(whgine_vj.vj_extra_text)+'E'
				xcall i_display(linp_id,, whgine_vj,,,,,,,,,,gold_com)
			end
		req=D_LDOWN
		xcall l_status(a_listid, D_LATBOTTOM, at_bottom)
		if at_bottom exitloop
	end
	xcall l_next(a_listid, current_item)
	req=D_LNOP
	xcall l_process( a_listid, req, whgine_vj,,
	&                    gold_com, gold_ax, ifkeys,
	&                    whgine_passed)
	xreturn
endsubroutine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.function whgine_trd_mod_chg ,^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VGREC.REC'                                             ; WG7719
	.include 'SRC:VMCOM.REC'

	external function
		f_file,         d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record dummy_vmrec
		,       a ^size(vmrec)  ;dummy_flds fields not referenced


	record gen
		.include 'vw_user' repository, group = 'vw_user'		; AP180810
		err,            d4
.proc
	clear gen

	; WG7465 - REPLACE J_OVER WITH J_NEW_MOD 	IE. O'ride with New Mod
	; WG7465		if (.not.(g_select.and.g_entnam.eq.'J_OVER')) then
	if (.not.(g_select.and.g_entnam.eq.'J_NEW_MOD')) then 	; WG7465
	begin
		if (a_pending_status .ne. D_OK .or. (g_select .and.
		&   (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
		&   g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_COPY')))
			freturn a_pending_status

		; AP180810            a_pending_status = %vw_change(a_data_entered, a_data_stored,
		; AP180810            &   a_pending_status, inputinfo, whgine_vb, gold_com, gold_ax
		; AP180810            &           ,a_dummy_fkeys, vx_rfa)
		a_pending_status = %vw_change(a_data_entered, a_data_stored,		; AP180810
		&   a_pending_status, inputinfo, whgine_vb, gold_com, gold_ax		; AP180810
		&           ,a_dummy_fkeys)							; AP180810				; AP180810

		xcall i_user(inp_wndid,'VB_CODE',vw_user)	        ; AP180810
		vx_rfa=vw_user.vxf_rfa				; AP180810

		if (a_pending_status .ne. D_OK .or.
		&   (g_entnam .eq. 'J_QUIT'))
			freturn a_pending_status

		if (a_data_stored)
		begin
			if (.not. (%f_file(pass_chn_data.chn(VW_FILE), vwrec, a_data_stored, 'RD',,,
			&  D_NO_LOCK)))
			begin
				vb_code = vwcode
				vb_tmod = vwmodl
				pass_chn_data.h_stok=whgine_vb.vb_tstk

				; read into dummy area so as not to overwrite any stuff
				; set on the vmrec so far
				if (.not.vmsold) then
					xcall file(pass_chn_data.chn(VM_FILE), dummy_vmrec, pass_chn_data.h_stok, 'RD', err)
				else
					xcall file(pass_chn_data.chn(HM_FILE), dummy_vmrec, pass_chn_data.h_stok, 'RD', err)
				if(.not.err.and.vmstok.ne.pass_chn_data.h_stok) vmstok=pass_chn_data.h_stok

				set vb_spec[], vmspec[], vbtspc[]=vwspec[]
				if (.not. vb_used)
				begin
					vb_grp = vwgrp
					xcall whgine_get_group(vb_grp, vb_grpdes,,,,,
					&       vb_book_wd_p, vb_est_rep_p, vb_est_warr_p)

				end
				vb_mak = vwmake
				xcall whgine_get_make(vb_mak, vb_makdes)

				vmgros = vwgros
				vmlen = vwlen
				vmwide = vwwide
				vmhigh = vwhigh
				vmtype = vwtype
				vm_comm_code = vwcomm                            ; WG7719
				vm_srv_mileage = vw_srv_mileage	           ; WG7447
				vm_max_srv_months = vw_max_srv_months          ; WG7447

				vb_type = vmtype
				h_comm_code = vwcomm
				; WG7433                    if (.not. pass_gen_data.h_vatable .or.
				; WG7433&                       (.not. pass_gen_data.h_vatreg .and. cms_country .ne. EIRE_VAT)) then
				if (.not. pass_gen_data.h_vatable .or.
				&                     .not. pass_gen_data.h_vatreg) then
					vb_vat=pass_gen_data.sb_vat_zero
				else
				begin
					if (cms_country.eq.EIRE_VAT) then
						vb_vat=pass_gen_data.sb_vat_code
					else
						vb_vat=vwvat
				end
				if (.not. vb_vat)
					vb_vat = pass_gen_data.sb_vat_code

				xcall whgine_set_vb_qualifying_field(inp_wndid, whgine_vb)

				if (.not.err)
				begin
					if (.not.vmsold) then
						xcall file(pass_chn_data.chn(VM_FILE), vmrec,, 'WR', err)
					else
						xcall file(pass_chn_data.chn(HM_FILE), vmrec,, 'WR', err)
				end

				xcall i_display( pass_gen_data.inp_vb_id, 'vb_full_set', whgine_vb,,,,,,,,,,
				&            gold_com)
				if (.not. vb_code)
					xcall i_init(pass_gen_data.inp_vb_id, 'vb_inpset', whgine_vb, 'vb_code')
				if (.not. vb_grp)
					xcall i_init(pass_gen_data.inp_vb_id, 'vb_inpset', whgine_vb, 'vb_grp')
				if (.not. vb_mak)
					xcall i_init(pass_gen_data.inp_vb_id, 'vb_inpset', whgine_vb, 'vb_mak')

			end
		end
	end
	else
	begin
		clear g_select, g_entnam
		xcall i_next(inp_wndid,'*CURR*','vb_type')
	end

	freturn D_OK

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.function whgineChangeVB_TMOD ,^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_file,         d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record dummy_vmrec
		,       a ^size(vmrec)  ;dummy_flds fields not referenced


	record gen
		.include 'vw_user' repository, group = 'vw_user'
		fldnam,         a30
		err,            i4
.proc

	; WG7465 - REPLACE J_OVER WITH J_NEW_MOD 	IE. O'ride with New Mod
	; WG7465        if (g_select.and.g_entnam.eq.'J_OVER')
	if (g_select.and.g_entnam.eq.'J_NEW_MOD')	; WG7465
	begin
		clear g_select, g_entnam
		xcall i_next(inp_wndid,'*CURR*','vb_type')
		freturn D_OK
	end

	if (a_data_entered(%trim(a_data_entered):1).eq.'?'.OR.
	&   a_data_entered(%trim(a_data_entered):1).eq.'*')
	begin
		clear a_data_entered(%trim(a_data_entered):1)
		a_data_stored = a_data_entered
		xcall m_signal('I_DRILL')
		freturn D_OK
	end

	if (a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_COPY')))
		freturn a_pending_status

	;        a_pending_status = %vw_change(a_data_entered, a_data_stored,
	;        &       a_pending_status, inputinfo, whgine_vb, gold_com, gold_ax
	;        &               ,a_dummy_fkeys, vx_rfa)

	if (a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT'))
		freturn a_pending_status

	fldnam = %i_getstring( inp_wndid, inp_fldnam )

	if (a_data_stored)
	begin
		if (.not. (%f_file(pass_chn_data.chn(VW_FILE), vwrec, vb_code, 'RD',,,
		&  D_NO_LOCK)))
		begin
			xcall vw_any_vxrec_for_vxmodl(vb_code, a_data_stored, err)
			if(.not.err)
			begin
				a_pending_status = %vw_change(a_data_entered,a_data_stored,a_pending_status,inputinfo,
				&   whgine_vb,gold_com,gold_ax,a_dummy_fkeys)
				xcall i_user(inp_wndid,fldnam,vw_user)	; AP180810
				vx_rfa=vw_user.vxf_rfa			; AP180810

				if ((a_pending_status.ne.D_OK .and. a_pending_status.ne.D_REQERR) .or.
				&   g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL' .or. g_entnam.eq.'I_HYPER')
					freturn a_pending_status

				xcall vw_get_vwrec_vxrec(inp_wndid, 'vb_tmod', vwrec, vb_code, vx_rfa)
				if(vb_spec[].ne.vwspec[])
				begin
					if (.not.vmsold) then
						xcall file(pass_chn_data.chn(VM_FILE), dummy_vmrec, pass_chn_data.h_stok, 'RD', err)
					else
						xcall file(pass_chn_data.chn(HM_FILE), dummy_vmrec, pass_chn_data.h_stok, 'RD', err)
					if(.not.err)
					begin
						set vb_spec[], vmspec[], vbtspc[]=vwspec[]
						if (.not.err)
						begin
							if (.not.vmsold) then
								xcall file(pass_chn_data.chn(VM_FILE), vmrec,, 'WR', err)
							else
								xcall file(pass_chn_data.chn(HM_FILE), vmrec,, 'WR', err)
						end
					end
				end
			end
		end
	end

	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.subroutine whgine_trd_mod_arrv
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'fkeys' repository, group = 'a_fkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group = 'fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VMCOM.REC'

	record General
		.include 'vw_user' repository, group = 'vw_user'
.proc
	xcall i_user(inp_wndid,'vb_code',vw_user)
	vw_user.mak_cod = whgine_vb.vb_mak      ; if blank will also set user data blank
	vw_user.fld_vwmodl = false              ; if blank will also set user data blank
	vw_user.include_vxf = false
	xcall i_user(inp_wndid,'vb_code',,vw_user)

	a_fkeys.fkey[D_FK_NO7].disabled_flg = FALSE
	xcall ibc_fkeys(inp_wndid,a_fkeys)
	if vmsold.and.vmivno then
		xcall ibc_disable(inp_wndid, 'vb_rrp_bc')
	else
		xcall ibc_enable(inp_wndid, 'vb_rrp_bc')
	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       general leave method for input fields on the trade in vb record.
;       This is primarily to trap j_quit and then tidy up after quit
;       when in insert more and the routine has already inserted a wgd.
;       in this case, the routine will delete that wholegood if it has been
;       created by the routine.
;
.subroutine whgine_trd_vb_gen_leave
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'fkeys' repository, group = 'dummy_fkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'


	.include "SRC:OPSCOM.REC"

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		.include 'vmrec' repository, group = 'dummy_vmrec'
		err,            d4

.proc

	if((g_entnam.eq.'BTNCANCEL'.or.g_entnam.eq.'J_QUIT').and.
	&  pass_gen_data.h_ivcr.eq.D_VIIVCR_INVOICE.and.
	&  pass_chn_data.line_mode.eq.D_INS_MODE.and.
	&  trd_create.and.vb_vm_exists.eq.'S'.and.vb_tstk)
	begin
		xcall file(pass_chn_data.chn(VM_FILE), dummy_vmrec, vb_tstk, 'RD', err,,,,,D_NO_LOCK)
		if(.not.err)
		begin
			xcall file(pass_chn_data.chn(VM_FILE), dummy_vmrec, vb_tstk, 'RD', err)
			xcall file(pass_chn_data.chn(VM_FILE), dummy_vmrec,, 'DE', err)
			xcall ScratchPadDelete(CMNT_WG_WSJ_INST,vb_tstk)
		end

		if(dummy_vmrec.vmpstk)
		begin
			xcall file(pass_chn_data.chn(HM_FILE), dummy_vmrec, dummy_vmrec.vmpstk, 'RD', err)
			if(.not.err)
			begin
				clear dummy_vmrec.vmnstk
				xcall file(pass_chn_data.chn(HM_FILE), dummy_vmrec, dummy_vmrec.vmpstk, 'WR', err)
			end
		end
		xcall m_signal('J_QUIT')
	end

	xreturn

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.subroutine whgine_trd_mod_leave
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'fkeys' repository, group = 'a_fkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group = 'fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VMCOM.REC'

.proc
	xcall whgine_trd_vb_gen_leave(inputinfo, whgine_vb, gold_com, gold_ax,
	&                             a_fkeys, whgine_passed)
	; SET QUAL FIELD
	xcall whgine_set_vb_qualifying_field(inp_wndid, whgine_vb)
	xcall whgine_set_trd_vat_code(inp_wndid, whgine_vb)

	a_fkeys.fkey[D_FK_NO7].disabled_flg = FALSE
	xcall ibc_fkeys(inp_wndid,a_fkeys)

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.subroutine whgine_trd_type_arrv
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'fkeys' repository, group = 'a_fkeys'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group = 'fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VMCOM.REC'

.proc

	a_fkeys.fkey[D_FK_NO7].disabled_flg = TRUE
	xcall ibc_fkeys(inp_wndid,a_fkeys)

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       pick up standard model price and cost for non stock display
.subroutine std_non_stk_costs

	a_model,        a
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
.proc

	clear vj_fc_mrrp, vj_bc_ecos, vj_d_fc_mrrp
	clear vj_fc_trd_price
	if(a_model .and. .not.vj_used)
	begin
		; get standard costs
		xcall calc_wg_pric(vj_fc_ecos, a_model,,pass_gen_data.vi_currency)
		vj_bc_ecos = vj_fc_ecos
		vj_dsp_cost = vj_fc_ecos
		xcall calc_wg_pric(vj_fc_mrrp, a_model,, pass_gen_data.vi_currency,,,1)
		; RETURN TRADE PRICE NOTE ARGUMENT NO 7 SET TO 2
		xcall calc_wg_pric(vj_fc_trd_price, a_model,,pass_gen_data.vi_currency,,,2)
		if(pass_chn_data.h_prog_code.ne.P_COD_MACH_TRAD) then
			vj_d_fc_mrrp = vj_fc_mrrp
		else
			vj_d_fc_mrrp = vj_fc_trd_price

		if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC.and.vj_vat)
		begin
			xcall whgine_vat_calc(vj_d_fc_mrrp, vj_vat,
			&       vt_vat_code, vt_vrat, vj_d_fc_mrrp,
			&       D_RET_VAT_EXC, D_RET_VAT_INC)
		end
		xcall whgine_set_vj_curr_flds(whgine_vj, whgine_passed, invoice_totals)

	end
	xreturn

.end

.subroutine set_line_mode

	a_listiad_mode,         a

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal


.proc
	case a_listiad_mode of
	begincase
		D_LISTIAD_INS:
		pass_chn_data.line_mode = D_INS_MODE
		D_LISTIAD_AMD:
		pass_chn_data.line_mode = D_AMD_MODE
		D_LISTIAD_DEL:
		pass_chn_data.line_mode = D_DEL_MODE
	endcase
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section sets the self bill vat codes.  These vary
        ;       depending on whether cms-country = eire and whether
        ;       this is a self bill invoice or not
.subroutine set_self_bill_vat_codes

	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:IVTCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if(cms_country.ne.EIRE_VAT) then
	begin
		pass_gen_data.sb_vat_code=cms_uk_def_vat
		pass_gen_data.sb_vat_zero=cms_uk_zero_vat
	end
	else
	begin
		if(pass_chn_data.h_prog_code.eq.P_COD_SEL_BILL) then
		begin
			pass_gen_data.sb_vat_code=ivt_vat_code
			pass_gen_data.sb_vat_zero=ivt_vat_zero
		end
		else
		begin
			pass_gen_data.sb_vat_code=sb_eire_vat_code
			pass_gen_data.sb_vat_zero=sb_eire_vat_zero
		end
	end
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : preprocess initialisation routine for wholegood
;
.subroutine whgine_wgd_prc

	a_listid,       n

	a_inpwndid,     n

	.include 'whgine_vj' repository, group='whgine_vj'

	a_mode,         a

	a_filechn,      n

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'fkeys' repository, group='ifkeys'
	.include 'whgine_passed' repository, group='whgine_passed'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'add_part_passed' repository, group='add_part_passed'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'

.proc

	xcall whgine_wgd_tab_set_fkeys(a_listid, whgine_vj, fkeys)

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_wgd_tab_set_fkeys

	a_listid,       n
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'fkeys' repository, group='fkeys'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		no_items,       d3
.proc

	xcall l_status(a_listid, D_LLASTITM, no_items)

	if( pass_gen_data.adv_mode .ne. D_VEW_MODE.and.
	&	pass_gen_data.h_ivcr.eq.D_VIIVCR_PART_INV)
	begin
		if(no_items.eq.1)
			fkeys.fkey[D_FK_NO2].disabled_flg = true
		else
			fkeys.fkey[D_FK_NO2].disabled_flg = false
	end

	if(pass_gen_data.h_ivcr.ne.D_VIIVCR_CREDIT.and.pass_gen_data.h_ivcr.ne.D_VIIVCR_PART_CRED)
	begin
		if no_items .and. pass_gen_data.adv_mode .ne. D_VEW_MODE then
		begin
			fkeys.fkey[D_FK_NO8].disabled_flg = false
			if vj_wg_attach then
			begin
				fkeys.fkey[D_FK_NO4].disabled_flg = true
			end
			else
			begin
				fkeys.fkey[D_FK_NO4].disabled_flg = false
			end
		end
		else
		begin
			fkeys.fkey[D_FK_NO8].disabled_flg = true
		end

		if no_items .and. pass_gen_data.adv_mode .ne. D_VEW_MODE .and.vj_vm_exists.eq.'S' then
		begin
			fkeys.fkey[D_FK_NO6].disabled_flg = FALSE
			if vj_wg_attach then
			begin
				fkeys.fkey[D_FK_NO6].btn_disp = 'Tfr Out'
			end
			else
			begin
				fkeys.fkey[D_FK_NO6].btn_disp = 'Tfr In '
			end
		end
		else
		begin
			fkeys.fkey[D_FK_NO6].disabled_flg = true
		end
	end

	xcall ibc_fkeys(a_listid, fkeys, true)

	xreturn

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       INITIALISES VM FIELDS WHEN ADDING NEW WHOLEGOOD
.subroutine initialise_vm_fields

	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'whgine_vb' repository, group = 'whgine_vb'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		loop,           d2

.proc

	; at this point will have already found a validate stock number which may or
	; may not be in history so next step is to put the vm fields into the screen
	; records.
	clear vm_commission, vm_comm_wgc
	clear vm_est_pdi_cost, vm_est_pdi_hours
	clear vm_man_adjust, vm_not_sb, vm_sugg_com, vm_act_com, vmityp
	clear vm_sb_adv, vm_sb_advno
	clear vm_hire_code
	vm_depot = vi_dep

	clear vm_fin_inv
	clear vmcost
	clear vmrdat
	clear vm_auto_cos(D_FC), vm_auto_cos(D_BC)
	clear vm_rrp(D_FC), vm_rrp(D_BC)
	clear vmrep, vmtrn
	clear vm_tip(D_FC),vm_tip(D_BC), vmoa, vm_sett(D_FC),vm_sett(D_BC)
	clear vm_conf_sold, vm_f_sup_sett, vm_f_add_chrg
	clear vmstat
	vmass=D_WG_ON_ORDER
	vmpsys='C'
	vmpacc=vi_cust

	clear vmmrrp, vm_est_cos(D_FC),vm_est_cos(D_BC)
	clear vm_trd_price

	if(.not. vb_same_machine) then
	begin
		clear vmser, vmeng, vmchas, vmaxle, vmtran, vm_old_stkno
		clear vmoth, vmothd, vmreg, vmdreg, vmclok
		clear vmccol, vmtcol, vmignk, vmradc, vmmot, vmmotd
		clear vm_year, vm_nxt_serv, vm_srv_mileage, vm_max_srv_months, vm_last_srv_date, vm_last_srv_mileage, vm_wsj_clk
		clear vmrec.vmwdat, vmrec.vm_warr_edat
		clear vmrec.vm_ex_warr_edat
		clear vmrec.vm_warr_end_clock
		clear vmrec.vm_ex_warr_end_clock
	end
	else
	begin
		clear vmgrp
		if (%ndate >= vmrec.vmwdat)
			clear vmrec.vmwdat
		if (%ndate >= vmrec.vm_warr_edat)
			clear vmrec.vm_warr_edat, vmrec.vm_warr_end_clock
		if (%ndate >= vmrec.vm_ex_warr_edat)
			clear vmrec.vm_ex_warr_edat, vmrec.vm_ex_warr_end_clock
	end
	clear vm_sb_adv, vm_sb_advno
	clear vmcust, vmcord, vmcdat, vmfcom, vmfpro, vmsold, vmivno, vminvf
	clear vm_f_disc, vmadno, vm_fp_edate, vm_buy_rep

	clear vmpdat, vmpinv, vmpord, vmrdat, vmgrn

	clear vmwstk, vmpstk, vmnstk, vmddat, vm_trade_in

	clear vmdeld
	clear vm_extra_comm
	clear vm_bonuses
	for loop = 1 until 5 do
	clear vm_bonus_est(loop), vm_bonus_actual[loop,D_FC],
	&               vm_bonus_comp(loop),vm_bonus_actual[loop,D_BC]

	clear vm_wash
	clear vm_date_wrt, vm_orig_cost, vm_amt_wrt
	vmnu='U'
	clear vm_man_init, vm_html_grp, vm_po_prt
	clear vm_qualifying, vm_manuf_status, vmloc
	clear vm_quote
	clear vm_orig_depot
	clear vm_sup_code
	vm_authorised=
	clear vm_hard_lett

	if(.not.pass_gen_data.h_vatable.or..not. pass_gen_data.h_vatreg)
	begin
		if (cmf_def_vat)
			vmvat = cmf_def_vat
		else
		begin
			if (cms_country == EIRE_VAT)
				vmvat = ivt_vat_zero
			else
				vmvat = cms_uk_zero_vat
		end
	end
	else
	begin
		if (cms_country == EIRE_VAT)
			vmvat=ivt_vat_code
		else
			vmvat=cms_uk_def_vat
	end
	clear vm_end_user_cus
	clear vm_end_user_idat
	clear vm_end_user_dreg
	clear vm_tomrowe
	clear vm_mob_clk_upd
	clear vm_condition
	clear vm_competitive
	clear vm_replace_dt
	clear vm_tractor_trader
	clear vm_funding_cust

	xreturn
.end
.function whgine_cpy_stk_change, ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	a_inprec,           a
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		vm_exists       ,a1
		vm_rfa,         a6
.proc
	if(.not.a_data_entered) a_data_entered='?'
	a_pending_status = %vm_change( a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, a_inprec )

	if( g_select .and. (g_entnam .eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL') .or.
	&   a_pending_status .ne. D_OK )      ; Menu entry
		freturn a_pending_status

	if(a_data_stored)
	begin
		pass_chn_data.h_stok = a_data_stored
		xcall check_vm_exists(whgine_passed, vm_exists, vm_rfa)
	end
	if(.not. vm_exists)
		a_pending_status = D_EMITTEDERR

	freturn a_pending_status
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_pr_ti_change, ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		vm_exists       ,a1
		vm_rfa,         a6
		fldnam,         a15
		loop,           d2
		cur_fld_no,     d2
.proc
	if(a_data_entered)
		a_pending_status = %vm_change( a_data_entered, a_data_stored,
		&     a_pending_status, inputinfo, whgine_hdr )

	if( g_select .and. (g_entnam .eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL') .or.
	&   a_pending_status .ne. D_OK )      ; Menu entry
		freturn a_pending_status

	if(a_data_stored)
	begin
		pass_chn_data.h_stok = a_data_stored
		xcall check_vm_exists(whgine_passed, vm_exists, vm_rfa)
	end
	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	cur_fld_no=fldnam(%trim(fldnam):1)
	if(.not.a_data_stored.and.cur_fld_no.ne.5)
	begin
		; PREPARE TO SHUFFLE THE ARRAY UP OR COMPLETE ENTRY IF SPACE ENTERED
		for loop from cur_fld_no thru 4
		begin
			xcall i_putfld(inp_wndid, 'inp_set', whgine_hdr,
			&              'fin_pr_ti_stk'+%string(loop,'XX'),
			&              fin_pr_ti_stk(loop+1))
		end
		set a_data_entered, a_data_stored = fin_pr_ti_stk(cur_fld_no)
		clear fin_pr_ti_stk(5)
		xcall i_display(inp_wndid,'dsp_set',whgine_hdr)
		; if we have shuffled the list up and now there is something
		; in the current position then ,make this the next field.  Otherwise,
		; the i_display will have completed the set
		if(fin_pr_ti_stk(cur_fld_no))
			xcall i_next(inp_wndid,'inp_set',fldnam)
		else
			xcall i_next(inp_wndid, 'inp_set', '*DONE*')
		freturn D_OK
	end

	for loop from 1 thru 5
	begin
		if(loop.ne.cur_fld_no.and.a_data_stored.eq.fin_pr_ti_stk(loop))
		begin
			xcall ibc_message('Invalid - this trade in is already on the list')
			freturn  D_EMITTEDERR
		end
	end

	if(.not. vm_exists)
		freturn  D_EMITTEDERR

	if(vmpsys.ne.'C')
	begin
		xcall ibc_message('Invalid - the selected item must be customer supplied')
		freturn  D_EMITTEDERR
	end

	if(vmass.eq.2)  ; still on order
	begin
		xcall ibc_message('Invalid - the selected item is on order - Not FULLY Traded in')
		freturn  D_EMITTEDERR
	end

	if(vmpacc.ne.vi_cust)   ; should be the same supplier
	begin
		xcall ibc_message('Invalid - the supplier for this item does not match '
		&                 +'the customer entered.')
		freturn  D_EMITTEDERR
	end

	;   can not be associated with a traded in against
	if(vm_trade_in)
	begin
		xcall ibc_message('Invalid - This Trade In is set as Traded In '
		&                 +'against stock no '+%atrim(vm_trade_in)
		&                 +'.  This facility is only intended for Trade Ins'
		&                 +' which have not been linked to another {WHOLEGD}.')
		freturn  D_EMITTEDERR
	end

	freturn a_pending_status
.end
; Display Method
.function whgine_pr_ti_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec                ,a      ; (Optional) record passed to I_INPUT.
                                        ;  Not passed if in I_INPFLD/I_DSPFLD.
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display
        ; a_method_data         ,a      ; Optional method data argument

	.include "SRC:OPSCOM.REC"


	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record general
		.include 'vmrec' repository, group = 'vmrec'

		fldnam,         a15
		cur_fld_no,     d1
		err,            d4
.proc
	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	cur_fld_no=fldnam(%trim(fldnam):1)
	if(.not.a_data_stored) then
		clear vmrec
	else
	begin
		xcall file(pass_chn_data.chn(VM_FILE), vmrec, a_data_stored, 'RD', err,,,,,D_NO_LOCK)
		if(err)
			xcall file(pass_chn_data.chn(HM_FILE), vmrec, a_data_stored, 'RD', err,,,,,D_NO_LOCK)
		if(err)
		begin
			clear vmrec
		end
	end

	xcall i_dspfld( inp_wndid, 'dsp_pr_ti_cod'+%string(cur_fld_no), vmcode)
	xcall i_dspfld( inp_wndid, 'dsp_pr_ti_mod'+%string(cur_fld_no), vmmodl)
	xcall i_dspfld( inp_wndid, 'dsp_pr_ti_adv'+%string(cur_fld_no), vm_sb_advno)
	xcall i_dspfld( inp_wndid, 'dsp_pr_ti_rdt'+%string(cur_fld_no), vmrdat)
	xcall i_dspfld( inp_wndid, 'dsp_pr_ti_tip'+%string(cur_fld_no), vm_tip[D_FC])
	freturn TRUE
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       input details for main washout screen
.subroutine whgine_washout_scn


	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'


	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record whgine_wash      ; Main {WHOLEGD} Washout Stock
		wash_tstk,              a8      ; main washout stock no
		wash_used,              d1      ; new used
		wash_type,              d1      ; {wholegd} / vehicle
		wash_code,              a13     ; model code
		wash_tmod,              a20     ; model description
		wash_grp,               a4      ; group
		wash_grpdes,            a20     ; group desc
		wash_mak,               a2      ; make
		wash_makdes,            a20     ; make desc
		wash_spec1,             a32     ; spec
		wash_spec2,             a32     ; spec
		wash_spec3,             a32     ; spec
		wash_ser,               a20     ; serial
		wash_reg,               a10     ; reg no
		wash_dreg,              d8      ; reg date

	record gen
		err,            d3
		wo_exists,      a1
		quitting,       d1
		reject,         d1
		done,           d1
		chr,            a1
		wo_vm_rfa,      a6
		h_input_orig,   a ^size(whgine_wash)
		h_input_new,    a ^size(whgine_wash)
		sal_nomacc,     a7
		.include 'vm_user' repository, group = 'vm_user4'
		.include 'whgine_vb' repository, group = 'whgine_vb'
		.include 'fkeys' repository, group = 'fkeys'

	record ifours
		inp_wash_id,    i4

.proc
	clear gen, ^i(ifours)
	clear fkeys.fkmnu_id

	xcall e_enter
	xcall ibc_column( D_REMOVE, D_LOCAL )

	if(pass_gen_data.adv_mode.eq.D_VEW_MODE.and..not.vi_stok)
	begin
		xcall ibc_message('No Washout Stock Number Specified for This Advice')
		goto washout_screen_exit
	end
	xcall ibc_ldinp(inp_wash_id, g_utlib, 'whgine_wash', D_NOPLC,,,,,fkeys)
	xcall i_user(inp_wash_id, 'wash_tstk', vm_user4 )

	clear vm_user4, ^i(vm_user4.vm_user_mh)
	vm_user4.usr_all=TRUE
	vm_user4.chk_option=D_ALL_WG
	xcall i_user(inp_wash_id, 'wash_tstk',, vm_user4 )

	xcall ibc_window( D_PLACE, inp_wash_id, 9, 2 )

	xcall i_init(inp_wash_id)

	clear vbtstk
	wash_tstk = vi_stok
	reject = TRUE
	washout_screen_init,
	vbtstk = wash_tstk              ; convenient store for wash_tstk
	if(.not.wash_tstk) then
		clear whgine_wash
	else
	begin
		pass_chn_data.h_stok = wash_tstk
		xcall check_vm_exists(whgine_passed, wo_exists, wo_vm_rfa)
		if(.not. wo_exists)
			xcall ibc_message('Washout Stock '+wash_tstk+' Does not exist')

		if(vmnu.EQ.'U') then wash_used=1
		else clear wash_used
		wash_type = vmtype
		wash_code = vmcode
		wash_tmod = vmmodl
		wash_grp = vmgrp
		xcall whgine_get_group(wash_grp, wash_grpdes)
		wash_mak=vmmak
		xcall whgine_get_make(wash_mak, wash_makdes)

		wash_spec1=vmspec(1)
		wash_spec2=vmspec(2)
		wash_spec3=vmspec(3)

		wash_ser = vmser
		wash_reg = vmreg
		wash_dreg = vmdreg
	end

	xcall i_display(inp_wash_id,'wash_full_set', whgine_wash )

	set quitting, done = false

	if(pass_gen_data.adv_mode.eq.D_VEW_MODE) then
	begin
		xcall e_sect('Enter Quit key to exit',D_INFO,D_LEFT)
		while( .NOT. quitting .AND. .NOT. done )
		begin
			xcall e_state( D_OFF, D_ECHO, D_CURSOR )
			xcall ibc_chr(chr, inp_wash_id,,,,,fkeys)
			; reinstate cursor and echo
			xcall e_state( D_ON, D_ECHO, D_CURSOR )
			if( g_select .and. g_entnam .eq. 'J_QUIT' ) quitting = TRUE
		end
	end
	else
	begin
		xcall i_next(inp_wash_id,'wash_inp_set', '*FRST*' )
		while( .NOT. quitting .AND. .NOT. done )
		begin
			reject=false
			xcall ibc_input( inp_wash_id,'wash_inp_set' , whgine_wash,gold_inp_id,
			&                       gold_sel_id, ,D_NOTERM ,,fkeys,gold_com,gold_ax,whgine_passed)
			if( g_select .and. g_entnam .eq. 'J_QUIT' ) then
				quitting=TRUE
			else
			begin
				if(.not.g_select.and.g_entnam.eq.'I_OK') then
					done=TRUE
				else
				begin
					call validate_washout_wg
					if(.not.reject.and.vbtstk.ne.wash_tstk.and.wash_tstk)
						goto washout_screen_init
					if( reject )
					begin
						xcall i_next( inp_wash_id, 'wash_inp_set',
						&                                       'wash_tstk' )
					end
					if(.not.reject) done=TRUE
				end
			end
		end
		if(.not.quitting.and.wash_tstk.ne.vi_stok) then
		begin
			if(vi_stok.ne.wash_tstk) then
				clear h_input_orig
			else
				h_input_orig=whgine_wash
			h_input_new=whgine_wash
			if %confirm_changes(h_input_orig, h_input_new) .eq. D_YES
			begin
				vi_stok = wash_tstk
				vi_tigr = wash_grp
				hdr_moded = TRUE
			end
		end
	end
	washout_screen_exit,
	set done, quitting, reject = false
	xcall e_exit
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       validate the washout wholegood number
	validate_washout_wg,

	err=true
	if(.not.wash_tstk) goto no_washout
	if(wash_tstk)
	begin
		pass_chn_data.h_stok=wash_tstk
		xcall check_vm_exists(whgine_passed, wo_exists, wo_vm_rfa)
	end
	if(.not. wo_exists) goto no_washout

	; if stock number has been entered which is not the top of the washout
	; chain then   find the top of the washout chain

	if(vmwstk.and.vmwstk.ne.vmstok)
	begin
		repeat
		begin
			pass_chn_data.h_stok=vmwstk
			xcall check_vm_exists(whgine_passed, wo_exists, wo_vm_rfa)
			if(err)
			begin
				pass_chn_data.h_stok=wash_tstk
				xcall check_vm_exists(whgine_passed, wo_exists, wo_vm_rfa)
				exitloop
			end
			wash_tstk=vmstok
			xcall flash('Switching to Main Washout Stock Number '+wash_tstk)
			if(.not.vmwstk.or.vmwstk.eq.vmstok) exitloop
		end
	end

	; washout wholegood validation

	xcall whgine_get_group(vmgrp,, err, sal_nomacc)
	if(err)
	begin
		xcall ibc_message('Invalid - Nominal Group '+vmgrp+' Is Not Set Up')
		goto invalid_washout_wg
	end
	if(.not. sal_nomacc)
	begin
		xcall ibc_message('Invalid - Sales Nominal Account Missing For'
		&               +' Group '+vmgrp)
		goto invalid_washout_wg
	end
	; want to make sure wgd set as main washout stock no is not on
	; trade in list as this would be invalid
	call check_if_wgd_on_vb_list
	if(reject.eq.true) goto invalid_washout_wg

	return

	no_washout,
	reject=TRUE
	g_fldnam='WASH_TSTK'
	g_setsts=1                      ; to stop done
	xcall i_force('?')
	return

	invalid_washout_wg,
	reject=TRUE
	wash_tstk=vi_stok
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; this section checks the wholegood list to ensure that the wgd
        ; selected does not already exist on the list
	check_if_wgd_on_vb_list,
	reject=false
	xcall l_remove(trd_lst_id)
	xcall l_data(trd_lst_id, D_LFIRST, trd_linp_id, whgine_vb,, err)
	while .not. err
	begin
		if(.not.whgine_vb.vb_wg_attach)
		begin
			if(whgine_vb.vb_tstk.eq.wash_tstk)
			begin
				xcall ibc_message('Invalid - this wholegood a trade in on this advice')
				reject=true
				exitloop
			end
		end
		xcall l_data(trd_lst_id, D_LNEXT, trd_linp_id, whgine_vb,, err)
	end

	return

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       general screen asking user to confirm the entered changes
.function confirm_changes, ^val

	a_orig,         a
	a_new,          a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'

	record gen
		yes_no_ans,     d1
.proc
	if(a_orig .ne. a_new) then
	begin
		if(vi_quote)
		begin
			xcall ibc_message('Please note that any changes you make to this'
			&                 +' advice may not be reflected in the related quotation'
			&                       +' (Quote No '+vi_quote+')'
			&                 +'\n\nIt is recommended that changes are made to the quote'
			&                 +' which then automatically updates the advice.')
		end
		yes_no_ans=D_YES
		xcall yes_no('Accept Changes ?',yes_no_ans,10)
	end
	else
		yes_no_ans=false
	freturn yes_no_ans
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;               input main stock only secondary screen including
        ;               serial numbers
.subroutine serial_no_screen
	.include 'whgine_passed' repository, group='whgine_passed'
	a_stkno,        a
	a_exists,       a
	a_rfa,          a
	a_serial,       a
	a_reg,          a
	a_reg_date,     n
	a_clock,        n
	a_year,         n
	a_vmmotd,       n

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:WGD_SERIALS.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3

.proc
	xcall e_enter
	xcall ibc_column(D_REMOVE,D_LOCAL)

	if (.not. a_exists) then
	begin
		clear vmrec
		vmrec.vmstok = a_stkno
	end
	else
	begin
		if (a_exists .eq. 'S') then
			xcall file(pass_chn_data.chn(VM_FILE),vmrec,a_stkno,'RD',err,,,,,
			&      (pass_gen_data.adv_mode.ne.D_VEW_MODE .and. viivcr.ne.D_VIIVCR_PART_CRED))
		else
			xcall file(pass_chn_data.chn(HM_FILE),vmrec,a_stkno,'RD',err,,,,,
			&      (pass_gen_data.adv_mode.ne.D_VEW_MODE .and. viivcr.ne.D_VIIVCR_PART_CRED))

	end
	if (err) then
		xcall ibc_message('{WHOLEGD} record not found')
	else
	begin
		if (^passed(a_serial))
			vmrec.vmser = a_serial
		if (^passed(a_reg))
			vmrec.vmreg = a_reg
		if (^passed(a_reg_date))
			vmrec.vmdreg = a_reg_date
		if (^passed(a_clock))
			vmrec.vmclok = a_clock
		if (^passed(a_year))
			vmrec.vm_year = a_year
		if (^passed(a_vmmotd))
			vmrec.vmmotd = a_vmmotd

		xcall wg_serials(vmrec,vmrec.vmstok,(a_exists.ne.'S'),
		&   false,(pass_gen_data.adv_mode.EQ.D_VEW_MODE ),(pass_gen_data.adv_mode.NE.D_VEW_MODE ),true)
		if ^passed(a_serial)
			a_serial = vmrec.vmser
		if ^passed(a_reg)
			a_reg = vmrec.vmreg
		if ^passed(a_reg_date)
			a_reg_date = vmrec.vmdreg
		if ^passed(a_clock)
			a_clock = vmrec.vmclok
		if ^passed(a_year)
			a_year = vmrec.vm_year
		if (^passed(a_vmmotd))
			a_vmmotd = vmrec.vmmotd

		if (pass_gen_data.adv_mode.ne.D_VEW_MODE .and. viivcr.ne.D_VIIVCR_PART_CRED)
		begin
			xcall whgine_write_vm(a_exists,a_rfa)
			f_lock_vm=TRUE
			pass_chn_data.h_stok = a_stkno
			xcall check_vm_exists(whgine_passed, a_exists, a_rfa)
		end
	end

	xcall e_exit

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for job field
.function whgine_auto_adv_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	a_inprec,           a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VIREC.REC'

	external function
		generate_adv_no,        a

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3
.proc
	if a_pending_status .ne. D_OK .or. g_entnam .eq. 'J_QUIT'
		freturn a_pending_status

	if(.not. cms_gngvad.and.a_data_stored.eq.T$AUTO)
	begin
		xcall ibc_message('Invalid - Auto advice numbering is not in use')
		freturn D_EMITTEDERR
	end

	if(.not. a_data_stored) then
	begin
		if(.not. cms_gngvad) then
		begin
			xcall ibc_message('A New Advice Number Must Be Entered')
			freturn D_EMITTEDERR
		end
		else
			a_data_stored = %generate_adv_no(pass_gen_data.plan_maint)
	end
	else
	begin
		xcall file(pass_chn_data.chn(VI_FILE), virec, a_data_stored, 'RD', err,,,,,
		&          D_NO_LOCK)
		if(.not.err)
		begin
			xcall ibc_message('Invalid - This advice already exists')
			freturn D_EMITTEDERR
		end
	end
	freturn a_pending_status
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       This section creates or writes a vm and a vr record
subroutine whgine_write_vm

	a_exists,       a
	a_rfa,          a
	a_old_vmrec,    a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VWREC.REC'                                             ; WG7719
	.include 'SRC:VGREC.REC'                                             ; WG7719

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		filename,       a D_FILENAME_LEN                             ; WG7719
		write_type,     a2
		err,            d3

	record ifours
		gen_channel,    i4
		chk_chn,        i4                                           ; WG7719
.proc
	;;;;; WG7719....             ; Ensure the correct commodity code is in place...
	filename = vwfile
	filename(7:3) = cn, 'XXX'
	xcall u_open(chk_chn,'i:i',filename,,,err)
	if(.not.err)
	begin
		xcall file(chk_chn, vwrec, vmcode, 'RD', err)   ; Try VW first
		if(.not.err)
		begin
			vm_comm_code = vwcomm
			xcall u_close(chk_chn)
		end
	end
	if(.not.vm_comm_code)
	begin
		filename = vgfile
		filename(8:3) = cn, 'XXX'
		xcall u_open(chk_chn,'i:i',filename,,,err)
		if(.not.err)
		begin
			xcall file(chk_chn, vgrec, vmgrp, 'RD', err) ; else VG....
			if(.not.err)
			begin
				vm_comm_code = vgcomm
				xcall u_close(chk_chn)
			end
		end
	end
	xcall u_close(chk_chn)
	;;;;; WG7719....

	gen_channel = pass_chn_data.chn(VM_FILE)
	if(.not. a_exists) then
	begin
		while(.not. vmpord)
			xcall dep_seq(vi_depot, DEP_S_PUR, vmpord)
		vmpdat = %ndate
		write_type = 'ST'
		a_exists = 'S'
	end
	else
	begin
		if(a_exists .eq. 'H')
			gen_channel = pass_chn_data.chn(HM_FILE)
		write_type = 'WR'
	end

	xcall file(gen_channel, vmrec, vmstok, write_type, err,, a_rfa)
	if err
	begin
		if write_type == 'WR' then
			xcall ibc_message('Error writing vmrec')
		else
			xcall ibc_message('Error storing vmrec')
	end
	if(write_type .eq. 'WR' .and. %passed(a_old_vmrec))
		xcall upd_wg_serials(a_old_vmrec, vmrec)

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       generates the next auto advice note no
.function generate_adv_no
	plan_maint_type,        n

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VIREC.REC'

	record gen
		filename,		a14
		vi_chn,			d4
		com_chn,		d4
		adv_no,         a6
		err,            d3
.proc
	xcall e_enter
	clear gen
	if(%passed(plan_maint_type).and.plan_maint_type) then
	begin
		repeat
		begin
			xcall pminvx_get_next_wgd_advice(adv_no, err)
			if(.not.err) exitloop
		end
	end
	else
	begin
		filename=vifile
		filename(7:3)=%string(cn,'XXX')
		xcall u_fndfil(filename,,vi_chn)

		filename=cofile
		filename(8:3)=%string(cn,'XXX')
		xcall u_fndfil(filename,'U',com_chn)
		if(.not.com_chn)
		begin
			xcall u_open(com_chn, 'U', filename,,,err)
		end
		if(err) exit	; careful with this - it is initialised at start
							; and should only be set if should not find file
							; and then failed to open
		xcall file( com_chn, cmsrec, 1, 'RN', err )
		repeat
		begin
			if(cms_gnvadv.lt.100000)
				cms_gnvadv=100000
			adv_no = cms_gnvadv
			incr cms_gnvadv
			if(cms_gnvadv.ge.999999)
				cms_gnvadv=100000
			xcall file(vi_chn, virec, adv_no, 'RD', err,,,,, D_NO_LOCK)
			if(err) exitloop
		end
		xcall file( com_chn, cmsrec, 1, 'WN', err )
	end
	xcall e_exit
	freturn adv_no
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;               check vm_depot matches dt ie. depot same
.function check_vm_depot, ^val

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'

	record gen
		err,            d3

.proc
	clear err
	if(dt .ne. vm_depot)
	begin
		if(dt .ne. vm_orig_depot) then
		begin
			xcall ibc_message('Invalid - {WHOLEGD} '+vmstok+' is at depot no '
			&                       +vm_depot)
			err=1
		end

		else
		begin
			xcall ibc_message('Warning - {WHOLEGD} '+vmstok+' has been '
			&                 +'transferred to depot '+vm_depot)
		end
	end
	freturn err
.end

.subroutine restart_all_lists
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'add_part_passed' repository, group = 'add_part_passed'
	doc_lst_id,     n
	sms_lst_id,     n
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'doclst_pass' repository, group = 'doclst_pass'
	.include 'doc_search' repository, group='doc_search'
	.include 'smslst_pass' repository, group = 'smslst_pass'

	.include 'SRC:CMSCOM.REC'

	record
		req,    i4

.proc
	xcall clear_hort_array(add_part_passed)

	xcall lbc_restart(seq_lst_id)

	xcall lbc_restart(wgd_lst_id)
	xcall lbc_restart(nstk_lst_id)
	xcall lbc_restart(prt_lst_id)
	xcall lbc_restart(cmnt_lst_id)
	xcall lbc_restart(trd_lst_id)
	for req from 1 thru 5
		reseq_req[req] = TRUE

	if( cms_doc_store )
	begin
		doc_lst_type = DRF_TYP_WG_ADVICE
		doc_lst_key(1:6) = vi_job
		xcall doc_lst_restart(gold_com, gold_ax, doc_lst_id, fkeys[DOC_FKEYS],
		&        doclst_pass, doc_search,
		&        %ts_tabset(DTS_TABINDEX, tabset_id, DTS_LIST, doc_lst_id ))
	end

	if( sms_lst_id )
	begin
		sms_lst_type = SMS_TYP_WHOLEGOOD
		sms_lst_key(1:6) = vi_job
		xcall lbc_restart(sms_lst_id)
	end

	xreturn
.end

.subroutine refresh_all_lists

	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'add_part_passed' repository, group = 'add_part_passed'
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'fkeys' repository, group = 'fkeys'
	.include 'invoice_totals' repository, group='invoice_totals'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal


	record ifours
		req,    i4

.proc
	xcall clear_hort_array(add_part_passed)

	xcall lbc_restart(seq_lst_id)
	xcall l_queue(seq_lst_id, D_LBOTTOM)
	req = D_LTOP
	xcall l_process(seq_lst_id, req, whgine_lst,, gold_com, gold_ax,
	&               fkeys, whgine_passed, invoice_totals)

	xcall lbc_restart(wgd_lst_id)
	xcall lbc_restart(nstk_lst_id)
	xcall lbc_restart(prt_lst_id)
	xcall lbc_restart(cmnt_lst_id)
	xcall lbc_restart(trd_lst_id)
	for req from 1 thru 5
		reseq_req[req] = TRUE

	if pass_gen_data.adv_mode .eq. D_INS_MODE
		pass_gen_data.adv_mode = D_AMD_MODE
	xreturn
.end

.subroutine clear_hort_array

	.include 'add_part_passed' repository, group = 'add_part_passed'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:POS_PARTS.CMN'
	.include 'SRC:HIDREC.REC'

	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4

	record gen
		loop,           d4
.proc
	if(cms_hort)            ; Clear memory array for hort deliveries
	begin
		hid_lat = 0
		for loop from 1 thru hid_max
			clear ^m(ll_hidrec[loop],hid_mhndl),^m(ll_hidrec[loop].ll_loop,
			&     hid_mhndl)
	end

	xreturn
.end

.subroutine whgine_override

	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	.include 'add_part_passed' repository, group='add_part_passed'
	override_val,           d
	override_type,          n
	override_based,         n
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_vj' repository, group= 'whgine_nstk'
	.include 'add_part_str' repository, group = 'part_data'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:IVTCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3
		.include 'whgine_lst' repository, group='whgine_lst'
		tot_sal,        d10
		cst_pcnt,       d10
		vat_ex,         d10
		diff,           d10
		main_wg_fnd,    d1
		write_req,      d1
		store_tstk,     a8
		attch_cost,     d10
		tmp_rate,       d4

	record ifours
		linp_id,        i4

.proc
	clear gen, ^i(ifours)
	if .not. adv_tot_cost .and..not. override_based
	begin
		xcall ibc_message('Unable to override - No costs available')
		xreturn
	end

	if override_type .eq. D_VAT_INC then
		xcall whgine_vat_calc(vat_ex, cms_uk_def_vat,
		&       vt_vat_code, vt_vrat, override_val,
		&       D_RET_VAT_INC, D_RET_VAT_EXC)
	else
		vat_ex = override_val

	xcall i_ldinp(linp_id, g_utlib, 'whgine_linp', D_NOPLC,,,
	&             h_seq_linp_name)
	if(.not.pass_gen_data.plan_maint.and.
	&       wg_security .eq. ACC_NO_COST_DISP)
		xcall i_setdel(linp_id, 'full_set', 'lst_tot_cost')
	; accumulate wholegoods and attachments
	xcall l_data( seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err )
	while( .NOT. err )
	begin
		write_req = false
		clear cst_pcnt
		using lst_ntype select
			(D_VJ_NSTK),
			begin
				if override_based then
				begin
					if(adv_tot_retail - adv_tot_disc)
						cst_pcnt = (lst_retail - lst_dsp_disc) * 1000000 / (adv_tot_retail -
						&     adv_tot_disc)
				end
				else
				begin
					if(adv_tot_cost)
						cst_pcnt = lst_tot_cost * 1000000 / adv_tot_cost
				end
				set lst_tot_retail, lst_retail = vat_ex * cst_pcnt / 1000000
				if(pass_gen_data.plan_maint.and.
				&   whgine_lst.wg_pm_charge_type.ne.PMC_CHARGE_CLOCK_READING)
					whgine_lst.wg_pm_contract_charge=lst_tot_retail
				clear lst_disc, lst_dsp_disc, lst_vi_disc
				tot_sal += lst_retail
				write_req = true
			end
			(D_VJ_WGD),
			begin
				if override_based then
				begin
					if(adv_tot_retail - adv_tot_disc)
						cst_pcnt = (lst_retail - lst_dsp_disc) * 1000000 / (adv_tot_retail -
						&     adv_tot_disc)
				end
				else
				begin
					if(adv_tot_cost)
						cst_pcnt = lst_tot_cost * 1000000 / adv_tot_cost
				end
				set lst_tot_retail, lst_retail = vat_ex * cst_pcnt / 1000000

				clear lst_disc, lst_dsp_disc, lst_vi_disc
				tot_sal += lst_retail
				main_wg_fnd = true
				if lst_vat .eq. 1      ; store
					store_tstk = lst_tstk
				write_req = true
				; do attachments
				if attach_ll
				begin
					xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
					while .not. err
					begin
						clear cst_pcnt
						if override_based then
						begin
							if(adv_tot_retail)
								cst_pcnt = vd_rrp(D_FC) * 1000000 / adv_tot_retail
						end
						else
						begin
							if cms_gnvcos .eq. D_WG_AUTO_COST_ADJ .and.
							&   .not. vd_fin_inv then
								attch_cost = %max(vd_cost[D_FC], vd_est_cos[D_FC])
							else
								attch_cost = vd_cost[D_FC]
							if(adv_tot_cost)
								cst_pcnt = attch_cost * 1000000 / adv_tot_cost
						end
						xcall whgine_attach_cur_val(vdrec, lst_code, pass_gen_data.vi_currency, invoice_totals)
						vd_rrp(D_FC) = vat_ex * cst_pcnt / 1000000
						; call the attachment routine agaiun to set vat inc
						clear vd_vi_rrp[D_FC]
						xcall whgine_attach_cur_val(vdrec, lst_code, pass_gen_data.vi_currency, invoice_totals)
						if(.not.vdvat)
						begin
							if(cms_country.eq.EIRE_VAT) then
								vdvat=pass_gen_data.h_vat_code
							else
								vdvat = cms_uk_def_vat
						end
						xcall f_vat_rate(vdvat, tmp_rate, true)
						if(tmp_rate.and..not.pass_gen_data.h_vatable)
						begin
							if(cms_country.eq.EIRE_VAT) then
								vdvat=ivt_vat_zero
							else
								vdvat=cms_uk_zero_vat
						end

						tot_sal += vd_rrp(D_FC) * vdqty
						xcall ll_process(attach_ll, D_LL_WRITE, vdrec, err)
						xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
					end
				end
				xcall reset_attch_vals(whgine_lst)
			end
			(D_VJ_PART),  begin
				if override_based then
				begin
					if(adv_tot_retail - adv_tot_disc)
						cst_pcnt = ((lst_retail - lst_disc)*lst_qty) * 1000000 /
						&     (adv_tot_retail -adv_tot_disc)
				end
				else
				begin
					if(adv_tot_cost)
						cst_pcnt = lst_tot_cost * 1000000 / adv_tot_cost
				end
				lst_retail = (vat_ex * cst_pcnt / 1000000) / lst_qty
				clear lst_disc, lst_disc_pcnt, lst_dsp_disc, lst_vi_disc
				lst_tot_retail = lst_retail * lst_qty
				tot_sal += lst_tot_retail
				write_req = true
			end
		endusing
		if (lst_ntype != D_VJ_COMMENT)
		begin
			xcall whgine_vat_calc(lst_vi_retail, lst_vat,
			&       vt_vat_code, vt_vrat, lst_retail,
			&       D_RET_VAT_EXC, D_RET_VAT_INC)

			if write_req
			begin
				set lst_moded, items_moded = true
				xcall l_data( seq_lst_id, D_LWRITE, linp_id, whgine_lst,, err )
			end
		end
		xcall l_data( seq_lst_id, D_LNEXT, linp_id, whgine_lst,, err )
	end

	if override_type .eq. D_VAT_EXC then
	begin
		diff = tot_sal - override_val
		if diff
		begin
			xcall l_data( seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err )
			if .NOT. err
			begin
				while .not. err .and. main_wg_fnd .and.
				&       lst_ntype .ne. D_VJ_WGD
					xcall l_data( seq_lst_id, D_LNEXT, linp_id, whgine_lst,, err )
				if lst_ntype .eq. D_VJ_WGD then
				begin
					lst_retail -= diff
					xcall reset_attch_vals(whgine_lst)
				end
				else
				begin
					lst_tot_retail -= diff
					lst_retail = lst_tot_retail / lst_qty
					lst_tot_retail = lst_retail * lst_qty
				end
				xcall whgine_vat_calc(lst_vi_retail, lst_vat,
				&       vt_vat_code, vt_vrat, lst_retail,
				&       D_RET_VAT_EXC, D_RET_VAT_INC)
				xcall l_data( seq_lst_id,D_LWRITE, linp_id, whgine_lst,, err )
			end
		end
	end

	else
	begin
		; recalc totals
		xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed,
		&                        whgine_hdr, whgine_inv_tab,
		&                        add_part_passed, invoice_totals)
		if inv_total .ne. override_val
		begin
			xcall whgine_vat_calc(diff, cms_uk_def_vat,
			&       vt_vat_code, vt_vrat, (override_val - inv_total),
			&       D_RET_VAT_INC, D_RET_VAT_EXC)
			if diff
			begin
				xcall l_data( seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err )
				if .NOT. err
				begin
					while .not. err .and. lst_tstk .ne. store_tstk
						xcall l_data( seq_lst_id, D_LNEXT, linp_id,
						&             whgine_lst,, err )
					lst_retail += diff
					xcall whgine_vat_calc(lst_vi_retail, lst_vat,
					&           vt_vat_code, vt_vrat, lst_retail,
					&           D_RET_VAT_EXC, D_RET_VAT_INC)
					xcall l_data( seq_lst_id,D_LWRITE, linp_id, whgine_lst,,
					&             err )
				end
			end
		end
	end

	xcall ibc_window(D_DELETE, linp_id)

	xcall lbc_restart(wgd_lst_id)
	xcall lbc_restart(nstk_lst_id)
	xcall lbc_restart(prt_lst_id)
	clear reseq_req[D_VJ_WGD+1], reseq_req[D_VJ_NSTK+1],
	&       reseq_req[D_VJ_PART+1]
	xcall whgine_disp_lst_tots(gold_com, gold_ax, whgine_passed,
	&                            whgine_hdr, whgine_inv_tab,
	&                            add_part_passed, invoice_totals)

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       check if all lines hidden, if so check for invoice comment
.function chk_all_lines_hid, ^val

	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	record gen
		err,            d3
		all_hidden,     d1
		.include 'whgine_lst' repository, group = 'whgine_lst'

	record ifours
		linp_id,        i4
.proc
	clear gen, ^i(ifours)
	if !%ScratchPadCheck(CMNT_WG_INV_STY,vi_job) ; no invoice comment
	begin
		xcall i_ldinp(linp_id, g_utlib, 'whgine_linp', D_NOPLC,,,
		&         h_seq_linp_name)
		; NOTE THAT FOR pass_gen_data.PLAN_MAINT TYPE ADVICES, lst_tot_cost field is
		; not set.
		if(.not.pass_gen_data.plan_maint.and.
		&   wg_security .eq. ACC_NO_COST_DISP)
			xcall i_setdel(linp_id, 'full_set', 'lst_tot_cost')

		all_hidden = true
		; accumulate wholegoods and attachments
		xcall l_data( seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err )
		while( .NOT. err )
		begin
			; exitloop if hit trade ins
			; if self biller type then should not skip reafing
			; when it finds first trade in record.  In fact, should only
			; contain trade ins
			if(pass_chn_data.h_prog_code.ne.P_COD_SEL_BILL.and.
			&    lst_ntype.eq.D_VJ_TRADE) exitloop
			; check for non hidden line or non hidden attach for main wgd type
			if (lst_hide.ne.D_YES .or.
			&    (lst_ntype .eq. D_VJ_WGD
			&    .and.lst_hide_att.ne.D_YES.and.lst_attach_num))
			begin
				all_hidden = false
				exitloop
			end
			xcall l_data( seq_lst_id, D_LNEXT, linp_id, whgine_lst,, err )
		end
		err = all_hidden
		if all_hidden
		begin
			xcall ibc_message('If all lines hidden then Invoice Comment must be entered')
			xcall ts_tabset(DTS_ACTIVE, gold_com.tabset_id, D_INV_CMNT_TAB_ID)
		end
		xcall ibc_window(D_DELETE, linp_id)
	end
	freturn err
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       builds attachment linked list and returns number of attachments
.function bld_attach_list, ^val

	a_stkno,        a
	a_attach_ll,    a
	a_attach_tot,   n
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3
		key_ref,        d1
		num_attach,     d3

	.align
	gen_channel,    i4

.proc
	init gen
	vkkey = vijob + a_stkno
	if(vistat .ge. D_ADV_INVOICED) then
	begin
		xcall file(pass_chn_data.chn(VK_FILE), vdrec, vkkey, 'FI', err)
		gen_channel = pass_chn_data.chn(VK_FILE)
		key_ref = 0
	end
	else
	begin
		xcall file(pass_chn_data.chn(VD_FILE), vdrec, a_stkno, 'FI', err, 1)
		gen_channel = pass_chn_data.chn(VD_FILE)
		key_ref = 1
	end
	repeat
	begin
		xcall file(gen_channel, vdrec, a_stkno, 'RS', err,
		&            key_ref,,,, D_NO_LOCK)
		if err .or. vdstok .ne. a_stkno
			exitloop
		if(key_ref.eq.0.and.vdgrn.ne.vijob) exitloop

		xcall whgine_attach_cur_val(vdrec, vmcode, vi_sell_cur, invoice_totals)

		if %passed(a_attach_ll)
		begin
			if .not. a_attach_ll
				xcall ll_open(a_attach_ll, ^size(vdrec))
			xcall ll_process(a_attach_ll, D_LL_APPEND, vdrec)
		end
		incr num_attach
	end
	freturn num_attach
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       subroutine to check attachment currency.  If attachment currency
;       not = pass_gen_data.vi_currency, update sales price
.subroutine whgine_attach_cur_val
	.include 'vdrec' repository, group='vdrec'
	pass_vmcode,            a
	pass_vi_sell_cur,       a
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:IVTCOM.REC'

	external function
		f_curr_bc,      d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record general
		h_rrp,  d10
		tmp_rate,       d4

.proc
	h_rrp=vd_rrp[D_FC]

	if(vd_sell_cur.ne.pass_vi_sell_cur)
	begin
		xcall calc_wg_pric(vd_rrp(D_FC),pass_vmcode,vdcode,
		&              pass_vi_sell_cur,vd_sell_cur,vd_rrp(D_FC),1)
		vd_sell_cur=pass_vi_sell_cur
	end
	if(.not.vdvat)
	begin
		if(cms_country.eq.EIRE_VAT) then
			vdvat=pass_gen_data.h_vat_code
		else
			vdvat = cms_uk_def_vat
	end

	xcall f_vat_rate(vdvat, tmp_rate, true)

	if(tmp_rate.and..not.pass_gen_data.h_vatable)
	begin
		if(cms_country.eq.EIRE_VAT) then
			vdvat=ivt_vat_zero
		else
			vdvat=cms_uk_zero_vat
	end
	if(h_rrp.ne.vd_rrp[D_FC].or..not.vd_vi_rrp[D_FC])
	begin
		if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
			vd_vi_rrp[D_FC]=vd_rrp[D_FC]
		else
			xcall whgine_vat_calc(vd_vi_rrp(D_FC), vdvat,
			&         vt_vat_code, vt_vrat, vd_rrp(D_FC),
			&         D_RET_VAT_EXC, D_RET_VAT_INC)
		vd_vi_rrp[D_BC]=%f_curr_bc(vd_vi_rrp[D_FC],pass_gen_data.vi_exch_rate)
	end
	xreturn

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_canc_parts

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'

	a_listid,       n

	.include 'add_part_str' repository, group='part_data'
	.include 'add_part_passed' repository, group='add_part_passed'

	.include 'SRC:OPSCOM.REC'

	record gen
		err,            d3
	record ivars
		no_items,       i4
		linp_id,        i4
.proc
	clear gen, ^i(ivars)
	xcall l_status( a_listid, D_LLASTITM, no_items, D_LINPID, linp_id )
	if( no_items )
	begin
		xcall l_data(a_listid, D_LFIRST, linp_id, part_data,, err)
		while .not. err
		begin
			if( .not. prev_batch .and. part_sold_qty .and.
			&   part_type .gt. D_PMF_TYP_MEMO)
				xcall add_part_del_hid(gold_com, gold_ax, add_part_passed,
				&                      part_data)

			xcall l_data( a_listid, D_LNEXT, linp_id, part_data,, err)
		end
	end

	xreturn
.end

; Display Method
.function whgine_cur_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec                ,a      ; (Optional) record passed to I_INPUT.
                                        ;  Not passed if in I_INPFLD/I_DSPFLD.
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	; a_method_data         ,a      ; Optional method data argument

	.include "SRC:OPSCOM.REC"
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'


	external function
		f_get_dec,      a
		f_curr_bc,      d
		f_curr_fc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	stack record
	number,                 d18

.proc
	; if displayed value is blank we can assume that blank if zero has been applied and return
	if a_data_displayed .eqs. ''
	freturn TRUE


	onerror bad_digit
	number = ^d(a_data_stored)
	if(pass_gen_data.curr_dsp)
	begin
		if(pass_gen_data.vi_currency .ne. cms_base_cur)
			number = %f_curr_bc(number, fcf_std_rate)
		else
			number = %f_curr_fc(number, fcf_std_rate)
	end
	bad_digit,
	offerror

	if cur_dp[cur_flag+1]
		then
	a_data_displayed = %f_get_dec(number, cur_dp[cur_flag+1])[RIGHT]
	else
		a_data_displayed = ^d(number)


	freturn TRUE
.end

; Display Method
.function whgine_bal_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec                ,a      ; (Optional) record passed to I_INPUT.
                                        ;  Not passed if in I_INPFLD/I_DSPFLD.
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include "SRC:OPSCOM.REC"

.proc
	if disp_balance then
		freturn %whgine_cur_display(a_data_stored, a_data_displayed, inputinfo,
		&     a_inprec, a_attributes, a_color, gold_com)
	else
		clear a_data_displayed

	freturn TRUE
.end

.subroutine whgine_fpro_leave

	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'

	.include "WND:tools.def"

.proc
	if .not. vi_fpro
		xcall ibc_disable(inp_wndid, 'vi_fpedat')
	else
		xcall ibc_enable(inp_wndid, 'vi_fpedat')
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_vb_rrp_chg ,^val

	a_data_entered       ,a
	a_data_stored        ,n
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'

	external function
		f_curr_fc,      d


.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_COPY'))
		freturn a_pending_status

	a_pending_status = %currency_bc_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vb, gold_com, gold_ax)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT')
		freturn a_pending_status

	if(.not.a_data_stored)
	begin
		if(f_wg_mv_comm)
			xcall ibc_message('Warning - Market Value not set and therefore '
			&         +'defaults can not be calculated')
		freturn D_OK
	end

	if(f_wg_mv_comm)
	begin
		if(^d(a_data_stored).ne. vb_rrp_bc)
		begin
			vb_e_repairs_bc=(^d(a_data_stored) * VB_EST_REP_P)#4
			vb_e_warr_bc=(^d(a_data_stored) * VB_EST_WARR_P)#4
		end
		vb_rrp_bc= ^d(a_data_stored)
	end

	freturn D_OK

.end

.function whgine_trd_net_chg ,^val

	a_data_entered       ,a
	a_data_stored        ,n
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'
	.include 'SRC:VMCOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_COPY'))
		freturn a_pending_status

	a_pending_status = %currency_bc_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vb, gold_com, gold_ax)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT')
		freturn a_pending_status

	if(pass_chn_data.h_prog_code .eq. P_COD_SEL_BILL .and.
	&  vb_tip_bc .ne. ^d(a_data_stored)
	&   .and. .not. (vi_stok .or. vi_tigr)) then
	begin
		xcall ibc_message('Invalid - The net stock value must '
		&                       +'be the same as trade in value for trade in only '
		&                       +'advices if the main washout '
		&                       +'stock number has not been set.')
		freturn D_EMITTEDERR
	end
	xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)

	freturn D_OK

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This function finds an item in the sequence list and then accumulates the
; retail values of all attachments.
;
.function get_attach_tot, ^val
	a_stkno,        a
	a_init_entry,   n
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:IVTCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record gen
		err,            d3
		.include 'whgine_lst' repository, group='whgine_lst'
		rtn_val,        d10
		key_ref,        d1
		tmp_rate,       d4

	record ifours
		linp_id,        i4
		gen_channel,    i4

.proc
	clear gen, ^i(ifours)

	if(.not.a_stkno) freturn rtn_val

	xcall i_ldinp(linp_id, g_utlib, 'whgine_totinp', D_NOPLC,,,
	&             h_seq_linp_name)
	if(.not.pass_gen_data.plan_maint.and.
	&       wg_security .eq. ACC_NO_COST_DISP)
		xcall i_setdel(linp_id, 'full_set', 'lst_tot_cost')

	if a_init_entry then
	begin
		if(vistat .ge. D_ADV_INVOICED) then
		begin
			vkkey = vijob + a_stkno
			xcall file(pass_chn_data.chn(VK_FILE),vdrec,vkkey,'FI',err)
			gen_channel = pass_chn_data.chn(VK_FILE)
			key_ref = 0
		end
		else
		begin
			xcall file(pass_chn_data.chn(VD_FILE),vdrec, a_stkno,'FI',err,1)
			gen_channel = pass_chn_data.chn(VD_FILE)
			key_ref = 1
		end
		repeat
		begin
			xcall file(gen_channel,vdrec, a_stkno,'RS', err,
			&                key_ref,,,, D_NO_LOCK)
			if err .or. vdstok .ne. a_stkno
				exitloop
			xcall whgine_attach_cur_val(vdrec, vmcode, vi_sell_cur, invoice_totals)
			call set_rtn_val
		end
	end
	else
	begin
		; accumulate wholegoods and attachments
		xcall l_data( seq_lst_id, D_LFIRST, linp_id, whgine_lst,, err )
		while( .NOT. err )
		begin
			if lst_stkno .eq. a_stkno
			begin
				if attach_ll
				begin
					xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
					while .not. err
					begin
						xcall whgine_attach_cur_val(vdrec, vmcode, vi_sell_cur, invoice_totals)
						call set_rtn_val
						xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
					end
				end
				exitloop
			end
			xcall l_data( seq_lst_id, D_LNEXT, linp_id, whgine_lst,, err )
		end
	end
	xcall ibc_window(D_DELETE, linp_id)
	freturn rtn_val
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_rtn_val,
	if(pass_chn_data.h_prog_code.eq.P_COD_WGD_VAT_INC) then
	begin
		if(.not.vdvat)
		begin
			if(cms_country.eq.EIRE_VAT) then
				vdvat=pass_gen_data.h_vat_code
			else
				vdvat = cms_uk_def_vat
		end
		xcall f_vat_rate(vdvat, tmp_rate, true)
		if(tmp_rate.and..not.pass_gen_data.h_vatable)
		begin
			if(cms_country.eq.EIRE_VAT) then
				vdvat=ivt_vat_zero
			else
				vdvat=cms_uk_zero_vat
		end

		if(.not.vd_vi_rrp(D_FC))
			xcall whgine_vat_calc(vd_vi_rrp(D_FC), vdvat,
			&         vt_vat_code, vt_vrat, vd_rrp(D_FC),
			&         D_RET_VAT_EXC, D_RET_VAT_INC)
		rtn_val += vd_vi_rrp(D_FC) * vdqty
	end
	else
		rtn_val += vd_rrp(D_FC) * vdqty
	return

.end

.subroutine whgine_get_cost
	rtn_val,        n
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'

.proc
	clear rtn_val

	if(wg_security .eq. ACC_NO_COST_DISP) xreturn

	; do not show cost if this is restricted group
	if(whgine_passed.f_acc_wg_exclude.gt.1) xreturn

	if(whgine_passed.f_acc_wg_exclude.eq.1.and.%f_chk_vgf_restricted(,vj_grp, dt))
		whgine_passed.f_acc_wg_exclude=2

	; do not show cost if this is restricted group
	if(whgine_passed.f_acc_wg_exclude.gt.1) xreturn

	if vj_fin_inv then
		rtn_val =  vj_fc_cost
	else
		rtn_val = %max(vj_fc_ecos, vj_fc_cost)

	xreturn
.end

.function whgine_not_sbill_change ,^val
	a_data_entered       ,a
	a_data_stored        ,d
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CMFCOM.REC'

.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER' .or. g_entnam .eq. 'J_NEW_CUS'))
		freturn a_pending_status

	if a_data_stored .eq. D_VI_NOT_SB_PUR_INV .and. .not. cmf_pur_acc
	begin
		xcall ibc_message('Invalid - Supplier a/c not set up.'
		&                 +'  Select Self Biller Option or Exit and Set Up '
		&                 +'Supplier A/c for this Customer')
		a_pending_status = D_EMITTEDERR
	end

	freturn a_pending_status
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       update the vj fields from screen input fields
.subroutine update_vj_fields

	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal
	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	external function
		f_curr_bc,      d

	record gen
		err,            d3
		loop,           d2
.proc
	xcall whgine_set_vj_curr_flds(whgine_vj, whgine_passed, invoice_totals)

	vjjob = vijob
	vjtstk = vj_tstk
	if(pass_gen_data.adv_mode .eq. D_INS_MODE .and. cms_gnavsk .and. vjnstk .eq. D_VJ_NSTK
	&                       .and. vj_tstk .eq. T$AUTO)
	begin
		while(vjtstk .eq. T$AUTO)
		begin
			xcall nstk_seq(vj_tstk, err, vi_depot)
			if(.not.err)
				vjtstk = vj_tstk
		end
	end

	; wg7433	if(vjnstk .eq. D_VJ_NSTK .and. pass_chn_data.h_prog_code.eq.P_COD_CAR_SAL) then
	; wg7433	  vjtype = 1
	; wg7433	else
	vjtype = vj_type

	if(vj_used) then
		vjused = 'U'
	else
		vjused = 'N'

	vjcode = vj_code
	vjnmod = vj_model
	vjngrp = vj_grp
	vjnmak = vj_mak
	if( vjnstk .lt. D_VJ_PART)
		for loop from 1 thru 10
			vjnspc(loop) = vj_spec[loop]
	vjnser = vj_ser
	vjnreg = vj_reg
	vj_dreg = vj_reg_date
	vjnclk = vj_clok
	vj_hide = vj_hide_ln
	vj_hide_attach = vj_hide_att
	vjnvat = vj_vat
	vjcost = vj_fc_cost
	vj_f_rrp = vj_fc_rrp
	vj_f_vi_rrp = vj_fc_vi_rrp
	vj_f_sett = vj_fc_sett
	vj_f_disc = vj_fc_disc
	vj_f_vi_disc=vj_fc_vi_disc
	if(.not.vj_f_disc)
		clear vj_f_vi_disc
	if(.not.vj_f_vi_disc.and.vj_f_disc)
	begin
		if(vjnstk.ne.D_VJ_PART)
		begin
			if(pass_chn_data.h_prog_code .eq. P_COD_CAR_SAL) then
				vj_f_vi_disc=vj_f_disc
			else
				xcall whgine_vat_calc(vj_f_vi_disc, vjnvat,
				&        vt_vat_code, vt_vrat, vj_f_disc,
				&        D_RET_VAT_EXC, D_RET_VAT_INC)
		end
	end
	vjsold = 1
	vj_qual = vj_qualify
	vj_orig_price = lst_orig_price
	vj_kit_status = vj_kit_part
	if(pass_gen_data.plan_maint) then
	begin
		vjrec.vj_wg_pm_group=whgine_vj.vj_inp_pm_group
	end
	else
	begin
		if(pass_gen_data.pm_create_cont_ivt.and.vjnstk .eq. D_VJ_WGD) then
			vjrec.vj_wg_pm_group = whgine_vj.vj_inp_pm_group
		else
		begin
			if(f_wg_md_disc)
				vj_md_group=vj_inp_md_group
		end
	end
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       update the vm fields from the vj fields
.subroutine update_vm_from_vj

	old_vmrec,      a
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_curr_bc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		pass_trk_status,    a1
		err,            d3

.proc
	old_vmrec = vmrec

	vmadno = vjjob
	vmstok = vjtstk
	if(pass_gen_data.adv_mode .ne. D_VEW_MODE)
		vminvf = TRUE

	; if partial credit, do not want to update any of the vm fields

	if(viivcr .eq. D_VIIVCR_PART_CRED) return

	; FOR PARTIAL INVOICES, ONLY update vm if this is not history item
	if(viivcr .eq. D_VIIVCR_PART_INV.and.vj_vm_exists.eq.'H'.and.
	&   vistat .lt. D_ADV_INVOICED) return

	vm_f_disc = vj_f_disc
	vm_rrp(D_FC) = vj_f_rrp
	vm_rrp(D_BC) = %f_curr_bc(vm_rrp(D_FC), pass_gen_data.vi_exch_rate)
	vm_sett(D_FC) = vj_f_sett
	vm_sett(D_BC) = %f_curr_bc(vm_sett(D_FC), pass_gen_data.vi_exch_rate)
	vmmrrp = vj_fc_mrrp
	vmgrp = vjngrp
	vmmak = vjnmak
	vmcode = vjcode         ; input field
	vmmodl = vjnmod
	vmser = vjnser
	vmreg = vjnreg
	vmwdat = vj_warr_sdat
	vm_warr_edat = vj_warr_edat
	vm_warr_end_clock = vj_warr_end_clock
	vm_ex_warr_edat = vj_ex_warr_edat
	vm_ex_warr_end_clock = vj_ex_warr_end_clock
	vmdeld = vj_vmdeld
	vm_extra_comm = vj_vm_extra_comm
	; WG7704 special for DOE - if set customer delivery date and blank
	; warranty then set this to delivery date
	if(cms_user_id.eq.10687.and..not.vmrec.vmwdat.and.vmrec.vmdeld)
		vmrec.vmwdat = vmrec.vmdeld

	vmdreg = vj_dreg
	vmmotd	= vj_vmmotd
	vmclok = vjnclk
	if(.not. vm_sb_adv)
		vmvat = vjnvat

	vmnu = vjused
	vmtype = vjtype

	xcall vm_change_to_qualify(VMREC, vj_qual)

	vm_qualifying = vj_qual

	if(vicust.ne.vmrec.vmcust)
	begin
		; special for simba - if in stock set trk status to 'R'
		if(cms_user_id.eq.10457.and.vmass.eq.0) then
			pass_trk_status='R'
		else
			pass_trk_status=' '

		xcall vm_cust_trk_update(vmrec.vmstok, Vmrec.vmcust, vicust  , gold_com, pass_trk_status)
	end

	vmcust = vicust
	vmadno = vijob
	vmcord = viord
	vmrep = virep
	vm_sell_cur = pass_gen_data.vi_currency
	vm_sell_cnv = pass_gen_data.vi_exch_rate
	vm_md_group=vj_md_group
	xreturn
.end

.subroutine whgine_del_hid

	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_lst' repository, group = 'whgine_lst'


	.include 'SRC:VICOM.REC'

	.include 'SRC:HIDREC.REC'
	.include 'SRC:HPDREC.REC'

	.include 'SRC:HORT.CMN'
	.include 'SRC:POS_PARTS.CMN'

	structure ll_hidrec
		ll_hid,         a ^size(hidrec)
		ll_hid_st,      d1
		ll_loop,        i4

	.align
	record gen
		loop,           i4
		err,            d3
		group hpd_key3, a
			hpk3_batch,     a6
			hpk3_line,      d4
		endgroup

.proc
	for loop from 1 thru hid_lat
	begin
		hidrec = ^m(ll_hidrec[loop].ll_hid,hid_mhndl)
		if( hid_line_no .eq. ^d(whgine_lst.lst_tstk(5:4)))
		begin
			if(viivcr.eq.D_VIIVCR_INVOICE.or.
			& viivcr.eq.D_VIIVCR_PART_INV) then
			begin
				; reset allocated qty on hpdrec
				hpk3_batch = hid_batch
				hpk3_line = hid_bat_line
				xcall file( g_hpd_chn, hpdrec, hpd_key3, 'RD',
				&                                err, 3 )
				if( ^m(ll_hidrec[loop].ll_hid_st, hid_mhndl) .gt. 0 ) then
				begin
					xcall file( g_hid_chn,hidrec,
					&                           ^m(ll_hidrec[loop].ll_hid(1:29), hid_mhndl),
					&                               'RD',err )
					hpd_stk_qty = hpd_stk_qty + hid_qty
					xcall file( g_hid_chn, hidrec, hidrec(1:29),
					&                                'DE', err )
				end
				else
					hpd_alloc = hpd_alloc - hid_qty
				xcall file( g_hpd_chn, hpdrec, hpd_key3, 'WR', err, 3 )
			end
			else
			begin
				; if Credit/Self-bill delete HID/HPD records
				if( ^m(ll_hidrec[loop].ll_hid_st,hid_mhndl) .gt. 0 ) then
				begin
					hpk3_batch = hid_batch
					hpk3_line = hid_bat_line
					xcall file( g_hpd_chn, hpdrec, hpd_key3, 'RD', err, 3 )
					if( .not. err )
						xcall file( g_hpd_chn, hpdrec, hpd_key3, 'DE', err, 3 )
					xcall file( g_hid_chn,hidrec,
					&                           ^m(ll_hidrec[loop].ll_hid(1:29), hid_mhndl),
					&                               'RD',err )
					xcall file( g_hid_chn, hidrec, hidrec(1:29),
					&                                'DE', err )
				end
			end
			^m(ll_hidrec[loop].ll_hid_st, hid_mhndl) = -1
			clear ^m(ll_hidrec[loop].ll_hid, hid_mhndl)
		end
	end

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     change method for vj discount field
.function whgine_vj_cost_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:CM4REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

.proc
	a_pending_status = %currency_na_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj, gold_com, gold_ax)

	if a_pending_status .ne. D_OK
		freturn a_pending_status

	vj_bc_cost = ^d(a_data_stored)
	xcall whgine_disp_vj_curr_vals(gold_com, whgine_vj, inp_wndid, whgine_passed, invoice_totals)

	freturn a_pending_status
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_vj_curr_display, ^val, reentrant

	a_data_stored           ,n      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	.include 'whgine_vj' repository, group = 'whgine_vj'
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include "SRC:OPSCOM.REC"
	.include "SRC:CMSCOM.REC"

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if pass_gen_data.vi_currency .eq. cms_base_cur then
		clear a_data_displayed
	else
		freturn %currency_na_display(a_data_stored, a_data_displayed,
		&                           inputinfo, whgine_vj, a_attributes,
		&                           a_color, gold_com)
	freturn TRUE
.end

.function whgine_vat_change ,^val

	a_data_entered       ,a
	a_data_stored        ,d
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"
	.include "SRC:CMSCOM.REC"
	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record
		.include 'vat_user' repository, group = 'vat_user'
		fldnam,     a30

.proc
	a_pending_status = %vat_change( a_data_entered, a_data_stored, a_pending_status, inputinfo, whgine_vj)
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER'))
		freturn a_pending_status

	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	xcall i_user(inp_wndid,fldnam,vat_user)

	if a_data_stored
	begin
		if(usr_rate.and..not.pass_gen_data.h_vatable)
		begin
			xcall ibc_message('Invalid - VAT Rate '+ %string(a_data_stored)
			&                 +' Non Zero. Default will be applied')
			a_pending_status = D_EMITTEDERR
		end

	end
	freturn a_pending_status
.end
.function whgine_trd_vat_chg ,^val

	a_data_entered       ,a
	a_data_stored        ,d
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_fkeys,                a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"
	.include "SRC:CMSCOM.REC"
	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record
		.include 'vat_user' repository, group = 'vat_user'
		fldnam,     a30

.proc
	a_pending_status = %vat_change( a_data_entered, a_data_stored, a_pending_status, inputinfo, whgine_vb)
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER'))
		freturn a_pending_status

	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	xcall i_user(inp_wndid,fldnam,vat_user)

	if a_data_stored
	begin
		if( usr_rate.and.
		&  ((.not.pass_gen_data.h_vatable.or..not.pass_gen_data.h_vatreg).or.
		&  ((cms_country.eq.UK_VAT.OR.cms_country.eq.EIRE_VAT).and.vb_used.and..not.vb_qualify)))
		begin
			xcall ibc_message('Invalid - Vat Rate '+ %string(a_data_stored)
			&                 +' Non Zero.  Default Will Be Applied')
			a_data_stored=pass_gen_data.sb_vat_zero
			xcall i_putfld(inp_wndid,'*CURR*', whgine_vb, 'vb_vat',
			&              a_data_stored, gold_com)
			a_pending_status = D_EMITTEDERR
		end
		else
		begin
			; IF ZERO VAT CODE FOR VATABLE CUSTOMER AND IRELAND WARNING
			if(.not. usr_rate.and..not.
			&  ((cms_country.eq.UK_VAT.OR.cms_country.eq.EIRE_VAT)
			& .and.vb_used.and..not.vb_qualify))
			begin
				xcall ibc_message('Warning Zero Vat Rate selected for vatable customer')
			end
		end
		if(a_pending_status.ne.D_EMITTEDERR.and.cms_country.eq.EIRE_VAT)
		begin
			vb_vat=a_data_stored
			xcall whgine_valid_trd_pri(inputinfo,
			&      whgine_vb, gold_com, gold_ax, a_fkeys, whgine_passed)
		end
	end
	freturn a_pending_status
.end
.function whgine_trd_vb_qual_chg ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_fkeys,                a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"
	.include "SRC:CMSCOM.REC"
	.include 'SRC:VICOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       g_entnam .eq. 'J_QUIT')
		freturn a_pending_status
	; WG7433        if( cms_country.eq.EIRE_VAT.and.pass_gen_data.h_vatable.and. vb_vat .and.vb_tip_bc)
	if(pass_gen_data.h_vatable.and. vb_vat .and.vb_tip_bc)
	begin
		; WG7433            if(a_pending_status.ne.D_EMITTEDERR.and.cms_country.eq.EIRE_VAT)
		if(a_pending_status.ne.D_EMITTEDERR)
		begin
			vb_qualify=a_data_stored
			xcall whgine_valid_trd_pri(inputinfo,
			&      whgine_vb, gold_com, gold_ax, a_fkeys, whgine_passed)
		end
	end
	freturn a_pending_status
.end

.function whgine_grp_change ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include "SRC:OPSCOM.REC"

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:VWREC.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		non_stk,                d1

.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER'))
		freturn a_pending_status

	a_pending_status = %vg_change(a_data_entered, a_data_stored, a_pending_status, inputinfo, whgine_vj)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT')
		freturn a_pending_status

	if a_data_stored
	begin
		xcall ibc_disable(inp_wndid,'vj_bc_cost')
		xcall ibc_disable(inp_wndid,'vj_fc_cost')
		if(wg_security.eq.ACC_DISP_AMEND)
		begin
			xcall whgine_get_group(a_data_stored,,,,, non_stk)
			if non_stk
			begin
				if(pass_gen_data.vi_currency .ne. cms_base_cur) then
					xcall ibc_enable(inp_wndid,'vj_bc_cost')
				else
					xcall ibc_enable(inp_wndid,'vj_fc_cost')
			end
		end
	end

	freturn D_OK

.end
.function whgine_vb_grp_change ,^val

	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'

	.include "SRC:OPSCOM.REC"


.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT' .or. g_entnam .eq. 'I_DRILL' .or.
	&       g_entnam.eq.'I_HYPER'))
		freturn a_pending_status

	a_pending_status = %vg_change(a_data_entered, a_data_stored, a_pending_status, inputinfo, whgine_vb)

	if a_pending_status .ne. D_OK .or.
	&       (g_entnam .eq. 'J_QUIT')
		freturn a_pending_status

	if(f_wg_mv_comm.and. a_data_stored)
	begin
		xcall whgine_get_group(a_data_stored, vb_grpdes,,,,,
		&   vb_book_wd_p, vb_est_rep_p, vb_est_warr_p)

		xcall i_dspfld(inp_wndid,'vb_book_wd_p',vb_book_wd_p)
		xcall i_dspfld(inp_wndid,'vb_est_rep_p',vb_est_rep_p)
		xcall i_dspfld(inp_wndid,'vb_est_warr_p',vb_est_warr_p)

		if(vb_rrp_bc)
		begin
			vb_e_repairs_bc=(vb_rrp_bc * VB_EST_REP_P)#4
			vb_e_warr_bc=(vb_rrp_bc * VB_EST_WARR_P)#4

			xcall whgine_calc_oa(gold_com, whgine_passed, whgine_vb)
			xcall whgine_disp_vb_curr_vals(gold_com, whgine_vb, whgine_passed)
		end
	end

	freturn D_OK

.end

.subroutine reset_attch_vals

	.include 'whgine_lst' repository, group = 'whgine_lst'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VDREC.REC'

	external function
		f_curr_fc,      d

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal


	record gen
		att_cost,       d10
		err,            d3
.proc
	lst_tot_cost = %f_curr_fc(lst_dsp_cost, pass_gen_data.vi_exch_rate)
	lst_tot_retail = lst_retail
	if .not. attach_ll
		xreturn

	; if this is a partial credit or a partial invoice but the current
	; main item is history, then ignore any associated attachments
	if(pass_gen_data.h_ivcr.eq.D_VIIVCR_PART_CRED.or.
	& (pass_gen_data.h_ivcr.eq.D_VIIVCR_PART_INV.and.
	& lst_vm_exists.eq.'H'.and.
	& pass_gen_data.h_status .lt. D_ADV_INVOICED))
		xreturn

	xcall ll_process(attach_ll, D_LL_FIRST, vdrec, err)
	while .not. err
	begin
		if cms_gnvcos .eq. D_WG_AUTO_COST_ADJ .and. .not. vd_fin_inv then
			att_cost = %max(vd_est_cos[D_BC], vd_cost[D_BC])
		else
			att_cost = vd_cost[D_BC]
		if pass_gen_data.vi_currency .ne. cms_base_cur
			att_cost = %f_curr_fc(att_cost, pass_gen_data.vi_exch_rate)
		if (! vd_vat_margin)
		begin
			lst_tot_cost += vdqty * att_cost
		end
		lst_tot_retail += vdqty * vd_rrp(D_FC)
		xcall ll_process(attach_ll, D_LL_NEXT, vdrec, err)
	end
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       This section evaluates whether or not the hide attachments
        ;       option is relevant and sets field accordingly
.subroutine evaluate_vb_hide_attach

	.include 'whgine_vb' repository, group = 'whgine_vb'
	.include 'whgine_passed' repository, group = 'whgine_passed'

	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	if vb_attach_num then
	begin
		if(pass_gen_data.adv_mode .ne. D_VEW_MODE) then
		begin
			if vb_hide_ln
				vb_hide_att = vb_hide_ln
			if vb_hide_ln then
				xcall ibc_disable(pass_gen_data.inp_vb_id, 'vb_hide_att')
			else
				xcall ibc_enable(pass_gen_data.inp_vb_id, 'vb_hide_att')
		end
		xcall i_dspfld(pass_gen_data.inp_vb_id, 'vb_hide_att', vb_hide_att)
	end
	else
		xcall ibc_disable(pass_gen_data.inp_vb_id, 'vb_hide_att')

	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       sets default settlement discount based on invoice type and
        ;       is default percentage discount
.subroutine set_settlement_default

	.include 'gold_com' repository, group = 'gold_com'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	a_wndid,        n
	.include 'whgine_passed' repository, group = 'whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VICOM.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		disc_val,       d10
.proc

	if(pass_chn_data.line_mode .ne. D_INS_MODE)
		xreturn       ; only in insert mode

	if(vi_crst.ne.D_IVT_CRST_SETTLE.or..not.vi_cr_chrg)
		xreturn       ; only if settlement flag and
                                                ; a discount percentage exists
	if(.not.vj_fc_sett)
	begin
		; special for MSF no settlement if outlet type Y.
		if(cms_user_id.eq.10060.and. pass_gen_data.no_sett) exit
		disc_val = vj_fc_rrp - vj_fc_disc
		vj_fc_sett = (disc_val * vi_cr_chrg) #4
		xcall i_dspfld(a_wndid, 'vj_fc_sett', vj_fc_sett, gold_com)
	end
	xcall whgine_disp_vj_curr_vals(gold_com, whgine_vj, a_wndid, whgine_passed, invoice_totals)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_cost_display, ^val, reentrant
	a_data_stored           ,n      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec,               a       ; Data rec
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'

	.include "SRC:OPSCOM.REC"

.proc
	if wg_security .eq. ACC_NO_COST_DISP then
		clear a_data_displayed
	else
		freturn %currency_na_display(a_data_stored, a_data_displayed, inputinfo,
		&     a_inprec, a_attributes, a_color, gold_com, gold_ax)

	freturn true
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_frmt_cost_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec,               a       ; Data rec
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display

	.include "SRC:OPSCOM.REC"

.proc
	if wg_security .eq. ACC_NO_COST_DISP
		clear a_data_displayed
	freturn true
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_pcnt_cost_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec,               a       ; Data rec
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'

	.include "SRC:OPSCOM.REC"

.proc
	if wg_security .eq. ACC_NO_COST_DISP then
		clear a_data_displayed
	else
		freturn %percent_display(a_data_stored, a_data_displayed, inputinfo, a_inprec, a_attributes, a_color)

	freturn true
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine view_bonuses
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_inv_tab' repository, group='whgine_inv_tab'
	group a_fkeys,  [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'vjrec' repository, group= 'vjrec'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
endparams
	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:NMFREC.REC'

	external function
		f_format_money,         a
		f_curr_fc,              d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

	record gen
		err,            d3
		return_bonus_difference, i8
	endrecord
	
	record ifours
		disp_nom_id,    i4
		tmp_bonus_old,  i8
		tmp_bonus_new,  i8
	endrecord
.proc
	clear gen, ^i(ifours)
	clear return_bonus_difference
	
	xcall file(pass_chn_data.chn(VM_FILE),vmrec ,whgine_vj.vj_tstk,'RD',err,,,,,D_NO_LOCK)
	if(err)
		xcall file(pass_chn_data.chn(HM_FILE),vmrec,whgine_vj.vj_tstk,'RD',err,,,,,D_NO_LOCK)
	if(err) clear vmrec
	
	xcall wg_bonus_calc(vmrec, tmp_bonus_old, pass_gen_data.vi_exch_rate)
	xcall wg_bonus_entry(whgine_vj.vj_tstk, pass_chn_data.chn(NMF_FILE),
	&       pass_chn_data.chn(VM_FILE),pass_chn_data.chn(HM_FILE), gold_com, gold_ax)

	xcall file(pass_chn_data.chn(VM_FILE),vmrec ,whgine_vj.vj_tstk,'RD',err,,,,,D_NO_LOCK)
	if(err)
		xcall file(pass_chn_data.chn(HM_FILE),vmrec,whgine_vj.vj_tstk,'RD',err,,,,,D_NO_LOCK)
	if(err) clear vmrec

	xcall wg_bonus_calc(vmrec, tmp_bonus_new, pass_gen_data.vi_exch_rate)

	if(tmp_bonus_old != tmp_bonus_new)
	begin
		data req,            i4

		return_bonus_difference=tmp_bonus_new-tmp_bonus_old

		whgine_vj.vj_fc_cost -= return_bonus_difference

		; Update the profit section in the header
		adv_tot_cost -= return_bonus_difference
		inv_prof_v = inv_val - adv_tot_cost
		inv_prof_p = (inv_prof_v * 10000) / inv_val
		xcall i_dspfld(inp_vi_id,'INV_PROF_V',INV_PROF_V, gold_com)
		xcall i_dspfld(inp_vi_id,'INV_PROF_P',INV_PROF_P, gold_com)

		xcall whgine_fill_list(gold_com, whgine_lst, vjrec, whgine_passed, invoice_totals)

		l_restart(whgine_passed.wgd_lst_id)
		l_restart(whgine_passed.seq_lst_id)

		xcall l_queue(seq_lst_id, D_LBOTTOM)
		xcall l_process(seq_lst_id, req = D_LTOP, whgine_lst,, gold_com, gold_ax,
		&           a_fkeys[SEQ_FKEYS], whgine_passed, invoice_totals)

		xcall l_queue(wgd_lst_id, D_LBOTTOM)

		xcall l_process(wgd_lst_id, req = D_LTOP, whgine_vj,, gold_com, gold_ax,
					&   a_fkeys[WGD_FKEYS], whgine_passed, a_fkeys, whgine_lst,
					&   whgine_inv_tab, whgine_hdr, add_part_passed, invoice_totals)

		if(pass_gen_data.vi_currency.ne.cms_base_cur)
		begin
			whgine_vj.vj_bc_cost = %f_curr_fc(whgine_vj.vj_fc_cost, pass_gen_data.vi_exch_rate)
		end
	end
	
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_sbtot_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	a_inprec                ,a      ; (Optional) record passed to I_INPUT.
                                        ;  Not passed if in I_INPFLD/I_DSPFLD.
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display

	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	; a_method_data         ,a      ; Optional method data argument

	.include "SRC:OPSCOM.REC"


	global data section whgine_gen_data
	record
		pass_gen_data,whgine_pass_gen_data_str
	endglobal

.proc
	; if displayed value is blank we can assume that blank if zero has been applied and return
	xcall whgine_cur_display(a_data_stored, a_data_displayed, a_inprec,
	&                        inputinfo, a_attributes, a_color, gold_com,
	&                        gold_ax)

	if ^d(a_data_stored) .and. pass_gen_data.h_vatreg then
	begin
		xcall i_dspfld(inp_wndid, 'vat_cust', '*')
		xcall i_dspfld(inp_wndid, 'vat_cust_legend',
		&              '* Vat will be applied')
	end
	else
	begin
		xcall i_dspfld(inp_wndid, 'vat_cust', ' ')
		xcall i_dspfld(inp_wndid, 'vat_cust_legend', ' ')
	end

	freturn TRUE
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_ivt_desc_change, ^val

	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	ivt_desc_chng,        n

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM3REC.REC'
	.include 'SRC:VMCOM.REC'
	.include 'SRC:VICOM.REC'

.proc
	a_pending_status = %capitalise_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr)

	if a_pending_status .eq. D_OK
	begin
		if a_data_stored .ne. vi_narr
			ivt_desc_chng = true
	end

	freturn a_pending_status
.end

.function whgine_vi_narr_change, ^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'

.proc
	a_pending_status = %capitalise_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_hdr, gold_com, gold_ax)
	xcall i_dspfld(inp_vi_id, 'vi_narr', a_data_stored)

	freturn a_pending_status
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section controls the printing of a deposit invoice
        ;       (or credit) if applicable.  An invoice may only be printed
        ;       if the deposit invoice field is not filled in (if it is then
        ;       the presumption is that it has already been invoiced).  If
        ;       invoiced (provided the wholegood invoice is itself not
        ;       completed) then he deposit may be credited.  Once the deposit
        ;       invoice has been prined, the screen details may not be amended.
.subroutine whgine_deposit_invoice
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	reprint_inv,    n       ; if reprint then no updating required
	main_wgd,       a
	.include 'whgine_hdr' repository, group='whgine_hdr'


	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:COMREC.REC'
	.include 'SRC:IVTCOM.REC'
	.include 'SRC:VICOM.REC'
	.include 'SRC:FCFREC.REC'
	.include 'SRC:CMFREC.REC'
	.include 'SRC:IDAREC.REC'

	.include 'SRC:CTFREC.REC'
	.include 'SRC:IHHREC.REC'
	.include 'SRC:HWREC.REC'
	.include 'SRC:NOMMSG.REC'

	.include 'DEF:DOCREC.DEF'

	.include 'vmrec' repository, record='vmrec'

	.define D_CTF_INVOICE,  1
	.define D_CTF_CREDIT,   2
	.define D_SOURCE_WIT,   3

	external function
		f_get_salcon,   a
		f_get_lp,       d
		f_curr_bc,      d
		f_ljust,        a
		f_alpha8_date,  a
		f_yes_no,       d

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record xrf
		xrf_items,      @ArrayList
		xrf_item,       drf_item

	record general
		.include 'SRC:IVPGRP.REC'
		.include 'doc_print' repository, group = 'doc_print'
		tmp_filename,           a14
		doc_subj,               a100

	.align
	record ids
		err,                    i4
		loop,                   i4
		loop2,                  i4
		ihh_chn,                i4
		ida_chn,                i4
		tx_sign,                i4      ; 1 or -1 for inv or credit
		credit,                 i4      ; 1=invoice, -1=credit
		prt_chn,                i4

.proc
	xcall e_enter

	clear general, ^i(ids)
	if(.not.CMS_WG_DEPOSIT)
	begin
		xcall ibc_message('The {WHOLEGD} Deposit Nominal Account'
		&   ' has not been set - Cannot Continue')
		err=true
	end
	if(.not.err)
		call open_files
	if(.not.err)
		call deposit_invoice_control

	xcall e_exit
	xreturn
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       opens any non wgds invoicing standard files
	open_files,
	tmp_filename=ihhfile
	tmp_filename(8:3)=cn,'XXX'
	xcall u_open(ihh_chn,'u:i',tmp_filename,,,err)
	if(err)
		xcall ibc_message('Open error no '+%string(err) +'on file '
		&                 +tmp_filename+' - Cannot Continue')

	if(err) return

	xcall file(g_com_chn,comrec,2,'RN',err,,,,,D_NO_LOCK)
	init doc_print

	dpr_form_type = DOC_FORM_INVOICE
	dpr_form_subtype = 'POS'
	dpr_doc_lic = DOC_TYP_CUSTOMER
	dpr_txt_type = ITX_FILE_INV
	dpr_80col = D_80COL
	dpr_invoices = D_INVOICE
	dpr_reprint = D_REPRINT
	dpr_single = D_YES

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       control printing of invoice or credit note.  Also deals
        ;       with reprinting by bypassing the update routines
	deposit_invoice_control,

	xcall file(pass_chn_data.chn(CMF_FILE), cusrec, vi_cust, 'RD', err)

	xcall file(g_fcf_chn,fcf_rec, cmf_cur_cod,'RD', err)

	if(.not.reprint_inv)
	begin
		if(vi_iorc) then
			credit=-1
		else
			credit=1
		if(fin_dep_inv_no) then
			tx_sign=-1
		else
			tx_sign=1
		call create_deposit_invoice
	end
	else
	begin
		ihh_cusac=cmf_acc_no
		ihh_ainvno=fin_dep_inv_no
		if (! fin_dep_inv_date)
			fin_dep_inv_date = %ndate
		else
			fin_dep_inv_date = %f_get_date(fin_dep_inv_date)
		ihh_invdate = fin_dep_inv_date

		xcall file(ihh_chn, ihhrec, ihh_key0, 'RD',err,,,,,Q_NO_LOCK)
		if(err)
		begin
			xcall ibc_message('Unable to find the deposit invoice details')
			return
		end
	end
	call print_deposit_invoice
	if(tx_sign.eq.-1)
	begin
		if(credit.eq.-1) then
			xcall ibc_message('NOTE - Invoice Number is '+fin_dep_inv_no)
		else
			xcall ibc_message('NOTE - Credit Note Number is '+fin_dep_inv_no)
		clear fin_dep_inv_no, fin_dep_inv_date
		clear fin_deposit_status
	end

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       Print Invoice
	print_deposit_invoice,

	; set data for prnt_inv external routine
	ivp_type = IVP_INV
	ivp_job_no =ihh_job_advice
	ivp_cust_no = ihh_cusac
	ivp_inv_no = ihh_ainvno
	ivp_inv_dat = ihh_invdate

	if( ihh_cur_cod.nes.fcf_code )
		xcall file( g_fcf_chn, fcf_rec, ihh_cur_cod, 'RD', err )

	dpr_inv_type = ihh_invtype
	dpr_depot = ihh_ainvno(1:1)
	dpr_reprint = D_REPRINT
	dpr_doc_ref = ihh_ainvno

	using ihh_rectype select
		(IHH_POS),      dpr_doc_form = 'Invoice'

		(IHH_POSCRED),  dpr_doc_form = 'Credit Note'

	endusing

	repeat
	begin
		prt_chn = %doc_print_start( gold_com, gold_ax, doc_print, cusrec )
		if(prt_chn) exitloop
		if(reprint_inv) return
		if(%f_yes_no('Deposit '+%atrim(dpr_doc_form)
		&   +' already posted - Quit Print?',,, true, false) .eq. D_YES)
			return
	end

	xrf_items = new ArrayList()
	if( cms_txt_inv )
		using ihh_rectype select

			(IHH_POS),      xcall disp( prt_chn,,'.',%char(8) )

			(IHH_POSCRED),  xcall disp( prt_chn, , ':', %char(8) )

		endusing

	if( dpr_send_type .eq. D_SEND_EMAIL .or. dpr_send_type .eq. D_SEND_EMAIL_POST )
		xcall s_bld(lp$fax_ftao, , '%a: %a %a %a for Account %a Ref %a', com_name,
		&     dpr_form_subtype, dpr_doc_form, ivp_inv_no, %f_ljust(ihh_cusac), cmf_acc_ref )

	xcall prnt_inv( ivp_hdr, ,ihh_rectype, err, prt_chn, ihh_lab_flag, ihh_crst, , , TRUE )

	xcall s_bld(doc_subj, , '%a %a %a %a', dpr_doc_type, %f_ljust(dpr_account),
	&       %f_alpha8_date(ivp_inv_dat), ivp_inv_no )

	xcall doc_print_end( prt_chn, doc_print, doc_subj, xrf_items )

	xcall doc_print_close( doc_print )

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       this section is called if this is a new invoice (or credit)
	create_deposit_invoice,

	repeat
	begin
		xcall dep_seq (dt, DEP_S_BILL,fin_dep_inv_no)
		; Double check it is not already used...
		xcall file(ihh_chn,ihhrec,fin_dep_inv_no,'RD',err,,,,,Q_NO_LOCK)
		if(err.eq.EOF_ERR.or.ihh_ainvno.ne.fin_dep_inv_no) exitloop
	end

	clear ihhrec
	if (! fin_dep_inv_date)
		fin_dep_inv_date = %ndate
	else
		fin_dep_inv_date = %f_get_date(fin_dep_inv_date)

	ihh_special_inv=TRUE

	ihh_cusac = cmf_acc_no
	ihh_invdate = fin_dep_inv_date
	ihh_ainvno = fin_dep_inv_no

	ihh_invtype = ivt_type
	ihh_invdesc(1)='DEPOSIT ADV '+vi_job
	ihh_invdesc(2)=vi_narr

	ihh_slman = vi_rep
	ihh_job_advice = vi_job

	if(credit*tx_sign.lt.0) then
		ihh_rectype = IHH_POSCRED
	else
		ihh_rectype = IHH_POS

	ihh_f_labtotal = 0
	ihh_set_chrg = 0
	ihh_tot_cost = 0

	ihh_cus_ord = vi_cord

	ihh_cre_date = %ndate
	ihh_contact = cmf_acc_nam
	ihh_prog_code = ivt_prog_code

	ihh_rinvdate = 0 - ihh_invdate

	if (cmf_vat) then
		xcall f_vat_rate( cms_uk_def_vat, ihh_lab_vt_rat )
	else
		xcall f_vat_rate( cms_uk_zero_vat, ihh_lab_vt_rat )

	ihh_inv_reqd = TRUE

	ihh_accum_inv = FALSE
	ihh_hort_job = FALSE

	ihh_vatno = cmf_vat_no
	ihh_cur_cod = cmf_cur_cod
	ihh_cur_cnv = fcf_std_rate
	ihh_who_inv = user_init
	ihh_orig_idate = 0

	ihh_f_sal_value = fin_deposit_amt

	ihh_f_tot_vat = fin_deposit_vat

	xcall file(ihh_chn, ihhrec, ihh_key0, 'ST', err )
	; note that the vat value is deliberately sign only after storing record.
	; this is because other places the value is used is signed whereas on ihh
	; the rules are different (for some reason)
	ihh_f_sal_value = fin_deposit_amt * tx_sign * credit
	ihh_f_tot_vat = ihh_f_tot_vat * tx_sign * credit

	if(vi_deladd[])
	begin

		tmp_filename=idfile
		tmp_filename(8:3)=cn,'XXX'
		xcall u_open(ida_chn,'u:i',tmp_filename,,,err)
		if(err)
			xcall ibc_message('Open error no '+%string(err) +'on file '
			& +tmp_filename+'\n Cannot Store Delivery Address Data on deposit invoice')
		if(err) exit

		clear dadrec

		ida_type = ID_POS_DELIV
		ida_ainv_no=ihh_ainvno
		ida_job_no=ihh_job_advice
		for loop from 1 thru 4
			ida_deladd(loop)=vi_deladd(loop)
		ida_del_pcod=vi_deladd(5)
		xcall file(ida_chn, dadrec, ida_key, 'ST', err )
	end

	clear loop2

	; find highest line number
	for loop from 1 thru 10
		if(fin_deposit_desc(loop)) loop2=loop

	;section to create new scratchpad from finance details
	if(loop2)
	begin
		data lString,	string
		data lLoop,		i4
		data lNewLine,	a2,	char(13)+char(10)
		lString=""
		for lLoop from 1 thru loop2
			lString = lString + fin_deposit_desc(lLoop) + lNewLine
		xcall ScratchPadCreate(CMNT_POS,vi_job+ihh_ainvno+'001',lString)
	end

	call update_ctf_tran
	call update_cust_with_deposit

	if(main_wgd)
		call create_washout_record

	call post_nominals
	fin_deposit_status=1
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       "Post" to Customer
	update_cust_with_deposit,
	if(ctf_cust_acc.ne.cmf_acc_no)  ; statement or invoice a/c applicable
		xcall file (pass_chn_data.chn(CMF_FILE),cusrec,cmf_acc_no,'RD',err)

	cmf_f_age(1) = cmf_f_age(1) + ctf_tran_val[D_FC]
	if(ctf_orig_acc)                ; statement or invoice a/c
	begin
		xcall file(pass_chn_data.chn(CMF_FILE),cusrec,,'WR',err)

		cmf_acc_no=ctf_orig_acc    ; restore back to
		xcall file (pass_chn_data.chn(CMF_FILE),cusrec,cmf_acc_no,'RD',err)
	end

	cmf_sal_td = cmf_sal_td +
	&               ((ctf_tran_val(D_BC)+ctf_vat_val(D_BC))#fcf_dp)

	; NOT SURE OF THE BEST ONE TO UPDATE IF ANY WSJ, POS, WIT, VEH
	cmf_sal_wsj.sales = cmf_sal_wsj.sales +
	&               + ctf_tran_val(D_BC) + ctf_vat_val(D_BC)

	cmf_sal_wsj.cost = cmf_sal_wsj.cost +
	&               + ctf_tran_val(D_BC) + ctf_vat_val(D_BC)

	; NOTE THAT THIS WAS COMMENTED OUT IN THE IBCOS WCCSIN ROUTINE

	xcall file(pass_chn_data.chn(CMF_FILE),cusrec,,'WR',err)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Update Customer Transaction File
	update_ctf_tran,

	clear ctfrec

	; sets ctf_cus_acc & ctf_orig_acc
	xcall CSDP_set_ctf_account(cmf_acc_no, cusrec, ctfrec)

	if (cmf_vat) then
		ctf_vat_code = cms_uk_def_vat
	else
	begin
		if cmf_def_vat then
			ctf_vat_code = cmf_def_vat
		else
			ctf_vat_code = cms_uk_zero_vat
	end

	ctf_tran_dat = ihh_invdate
	ctf_doc_ref = ihh_ainvno

	if(ihh_rectype .eq. IHH_POSCRED) then
		ctf_post_type = D_CTF_CREDIT
	else
		ctf_post_type = D_CTF_INVOICE

	ctf_cur_cod = cmf_cur_cod
	ctf_set_dat = ihh_set_date
	ctf_sys_dat = %ndate
	ctf_desc = ihh_invdesc(1)
	ctf_ref_no=ihh_cus_ord
	ctf_batch = 9996
	ctf_cur_tran = (cmf_cur_cod .NE. cms_base_cur)
	set ctf_tran_val(D_FC),ctf_bal_out(D_FC)=
	&               (ihh_f_sal_value + ihh_f_tot_vat)

	set ctf_tran_val(D_BC),ctf_bal_out(D_BC)=
	&                       %f_curr_bc(ctf_tran_val(D_FC),fcf_std_rate)

	ctf_vat_val(D_FC) = ihh_f_tot_vat * -1
	ctf_vat_val(D_BC) = %f_curr_bc(ctf_vat_val(D_FC),fcf_std_rate)

	ctf_source=D_SOURCE_WIT
	ctf_inv_typ=ihh_invtype

	xcall file( pass_chn_data.chn( CTF_FILE ), ctfrec, ctf_key, 'ST', err )

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;
	create_washout_record,
	xcall file(pass_chn_data.chn(VM_FILE), vmrec, main_wgd,'RD',err,,,,,Q_NO_LOCK)
	if(err)
		xcall file(pass_chn_data.chn(HM_FILE), vmrec, main_wgd,'RD',err,,,,,Q_NO_LOCK)
	if(err) return

	clear hwrec
	hworig=vmwstk
	hwstk1=vmstok
	hwttyp=HW_SALE
	hwmodl=ihh_invdesc(1)
	hwdate=ctf_tran_dat

	hwrep=virep
	hwjob=vijob
	hwivno=ctf_doc_ref
	hwcust=ctf_cust_acc
	hw_sold[D_FC]=ctf_tran_val[D_FC]+ctf_vat_val[D_FC]
	hw_sold[D_BC]=ctf_tran_val[D_BC]+ctf_vat_val[D_BC]

	hw_cost[D_FC]=
	hw_cost[D_BC]=

	hwint=user_init
	hwlcsf=FALSE

	hwprt=FALSE

	hw_att_stk=

	if(vm_trade_in) hwfather=vm_trade_in
	if(ctf_post_type.eq.D_CTF_INVOICE) then
	begin
		hw_res_type=0
		hwiorc='I'
	end
	else
	begin
		hw_res_type=1
		hwiorc='C'
	end
	hw_depot=vi_depot

	hwbonp=
	hw_comm_stat=false
	hw_res_vat=
	hw_pur_cur=
	hw_sell_cur=ctf_cur_cod
	hw_non_stock=false
	hw_oa_reverse=false
	hw_split_cost=false
	xcall file(pass_chn_data.chn(HW_FILE), hwrec,, 'ST', err)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	post_nominals,

	clear pstrec
	pst_prt = 'IN'
	pst_type = D_POST_SAL
	pst_ref = ctf_doc_ref
	pst_date = ctf_tran_dat
	pst_rcom = cn
	pst_desc = ctf_desc

	; Update sales Control
	pst_account = %f_get_salcon(cusrec,,dt)
	pst_val = ctf_tran_val(D_FC)
	pst_b_val = ctf_tran_val(D_BC)
	pst_cur_cod=ctf_cur_cod
	call post_nominal

	; Update Vat Control
	pst_account= cms_salvat
	pst_val = ctf_vat_val(D_BC)
	pst_b_val = ctf_vat_val(D_BC)
	pst_cur_cod=cms_base_cur
	call post_nominal

	; Update deposit a/c
	pst_account = cms_wg_deposit
	if(pst_account(7,7) .eq. '*')                                ; WG7424
		pst_account(7,7) = dt                                      ; WG7424
	pst_val = (ctf_tran_val(D_BC) *-1)  - ctf_vat_val(D_BC)
	pst_b_val = pst_val
	pst_cur_cod=cms_base_cur
	call post_nominal
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       post this nominal transaction
	post_nominal,
	if(.not.pst_val) return

	if(.not.pst_account) pst_account=cms_postdmp

	if(.not.pst_cur_cod) pst_cur_cod=cms_base_cur
	if( pst_cur_cod .ne. cms_base_cur ) then
		pst_foreign = 2
	else
		clear pst_foreign
	xcall post_nom( pstrec )
	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_check_sb_int_jobs
	yes_no_ans,     n
	pass_stok,      a

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:IVTREC.REC'
	.include 'SRC:VSREC.REC'
	.include 'SRC:IHHREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal

	record general
		tmp_val,        d10
		err,            d4


.proc

	clear tmp_val
	yes_no_ans=TRUE

	clear vsstok
	vs_typ_ser=0
	vsstk = pass_stok
	vssdat = 99999999
	xcall file(pass_chn_data.chn(VS_FILE),vsrec,vsstok,'FI',err)
	repeat
	begin
		xcall file(pass_chn_data.chn(VS_FILE),vsrec,,'RS',err)
		if (err .OR. vsstk .NE. pass_stok.or.vs_typ_ser)
			exitloop

		xcall file(pass_chn_data.chn(IVT_FILE),ivtrec,vstype,'RD',err)
		if(err)
			clear ivtrec
		; ap20121025 - log no 622099 bourne tractors. The customer had changed the
		; program code assocated with invoice type 29 a number of time and this
		; caused problems with the display.  Rather than using the current setting of
		; program code, try and use ihh_prog_code which would have been setat the time of
		; raising the invoice.
		ihhk1_invno = vsivno
		ihhk1_invdate = vssdat
		if(.not.%xf_file(pass_chn_data.chn(IHH_FILE),ihhrec,ihh_key1,'RD',1).and.ihh_prog_code)
			ivt_prog_code=ihh_prog_code

		if(ivt_prog_code.ne.P_COD_INT_VAL) nextloop

		tmp_val += (vs_pval + vs_lval)

	end

	if(tmp_val)
	begin
		xcall yes_no('Internal Jobs affecting cost for <WGD> '+pass_stok+' - Continue?',yes_no_ans,10)
	end

	xreturn

.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_spec, ^val
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_stk_no,       a               ; stock no
	a_wgtype,       n               ; type (live or hist) [optional - default live]
	a_row,          n               ; row [optional]
	a_col,          n               ; col [optional]
	a_view,         n               ; view only [optional]
	a_not_exists,   n               ; already exists [optional] default false

	; returns ret_val - 0 (D_NO_ERROR) if successful, -1 (D_USER_ABORT) on cancel
	;                  or error_no if error occurs


	.define SYN_TK
	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'

	.define D_LIVE,         0
	.define D_HIST,         1

	external function
		f_yes_no,       d

	record gen
		filename,       a D_FILENAME_LEN
		ret_val,        d3
		search,         d1
		.include 'fkeys' repository, group = 'spc_fkeys'
		.include 'vmrec' repository, group = 'Vm_bak', nofields
		wgtype,         d1
		view,           d1
		chr,            a1
		not_exists,     d1

	record ifours
		chn,            i4
		spc_id,         i4

.proc
	clear gen, ^i(ifours)

	if %passed(a_wgtype) then
		wgtype = a_wgtype
	else
		wgtype = D_LIVE

	if %passed(a_view) then
		view = a_view
	else
		view = false

	if %passed(a_not_exists) then
		not_exists = a_not_exists
	else
		not_exists = false


	call setup

	if .not. ret_val
		call process_spec

	freturn ret_val

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	setup,
	call open_files

	if ret_val
		return

	call set_up_fkeys

	call load_windows

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	open_files,
	if (wgtype .eq. D_HIST) then
	begin
		filename = hmfile
		filename(7:3) = gold_com.cur_company,'XXX'
		xcall u_fndfil(filename, 'U:I', chn)
		if (.not. chn)
			xcall u_open(chn, 'U:I', filename,,, ret_val)
	end
	else
	begin
		filename = vmfile
		filename(7:3) = gold_com.cur_company,'XXX'
		xcall u_fndfil(filename, 'U:I', chn)
		if (.not. chn)
			xcall u_open(chn, 'U:I', filename,,, ret_val)
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_fkeys,
	clear spc_fkeys, spc_fkeys.fkmnu_id
	if .not. view
	begin
		spc_fkeys.fkey[ D_FK_NO2 ] = T$FK_SKIP
		spc_fkeys.fkey[ D_FK_NO3 ] = T$FK_CANC

		.ifdef D_GUI
			spc_fkeys.fkey[D_FK_NO4] = T$FK_AMD
		.else
			begin
				spc_fkeys.fkey[ D_FK_NO5 ] = T$FK_PRIV
				spc_fkeys.fkey[ D_FK_NO6 ] = T$FK_DL_LINE
			end
		.endc
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_windows,
	xcall ibc_ldinp(spc_id,g_utlib,'whgine_spc', D_CENTER_WND, search,,,, spc_fkeys)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	process_spec,
	xcall file(chn, vmrec, a_stk_no, 'RD', ret_val)
	if ret_val
	begin
		clear vmrec, ret_val
		vmstok = a_stk_no
	end

	xcall i_display(spc_id,'dsp_set',vmrec)

	if %passed(a_row)
		xcall ibc_window(D_PLACE, spc_id, a_row, a_col)

	if view then
	begin
		xcall i_frames(spc_id)
		xcall ibc_chr(chr, spc_id,,,,, spc_fkeys)  ;Get a keystroke
	end
	else
	begin
		xcall i_next(spc_id, 'inp_set', 'vmspec')
		.ifdef D_GUI
			if( vmspec .or. vmspiv ) then
				xcall i_readonly( D_SET, spc_id, 'inp_set' )
			else
				xcall i_readonly( D_OFF, D_SET, spc_id, 'inp_set' )
		.endc
		g_txt_rtrn = TRUE
		repeat
		begin
			xcall ibc_input(spc_id, 'inp_set', vmrec, gold_com.inp_col_id,,gold_edit_id,
			&               D_NOTERM,, spc_fkeys)

			if( g_select .and. g_entnam.eq.'J_AMD' )
			begin
				Vm_bak = vmrec
				xcall i_readonly( D_OFF, D_SET, spc_id, 'inp_set' )
				xcall ibc_input(spc_id, 'inp_set', vmrec,
				&	      gold_com.inp_col_id, gold_com.sel_col_id,gold_com.edt_col_id,
				&	      D_NOTERM,,spc_fkeys )
				if( g_select .and. g_entnam.eq.'J_QUIT' )
				begin
					vmrec = Vm_bak
					xcall i_display( spc_id, 'inp_set', vmrec )
				end
				xcall i_readonly( D_SET, spc_id, 'inp_set' )
				nextloop
			end

			if( g_select .and. g_entnam.eq.'J_PRIV' ) then
			begin
				if( spc_fkeys.fkey[ D_FK_NO5 ].fk_disp .eq. 'GenSpec' ) then
				begin
					xcall i_next(spc_id,'*CURR*','vmspec')
					spc_fkeys.fkey[ D_FK_NO5 ].btn_disp = 'PrvSpec'
				end
				else
				begin
					xcall i_next(spc_id,'*CURR*','vmspiv')
					spc_fkeys.fkey[ D_FK_NO5 ].btn_disp = 'GenSpec'
				end
				spc_fkeys.fkey[ D_FK_NO5 ].btn_txt_chngd = TRUE
			end
			else
				exitloop
		end
	end

	.ifndef D_GUI
		g_txt_rtrn = FALSE
	.endc
	if (view .or. g_select .and. g_entnam .eq. 'J_QUIT') then
	begin
		ret_val = D_USER_ABORT
	end
	else
	begin
		if (%f_yes_no('OK To Update?') .eq. D_YES)
		begin
			if not_exists then
				xcall file(chn, vmrec, vmstok, 'ST', ret_val)
			else
				xcall file(chn, vmrec, vmstok, 'WR', ret_val)
			xcall file(chn, vmrec, vmstok, 'RD', ret_val)
		end
	end

	xcall ibc_window(D_REMOVE, spc_id)

	return

.end

.function whgine_att_spec, ^val

	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_stk_no,       a               ; stock no
	a_row,          n               ; row [optional]
	a_col,          n               ; col [optional]
	a_view,         n

	; returns ret_val - 0 (D_NO_ERROR) if successful, -1 (D_USER_ABORT) on cancel
	;                  or error_no if error occurs


	.define SUB_RTN
	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_yes_no,       d

	record gen
		filename,       a D_FILENAME_LEN
		ret_val,        d3
		search,         d1
		.include 'fkeys' repository, group = 'spc_fkeys'
		chr,            a1
		view,           d1

	record ifours
		chn,            i4
		spc_id,         i4

.proc
	clear gen, ^i(ifours)

	if %passed(a_view) then
		view = a_view
	else
		view = false

	call setup

	if .not. ret_val
		call process_spec

	freturn ret_val

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	setup,
	call open_files

	if ret_val
		return

	call set_up_fkeys

	call load_windows

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	open_files,
	filename = vdfile
	filename(7:3) = gold_com.cur_company,'XXX'
	xcall u_fndfil(filename, 'U:I', chn)
	if (.not. chn)
		xcall u_open(chn, 'U:I', filename,,, ret_val)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_fkeys,
	clear spc_fkeys, spc_fkeys.fkmnu_id
	if .not. view
	begin
		spc_fkeys.fkey[D_FK_NO2] = T$FK_SKIP
		spc_fkeys.fkey[D_FK_NO3] = T$FK_FIRST
		spc_fkeys.fkey[D_FK_NO4] = T$FK_CANC
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_windows,
	xcall ibc_ldinp(spc_id,g_utlib,'whgine_att_spec', D_CENTER_WND,
	&               search,,,, spc_fkeys)

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	process_spec,
	xcall file(chn, vdrec, a_stk_no, 'RD', ret_val)
	if ret_val
		clear vdrec, ret_val

	xcall i_display(spc_id, 'disp_set', vdrec)

	if %passed(a_row)
		xcall ibc_window(D_PLACE, spc_id, a_row, a_col)

	xcall i_frames(spc_id)

	xcall i_next(spc_id, 'inp_set', 'vdmodl')
	if view then
	begin
		xcall e_state( D_OFF, D_ECHO, D_CURSOR )
		xcall ibc_chr(chr, spc_id,,,,, spc_fkeys)  ;Get a keystroke
                ; reinstate cursor and echo
		xcall e_state( D_ON, D_ECHO, D_CURSOR )
	end
	else
	begin
		xcall ibc_input(spc_id, 'inp_set', vdrec, gold_com.inp_col_id, ,,
		&           D_NOTERM,, spc_fkeys)
	end

	if (view .or. g_select .and. g_entnam .eq. 'J_QUIT') then
	begin
		ret_val = D_USER_ABORT
	end
	else
	begin
		if (%f_yes_no('OK To Update?') .eq. D_YES)
		begin
			xcall file(chn, vdrec, vdstok, 'WR', ret_val)
			xcall file(chn, vdrec, vdstok, 'RD', ret_val)
		end
	end

	xcall ibc_window(D_REMOVE, spc_id)

	return

.end

.function whgine_nstk_spec, ^val

	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	a_row,          n               ; row [optional]
	a_col,          n               ; col [optional]
	a_view,         n
	pass_plan_maint,n               ; optional - if passed then will change prompt
        ; returns ret_val - 0 (D_NO_ERROR) if successful, -1 (D_USER_ABORT) on cancel
        ;                  or error_no if error occurs


	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VMCOM.REC'

	external function
		f_yes_no,       d

	record gen
		.include 'whgine_vj' repository, group = 'orig_whgine_vj', nofields
		ret_val,        d3
		search,         d1
		.include 'fkeys' repository, group = 'spc_fkeys'
		view,           d1
		chr,            a1

	record ifours
		spc_id,         i4

.proc
	clear gen, ^i(ifours)

	if %passed(a_view) then
		view = a_view
	else
		view = false

	call setup

	if .not. ret_val
		call process_spec

	freturn ret_val

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	setup,
	call set_up_fkeys

	call load_windows

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_fkeys,
	clear spc_fkeys, spc_fkeys.fkmnu_id
	if .not. view
	begin
		spc_fkeys.fkey[D_FK_NO2] = T$FK_SKIP
		spc_fkeys.fkey[D_FK_NO3] = T$FK_FIRST
		spc_fkeys.fkey[D_FK_NO4] = T$FK_CANC
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_windows,
	xcall ibc_ldinp(spc_id,g_utlib,'whgine_nstk_spc', D_CENTER_WND,
	&               search,,,, spc_fkeys)
	if(%passed(pass_plan_maint).and.pass_plan_maint)
	begin
		xcall wnd_title(' PM Equip Line Specification ', spc_id)

		xcall i_prompt(spc_id, 'vj_tstk','Ref No:')
	end
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	process_spec,
	orig_whgine_vj = whgine_vj
	xcall i_display(spc_id, 'disp_set', whgine_vj)

	if %passed(a_row)
		xcall ibc_window(D_PLACE, spc_id, a_row, a_col)

	xcall i_frames(spc_id)

	xcall i_next(spc_id, 'inp_set', 'vj_spec')

	if view then
	begin
		xcall e_state( D_OFF, D_ECHO, D_CURSOR )
		xcall ibc_chr(chr, spc_id,,,,, spc_fkeys)  ;Get a keystroke
        ; reinstate cursor and echo
		xcall e_state( D_ON, D_ECHO, D_CURSOR )
	end
	else
	begin
		xcall ibc_input(spc_id, 'inp_set', whgine_vj, gold_com.inp_col_id, ,,
		&           D_NOTERM,, spc_fkeys)
	end

	if (view .or. g_select .and. g_entnam .eq. 'J_QUIT') then
	begin
		whgine_vj = orig_whgine_vj
		ret_val = D_USER_ABORT
	end
	else
	begin
		if(whgine_vj .ne. orig_whgine_vj.and.
		&  %f_yes_no('OK To Update?') .ne. D_YES)
		begin
			whgine_vj = orig_whgine_vj
		end
	end

	xcall ibc_window(D_REMOVE, spc_id)

	return

.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ROUTINE TO ALLOW ENTRY OF BASIC PLANNED MAINTENANCE CONTRACT DATA.
; IMPORTANT TO NOTE THAT THIS IS NOT RELATED TO THE WHGINE_PM_CLOCK_ENTRY
; WHICH IS ONLY APPLICABLE WHEN DEALING WITH BILLING AN EXISTING PLANNED
; MAINTENANCE INVOICE CONTRACT.
;
; WHGINE_PM_CONTRACT_ENTRY IS ONLY AVAILABLE FOR WHOLEGOOD LINES ON A
; NORMAL WGD INVOICE OR CREDIT.  THE IDEA IS TO SET UP BASIC CONTRACT
; DATA AT THE TIME OF SELLING THE WHOLEGOOD.
.function whgine_pm_contract_entry, ^val
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	a_view,         n		; 0 =no,1=yes, 2=D_CRT_PM_PROC
					; ie. offer function to sawp out to
					; plan maint contract entry

	.include 'whgine_passed' repository, group='whgine_passed'
	endparams

	.include 'DEF:PMCHECK.DEF'
	.define D_CRT_PM_PROC,  2       ; when view mode flag for pm contract
								; entry is set, allow user function to
								; swap out to contract

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM5REC.REC'
	.include 'SRC:PMHREC.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	external function
		pm_get_pmh_cont_ref,	a
		f_yes_no,       d
	endexternal

	record gen
		.include 'vwrec' repository, group = 'lVWRec'
		.include 'varec' repository, group = 'varec'
		.include 'vdrec' repository, group = 'vdrec'
		.include 'vmrec' repository, group = 'vmrec'
		.include 'cmfrec' repository, group = 'cmfrec'
		.include 'pmmrec' repository, group = 'pmmrec'
		.include 'pmlrec' repository, group = 'pmlrec'
		.include 'pmdrec' repository, group = 'pmdrec'
		.include 'pmdrec' repository, group = 'tpmdrec'
		.include 'whgine_vj' repository, group = 'orig_whgine_vj', nofields
		ret_val,        d3
		search,         d1
		.include 'fkeys' repository, group = 'contract_fkeys'
		view,           d1
		chr,            a1
		tmp_date,	 d8
		lServiceSequence,	d4
		pm_cont_id,     i4
		err,            i4
		loop,		i4
	endrecord
.proc
	init gen
	xcall e_enter

	if %passed(a_view) then
		view = a_view
	else
		view = false

	call setup
	call input_contract
	xcall e_exit

	freturn ret_val

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	setup,
	call set_up_fkeys
	call load_windows
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_fkeys,
	clear contract_fkeys, contract_fkeys.fkmnu_id
	if(view.ne.true .and. pass_gen_data.h_status .lt. D_ADV_INVOICED)
	begin
		contract_fkeys.fkey[D_FK_NO2] = T$FK_SKIP
		contract_fkeys.fkey[D_FK_NO3] = T$FK_FIRST
		contract_fkeys.fkey[D_FK_NO4] = T$FK_CANC
	end
	if(view.eq.D_CRT_PM_PROC)
		contract_fkeys.fkey[D_FK_NO7] = P$FK_CON_CRT

	if( pass_gen_data.h_status .ge. D_ADV_INVOICED.and.
	&	whgine_vj.vj_inp_pm_group.wg_pm_contract ) then
	begin
		contract_fkeys.fkey[D_FK_NO6]= T$FK_PMCNT
		contract_fkeys.fkey[D_FK_NO6].disabled_flg=false
	end
	else
		contract_fkeys.fkey[D_FK_NO6].disabled_flg=true

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_windows,
	xcall ibc_ldinp(pm_cont_id,g_utlib,'whgine_pm_cont', D_CENTER_WND,
	&               search,,,, contract_fkeys)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	input_contract,
	; treat this field as a flag to indicate that the details held are
	; from an existing contract
	if(view.eq.true.or.(whgine_vj.vj_inp_pm_group.wg_pm_contract.and.
	&  whgine_vj.vj_inp_pm_group.wg_pm_idle_time.eq.999999999)) then
	begin
		call set_existing_contract_fields
		if(err) return
	end
	else
	begin
		call set_default_entry_fields
	end

	clear orig_whgine_vj
	call display_contract_screen
	orig_whgine_vj = whgine_vj

	if view.eq.true then
	begin
		xcall e_state( D_OFF, D_ECHO, D_CURSOR )
		xcall ibc_chr(chr, pm_cont_id,,,,, contract_fkeys)  ;Get a keystroke
		if(g_select.and. g_entnam .eq. 'J_PM_CONT')
			call contract_enquiry
		; reinstate cursor and echo
		xcall e_state( D_ON, D_ECHO, D_CURSOR )
	end
	else
	begin
		repeat
		begin
			xcall i_next(pm_cont_id, 'inp_set', 'WG_PM_MODEL')
			xcall ibc_input(pm_cont_id, 'inp_set', whgine_vj, gold_com.inp_col_id, ,,
			&          D_NOTERM,, contract_fkeys, gold_com, gold_ax, whgine_passed, pass_chn_data.chn(PMM_FILE))
			if(g_select) then
			begin
				if(g_entnam .eq. 'J_CON_CRT')
				begin
					if %whgine_check_pm_details(whgine_vj.vj_tstk, true, whgine_vj.vj_inp_pm_group,true)
						nextloop
				end
				exitloop
			end
			else
			begin
				if(view.eq.D_CRT_PM_PROC)
				begin
					if %whgine_check_pm_details(whgine_vj.vj_tstk, true, whgine_vj.vj_inp_pm_group,true)
						nextloop
				end
				if(.not.g_setsts) exitloop
			end
		end
	end
	if (view.eq.true .or. g_select .and. g_entnam .eq. 'J_QUIT') then
	begin
		if(view.eq.D_CRT_PM_PROC)
		begin
			tmp_date=whgine_vj.wg_pm_chg_date_to
			; exits checking if end date set
			if(whgine_vj.wg_pm_chg_date_to)
				clear whgine_vj.wg_pm_chg_date_to
			err = %whgine_check_pm_details(whgine_vj.vj_tstk, true,whgine_vj.vj_inp_pm_group,true)
			whgine_vj.wg_pm_chg_date_to = tmp_date
			if(err) goto input_contract
		end
		whgine_vj = orig_whgine_vj
		ret_val = D_USER_ABORT
	end
	else if(whgine_vj .ne. orig_whgine_vj.or.view.eq.D_CRT_PM_PROC)
	begin
		call display_contract_screen
		if(view.eq.D_CRT_PM_PROC) then
		begin
			ret_val=true
			if(whgine_vj.wg_pm_contract) then
				ret_val = %f_yes_no('Contract '+whgine_vj.wg_pm_contract+ ' for {W} '
				&	+whgine_vj.vj_tstk+' already set - Update?', 20)
			else
				ret_val = %f_yes_no('OK to Create Contract for {W} '+whgine_vj.vj_tstk+'?', 20)
			if(ret_val.ne.true)
			begin
				whgine_vj = orig_whgine_vj
				ret_val = D_USER_ABORT
			end
			else
				call create_pm_contract
		end
		else if(%f_yes_no('OK To Update?', 20) .ne. D_YES)
			whgine_vj = orig_whgine_vj
	end
	xcall ibc_window(D_REMOVE, pm_cont_id)

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_existing_contract_fields,
	call read_contract
	if(err) then
	begin
		if(.not.view)
			xcall ibc_message('Error reading contract '
			&	+whgine_vj.vj_inp_pm_group.wg_pm_contract
			&	+' - this entry will be cleared')
		clear whgine_vj.vj_inp_pm_group
		return
	end
	else
	begin
		wg_pm_equip_no = pmlrec.pml_equip_no
		wg_pm_model = pmlrec.pmm_model
		wg_pm_charge_code = pmlrec.pmm_charge_code
		wg_pm_contract_charge = pmlrec.pmm_contract_charge
		wg_pm_curr_clock = pmlrec.pml_shift_pattern * 12
		wg_pm_chg_date_fr = pmlrec.pml_sal_date_fr
		wg_pm_chg_date_to = pmlrec.pml_sal_date_to
		wg_pm_contact_name = pmhrec.pmh_contact_nam
		wg_pm_contact_tel = pmhrec.pmh_contact_tel
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_default_entry_fields,
	if(.not.whgine_vj.wg_pm_equip_no)
		whgine_vj.wg_pm_equip_no = whgine_vj.vj_tstk

	if(.not.whgine_vj.vj_inp_pm_group.wg_pm_model)
	begin
		data lFileIOError,	int
		xcall file(pass_chn_data.chn(VW_FILE),lVWRec,whgine_vj.vj_code,'RE',lFileIOError)
		if lFileIOError || !lVWRec.vw_pm_model
			whgine_vj.vj_inp_pm_group.wg_pm_model = whgine_vj.vj_code
		else
			whgine_vj.vj_inp_pm_group.wg_pm_model = lVWRec.vw_pm_model
	end

	if(.not.whgine_vj.vj_inp_pm_group.wg_pm_model)
	begin
		data lFileIOError,	int
		xcall file(pass_chn_data.chn(VW_FILE),lVWRec,whgine_vj.vj_model,'RE',lFileIOError)
		if lFileIOError || !lVWRec.vw_pm_model
			whgine_vj.vj_inp_pm_group.wg_pm_model = whgine_vj.vj_model
		else
			whgine_vj.vj_inp_pm_group.wg_pm_model = lVWRec.vw_pm_model
	end

	xcall whgine_set_pm_chrg_default(pm_cont_id,whgine_vj,pmmrec,gold_com,gold_ax,
	&	pass_chn_data.chn(PMM_FILE))

	if(.not.whgine_vj.vj_inp_pm_group.wg_pm_charge_code)
		whgine_vj.vj_inp_pm_group.wg_pm_charge_code = pmmrec.pmm_charge_code

	if(.not.whgine_vj.vj_inp_pm_group.wg_pm_contract_charge)
		whgine_vj.vj_inp_pm_group.wg_pm_contract_charge = pmmrec.pmm_contract_charge

	begin
		data lFileIOError,	int
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,whgine_vj.wg_pm_equip_no,'FI',lFileIOError,1)
		repeat
		begin
			xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',lFileIOError,,,,,Q_NO_LOCK)
			if(lFileIOError.or.vdrec.vdstok.ne.whgine_vj.wg_pm_equip_no) exitloop

			if(!vd_rrp[D_BC]) nextloop

			xcall file(pass_chn_data.chn(VA_FILE), varec, vdrec.vdcode, 'RD', lFileIOError)
			if(lFileIOError) nextloop

			if(varec.vadopt != 2) nextloop

			whgine_vj.vj_inp_pm_group.wg_pm_contract_charge = vd_rrp[D_BC]

			exitloop
		end
	end

	xcall file(pass_chn_data.chn(cmf_file), cmfrec, whgine_hdr.vi_cust, 'RD', err,,,,,D_NO_LOCK)
	if(err) clear cmfrec
	if((.not.whgine_vj.vj_inp_pm_group.wg_pm_contact_name.or.
	&  .not.whgine_vj.vj_inp_pm_group.wg_pm_contact_tel).and.
	&	whgine_hdr.vi_cust)
	begin
		if(.not.whgine_vj.vj_inp_pm_group.wg_pm_contact_name)
			whgine_vj.vj_inp_pm_group.wg_pm_contact_name = cmfrec.cmf_acc_nam
		if(.not.whgine_vj.vj_inp_pm_group.wg_pm_contact_tel)
			whgine_vj.vj_inp_pm_group.wg_pm_contact_tel = cmfrec.cmf_lacc_tel
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	contract_enquiry,
	xcall execute( 'pmhenq',,,whgine_vj.wg_pm_contract)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	create_pm_contract,
	call read_contract
	if(.not.err)
	begin
		xcall ibc_message('Contract '+pmhrec.pmh_contract+' already exists for {W} '
		&	+whgine_vj.vj_tstk)
		return
	end
	xcall whginePMCreateContract(gold_com,whgine_vj,whgine_hdr,cmfrec)
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	read_contract,
	err=true
	if(whgine_vj.wg_pm_contract) then
	begin
		pmh_contract  = whgine_vj.wg_pm_contract
		pmh_site_add_no = whgine_vj.wg_pm_site_add_no
		xcall file(pass_chn_data.chn(PMH_FILE), pmhrec, pmh_key0, 'RD', err,,,,,D_NO_LOCK)
		if(.not.err) then
		begin
			xcall file(pass_chn_data.chn(PML_FILE), pmlrec,
			&	whgine_vj.vj_tstk+whgine_vj.wg_pm_contract,
			&	'RD', err,1,,,,D_NO_LOCK)
			if(err.ne.EOF_ERR.and.pmlrec.pml_contract.eq.pmhrec.pmh_contract.and.
			&	pml_equip_no .eq. whgine_vj.vj_tstk)
				clear err
		end
		else
			clear pmhrec
	end
	else if(view)
	begin
		xcall file(pass_chn_data.chn(PML_FILE), pmlrec, vj_tstk, 'RD', err,1,,,,D_NO_LOCK)
		if(err.ne.EOF_ERR.and.pmlrec.pml_equip_no.eq.vj_tstk)
		begin
			xcall ibc_message('Contract not created for this item on this advice.'
			&	+'  However, the item does exist on contract '+pmlrec.pml_contract)
			clear err
		end
	end
	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;display_contract_screen,
	display_contract_screen,
	if(.not.orig_whgine_vj)
		orig_whgine_vj = whgine_vj
	xcall i_display(pm_cont_id, 'full_set', whgine_vj,,,,,,,,,,gold_com ,gold_ax)

	return
.end

function whginePMCreateContract,	^val
	.include 'gold_com' repository, group = 'aGoldCom'
	.include 'whgine_vj' repository, group = 'aWhgineVj'
	.include 'whgine_hdr' repository, group = 'aWhgineHdr'
	.include 'cmfrec' repository, group = 'aCMFRec'
	endparams
	external function
		pm_get_pmh_cont_ref,	a
	endexternal
	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal
	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal
	.include 'SRC:CMSCOM.REC'
	record
		lReturnValue,	int
		.include 'pmhrec' repository, group='lPMHRec'
		.include 'cm5rec' repository, group='cm5rec'
	endrecord
proc
	lReturnValue=true
	if(!aWhgineVj.wg_pm_contract)
	begin
		data lError,	int
		init lPMHRec
		lPMHRec.pmh_contract = %pm_get_pmh_cont_ref(aGoldCom,pass_chn_data.chn(PMH_FILE), g_com_chn)
		xcall file(pass_chn_data.chn(PMH_FILE), lPMHRec, lPMHRec.pmh_contract, 'RD', lError)
		if(lError)
			xcall ibc_message('Error creating PMH record for {W} '+aWhgineVj.vj_tstk)
		else
		begin
			data lAddressLoop,	int
			lPMHRec.pmh_site_add_no = 0
			lPMHRec.pmh_inv_type = pass_gen_data.pm_create_cont_ivt
			xcall s_bld(lPMHRec.pmh_desc_1,,'{W} ADV %a %a',aWhgineHdr.vi_job, aWhgineHdr.vi_narr)
			xcall s_bld(lPMHRec.pmh_desc_2,,'{W} NO %a %a', aWhgineVj.vj_tstk, aWhgineVj.vj_code)
			xcall s_bld(lPMHRec.pmh_desc_3,,'Model %a',,aWhgineVj.vj_model)
			lPMHRec.pmh_cust_acc = aWhgineHdr.vi_cust
			lPMHRec.pmh_fin_acc = aWhgineHdr.vi_fcus
			lPMHRec.pmh_fin_agree = aWhgineHdr.vi_fpro
			if(aWhgineHdr.vi_deladd[])
				for lAddressLoop from 1 thru 5
					lPMHRec.pmh_site_address[lAddressLoop]=aWhgineHdr.vi_deladd[lAddressLoop]
			lPMHRec.pmh_cust_ord = aWhgineHdr.vi_cord
			lPMHRec.pmh_contact_nam = aWhgineVj.wg_pm_contact_name
			lPMHRec.pmh_contact_tel = aWhgineVj.wg_pm_contact_tel
			lPMHRec.pmh_status = 0
			lPMHRec.pmh_nickname =  aCMFRec.cmf_nick_name
			lPMHRec.pmh_area = aCMFRec.cmf_pc_area
			lPMHRec.pmh_plant_equipment = false
			lPMHRec.pmh_sal_date_fr = aWhgineVj.wg_pm_chg_date_fr
			lPMHRec.pmh_sal_date_to = aWhgineVj.wg_pm_chg_date_to
			lPMHRec.pmh_depot = aGoldCom.cur_depot
			xcall file(g_com_chn, cm5rec, 5, 'RN', lError,,,,,D_NO_LOCK)
			if lError
				clear cm5rec
			lPMHRec.pmh_update_from_model=cm5_pm_user_model_charges
			aWhgineVj.wg_pm_contract = lPMHRec.pmh_contract
			xcall whginePMCreateLines(aGoldCom,aWhgineVj,aWhgineHdr)
			xcall file(pass_chn_data.chn(PMH_FILE), lPMHRec, , 'WR',lError)
			lReturnValue=lError
			if lError
				xcall ibc_message('Error updating PMH record for {W} '+aWhgineVj.vj_tstk)
			else
				aWhgineVj.wg_pm_contract = lPMHRec.pmh_contract
		end
	end
	freturn lReturnValue
endfunction

function whginePMCreateLines,	^val
	.include 'gold_com' repository, group = 'aGoldCom'
	.include 'whgine_vj' repository, group = 'aWhgineVj'
	.include 'whgine_hdr' repository, group = 'aWhgineHdr'
	endparams
	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal
	record
		lReturnValue,	int
		.include 'pmlrec' repository, group='lPMLRec'
		.include 'pmmrec' repository, group='lPMMRec'
		.include 'vmrec' repository, group='lVMRec'
	endrecord
proc
	lReturnValue=false
	begin
		data lError,	int
		init lPMLRec
		xcall file(pass_chn_data.chn(VM_FILE), lVMRec, aWhgineVj.vj_tstk , 'RD', lError,,,,,D_NO_LOCK)
		if(lError)
			xcall file(pass_chn_data.chn(HM_FILE), lVMRec, aWhgineVj.vj_tstk , 'RD', lError,,,,,D_NO_LOCK)
		if(lError)
			lReturnValue=lError
	end
	if !lReturnValue
	begin
		data lError,	int
		data lDoneMainSeries,	boolean,	false
		init lPMLRec
		lPMLRec.pml_contract = aWhgineVj.wg_pm_contract
		lPMLRec.pml_site_add_no = 0
		lPMLRec.pml_equip_no = aWhgineVj.vj_tstk
		xcall file(pass_chn_data.chn(PMM_FILE),, aWhgineVj.wg_pm_model , 'FI', lError)
		repeat
		begin
			xcall file(pass_chn_data.chn(PMM_FILE),lPMMRec, aWhgineVj.wg_pm_model , 'RS', lError)
			if lError || lPMMRec.pmm_model != aWhgineVj.wg_pm_model
				exitloop
			lPMLRec.pml_pmmrec_grp=lPMMRec
			if !lDoneMainSeries
				xcall whginePMSetMainSeriesFields(lPMLREC,aWhgineVj,aWhgineHdr,lVMRec)
			lDoneMainSeries=true
			xcall whginePMCreateServices(lPMLREC)
			xcall file(pass_chn_data.chn(PML_FILE), lPMLREC,, 'ST',lError)
			lPMLRec.pmlsr.pml_sinv_date_fr=0
			lPMLRec.pmlsr.pml_sinv_date_to=0
		end
		if !lDoneMainSeries
		begin
			init lPMMRec
			lPMLRec.pml_pmmrec_grp=lPMMRec
			xcall whginePMSetMainSeriesFields(lPMLREC,aWhgineVj,aWhgineHdr,lVMRec)
			xcall file(pass_chn_data.chn(PML_FILE), lPMLREC,, 'ST',lError)
		end
	end
	aWhgineVj.wg_pm_equip_no = aWhgineVj.vj_tstk
	freturn lReturnValue
endfunction

subroutine whginePMSetMainSeriesFields
	.include 'pmlrec' repository, group = 'aPMLRec'
	.include 'whgine_vj' repository, group = 'aWhgineVj'
	.include 'whgine_hdr' repository, group = 'aWhgineHdr'
	.include 'vmrec' repository, group = 'aVMRec'
proc
	aPMLRec.pmm_model =  aWhgineVj.wg_pm_model
	if(!aPMLRec.pmm_desc_1)
		aPMLRec.pmm_desc_1 = aWhgineVj.vj_model
	aPMLRec.pmm_charge_code  = aWhgineVj.wg_pm_charge_code
	aPMLRec.pmm_contract_charge = aWhgineVj.wg_pm_contract_charge
	aPMLRec.pml_shift_pattern = aWhgineVj.wg_pm_curr_clock / 12
	aPMLRec.pml_ser = aWhgineVj.vj_ser		;Serial Number
	aPMLRec.pml_pord = aVMRec.vmpord			;Wholegood Order No
	aPMLRec.pml_reg = aWhgineVj.vj_reg		;Registration No
	aPMLRec.pmlsr.pml_sinv_date_fr=aWhgineVj.vj_inp_pm_group.wg_pm_chg_date_fr
	aPMLRec.pmlsr.pml_sinv_date_to=aWhgineVj.vj_inp_pm_group.wg_pm_chg_date_to
	if aWhgineVj.vj_inp_pm_group.wg_pm_curr_clock && aWhgineVj.vj_inp_pm_group.wg_pm_curr_clock_date
	begin
		aPMLRec.pml_clock = aWhgineVj.vj_inp_pm_group.wg_pm_curr_clock	;Last Actual Clock Reading
		aPMLRec.pml_curr_clock_date = aWhgineVj.vj_inp_pm_group.wg_pm_curr_clock_date
		aPMLRec.pml_initial_clock =  aWhgineVj.vj_inp_pm_group.wg_pm_curr_clock
		aPMLRec.pml_initial_clock_date  = aWhgineVj.vj_inp_pm_group.wg_pm_curr_clock_date
	end
	else
	begin
		aPMLRec.pml_clock = aWhgineVj.vj_clok	;Last Actual Clock Reading
		aPMLRec.pml_curr_clock_date = aWhgineHdr.vi_idat
		aPMLRec.pml_initial_clock =  aWhgineVj.vj_clok
		aPMLRec.pml_initial_clock_date  = aWhgineHdr.vi_idat
	end
	xreturn
endsubroutine

function whginePMCreateServices,	^val
	.include 'pmlrec' repository, group = 'aPMLRec'
	.include 'whgine_passed' repository, group='aWhginePassed'
	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal
	record
		lReturnValue,		int
		lError,				int
		lServiceSequence,	d10
		.include 'pmdrec' repository, group = 'lPMDRec'
		.include 'pmdrec' repository, group = 'lStorePMDRec'
	endrecord
proc
	init lPMDRec
	lPMDRec.pmd_site_add_no = aPMLRec.pml_site_add_no
	lPMDRec.pmd_model = aPMLRec.pmm_model
	lPMDRec.pmd_service_series = aPMLRec.pmm_service_series
	clear lPMDRec.pmd_service_sequence
	lServiceSequence=0
	xcall file(pass_chn_data.chn(PMD_FILE), lPMDRec,lPMDRec.pmd_key, 'FI',lError)
	repeat
	begin
		xcall file(pass_chn_data.chn(PMD_FILE), lPMDRec,, 'RS',lError,,,,,D_NO_LOCK)
		if(lError.or.lPMDRec.pmd_model.ne.aPMLRec.pmm_model.or.
		&	lPMDRec.pmd_service_series.ne.aPMLRec.pmm_service_series.or.
		&	lPMDRec.pmd_contract.or.lPMDRec.pmd_site_add_no.ne.aPMLRec.pml_site_add_no)
			exitloop

		lPMDRec.pmd_uniq_ref=lServiceSequence+1
		lPMDRec.pmd_service_sequence=lServiceSequence+1
		lPMDRec.pmd_contract=aPMLRec.pml_contract
		lPMDRec.pmd_equip_no=aPMLRec.pml_equip_no
		if lServiceSequence
		begin
			lPMDRec.pmd_prev_uniq_ref=lServiceSequence
			xcall file(pass_chn_data.chn(PMD_FILE), lPMDRec,, 'ST',lError)
		end
		else
			lStorePMDRec=lPMDRec
		incr lServiceSequence
	end
	if lServiceSequence
	begin
		lPMDRec=lStorePMDRec
		lPMDRec.pmd_prev_uniq_ref=lServiceSequence
		xcall file(pass_chn_data.chn(PMD_FILE), lPMDRec,, 'ST',lError)
	end
	freturn lReturnValue
endfunction

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Checks a Wholegood to ensure any contract down payment attacthments are valid
;	returns true if their is an issue
.function whgine_check_pm_details,	^val
	req in aWGDStockNo,						a		;the WholeGood to check
	opt in aPrompt,							n		;if passed and true warn the user of any problems
	.include 'wg_pm_group' repository, group = 'wg_pm_group'
	opt in aShowContractError,				n		;if passed shows any issues for contract creation
	opt in aFinalInvoiceRunCheck,			n		;if passed shows any issues which must be resolved before invoicing
	endparams
	.include 'SRC:OPSCOM.REC'

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	external function
		f_yes_no,       d
	endexternal

	record gen
		.include 'varec' repository, group = 'varec'
		.include 'vdrec' repository, group = 'vdrec'
		.include 'pmmrec' repository, group = 'pmmrec'
		lFoundAttachment,			a10
		lReturnError,				i4
		lContractError,				i4
		lFileIOError,				i4
		lFinalInvoiceRunCheckError,	i4
	endrecord

	record objects
		lErrorText,			string
	endrecord
.proc
	init gen
	pass_gen_data.f_pm_att=false
	if ^passed(wg_pm_group)
	begin
		lContractError=true
		lErrorText='Entry of contract detail incomplete\n'
		if !wg_pm_group.wg_pm_model
			lErrorText=lErrorText+' - missing model code'
		else if !wg_pm_group.wg_pm_charge_code
			lErrorText=lErrorText+' - missing charge code'
		else if !wg_pm_group.wg_pm_curr_clock
			lErrorText=lErrorText+' - missing Expected Yearly Hours/Mileage'
		else if !wg_pm_group.wg_pm_contract_charge
			lErrorText=lErrorText+' - missing contract charge'
		else
			lContractError=false
		if !lContractError
		begin
			xcall file(pass_chn_data.chn(PMM_FILE), pmmrec, wg_pm_group.wg_pm_model , 'RD', lFileIOError)
			if lFileIOError || pmmrec.pmm_model != wg_pm_group.wg_pm_model
			begin
				lErrorText='invalid contract model code entered'
				lContractError=true
			end
		end
	end


	xcall file(pass_chn_data.chn(VD_FILE),vdrec,aWGDStockNo,'FI',lFileIOError,1)
	repeat
	begin
		xcall file(pass_chn_data.chn(VD_FILE),vdrec,,'RS',lFileIOError,,,,,Q_NO_LOCK)
		if(lFileIOError.or.vdrec.vdstok.ne.aWGDStockNo) exitloop

		if(.not.vd_rrp[D_FC]) nextloop

		xcall file(pass_chn_data.chn(VA_FILE), varec, vdrec.vdcode, 'RD', lFileIOError)
		if(lFileIOError) nextloop

		if(varec.vadopt.ne.2) nextloop

		;already got a downpayment for this wholegood
		if  pass_gen_data.f_pm_att
		begin
			lReturnError=true
			;it is critical that invoices are not produced with multiple downpayments as contract
			;monthly provision will in no way handle this
			lFinalInvoiceRunCheckError=true
			lErrorText='Multiple down payment attachments for {WGD} '+%atrim(aWGDStockNo)+'\n'+
			&	'only one down payment is allowed against a {WGD}'+'\n'+
			&	'this must be rectified before the {WGD} advice note can be invoiced'
			exitloop
		end
		lFoundAttachment=vdrec.vdcode
		pass_gen_data.f_pm_att = true
	end
	if !lReturnError && (pass_gen_data.f_pm_att == true)
	begin
		if lContractError
		begin
			lReturnError=true
			;it is critical that invoices are not produced with downpayments where contract details have not
			;been set up as contract monthly provision will in no way handle this
			lFinalInvoiceRunCheckError=true
			lErrorText = 'WARNING - Down Payment Attachment '+%atrim(lFoundAttachment)+' applicable\n'+
			&	           +'however a contract cannot be setup because\n'+
			&			   +' - '+lErrorText+'\n'+
			&			   'this must be rectified before the {WGD} advice note can be invoiced'
		end
	end
	if ((!lReturnError) && lContractError)
		if ^passed(aShowContractError) && aShowContractError
			lReturnError = lContractError

	if lReturnError
		if(%passed(aPrompt).and.aPrompt.eq.true)
		begin
			if ^passed(aFinalInvoiceRunCheck) && aFinalInvoiceRunCheck
			begin
				if lFinalInvoiceRunCheckError
					xcall ibc_message((a) lErrorText)
				lReturnError = lFinalInvoiceRunCheckError
			end
			else
			begin
				lErrorText = lErrorText + '\nAmend Contract Setup Details?'
				if %f_yes_no((a) lErrorText) .ne. D_YES
					lReturnError=false
			end
		end
	freturn lReturnError
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       ALLOW ENTRY OF CLOCK DETAILS FOR PLAN MAINT - THIS IS ONLY
;       PERMITTED IF THE CURRENT ITEM IS CHARGE BY CLOCK TYPE
; returns ret_val - 0 (D_NO_ERROR) if successful, -1 (D_USER_ABORT) on cancel
;                  or error_no if error occurs
.function whgine_pm_clock_entry, ^val
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	a_view,         n
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'pmhrec' repository, group = 'pmhrec'
	.include 'pmlrec' repository, group = 'pmlrec'
	.include 'pmcrec' repository, group = 'pmcrec'
	endparams


	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM5REC.REC'

	external function
		f_yes_no,       d

	record gen
		.include 'whgine_vj' repository, group = 'orig_whgine_vj', nofields
		ret_val,        d3
		search,         d1
		.include 'fkeys' repository, group = 'clock_fkeys'
		view,           d1
		chr,            a1
		dsp_pml_est_usage,d9
		dsp_pml_est_usage_pd,d9.2
		clock_id,       i4
		err,            i4
		disp_message,   i4
		f_upd_pml,      i4
	endrecord
.proc
	init gen

	if %passed(a_view) then
		view = a_view
	else
		view = false

	call setup

	if .not. ret_val
		call input_clock

	freturn ret_val

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	setup,
	call set_up_fkeys

	call load_windows

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	set_up_fkeys,
	clear clock_fkeys, clock_fkeys.fkmnu_id
	if .not. view
	begin
		clock_fkeys.fkey[D_FK_NO2] = T$FK_SKIP
		clock_fkeys.fkey[D_FK_NO3] = T$FK_FIRST
		clock_fkeys.fkey[D_FK_NO4] = T$FK_CANC
	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	load_windows,
	xcall ibc_ldinp(clock_id,g_utlib,'whgine_i_pm_clk', D_CENTER_WND,
	&               search,,,, clock_fkeys)
	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	input_clock,

	xcall file(g_com_chn, cm5rec, 5, 'RN', err,,,,,D_NO_LOCK)
	unlock g_com_chn

	if(vj_inp_act_clock)
		pml_clock=vj_inp_act_clock
	if(vj_inp_act_clock_date)
		pml_curr_clock_date=vj_inp_act_clock_date
	err=%pm_calc_usage(pmlrec,dsp_pml_est_usage)

	clear orig_whgine_vj
	disp_message=false
	call display_clock_screen
	orig_whgine_vj = whgine_vj

	xcall ibc_disable(clock_id, 'VJ_INP_ACT_CLOCK_DATE')

	xcall i_next(clock_id, 'inp_set', '*FRST*')

	if view then
	begin
		xcall e_state( D_OFF, D_ECHO, D_CURSOR )
		xcall ibc_chr(chr, clock_id,,,,, clock_fkeys)  ;Get a keystroke
        ; reinstate cursor and echo
		xcall e_state( D_ON, D_ECHO, D_CURSOR )
	end
	else
	begin
		xcall ibc_input(clock_id, 'inp_set', whgine_vj, gold_com.inp_col_id, ,,
		&           D_NOTERM,, clock_fkeys, gold_com, gold_ax, whgine_passed, pmlrec, cm5rec,
		&           dsp_pml_est_usage_pd,pmhrec)
	end
	if (view .or. g_select .and. g_entnam .eq. 'J_QUIT') then
	begin
		whgine_vj = orig_whgine_vj
		ret_val = D_USER_ABORT
	end
	else
	begin
		if(whgine_vj .ne. orig_whgine_vj)
		begin
			disp_message=2          ; note set to 2 = display, 1=write to log file
			if(vj_inp_act_clock.and.vj_inp_act_clock.ne.pml_clock)
			begin
				f_upd_pml=true
				pml_clock=vj_inp_act_clock
				pml_curr_clock_date=vj_inp_act_clock_date
				err=%pm_calc_usage(pmlrec,dsp_pml_est_usage)
			end
			call display_clock_screen
			if(%f_yes_no('OK To Update?', 20) .ne. D_YES)
				whgine_vj = orig_whgine_vj
			else
			begin
				if(f_upd_pml)
				begin
					pml_clock=vj_inp_act_clock
					pml_curr_clock_date=vj_inp_act_clock_date
					if(wg_pm_curr_clock.ne.pml_clock) then
						wg_pm_curr_clock_est=true
					else
						wg_pm_curr_clock_est=false
					wg_pm_clock=vj_inp_act_clock
					items_moded=true
				end
				xcall whgine_set_plan_maint_charges(inp_nstk_id,
				&   whgine_vj, whgine_passed, gold_com,invoice_totals )
				xcall i_display(inp_nstk_id, 'nstk_fullset', whgine_vj,,,,,,,,,, gold_com,
				&           gold_ax)
				xcall i_display(inp_nstk_clk_id,, whgine_vj,,,,,,,,,,gold_com ,gold_ax, pmhrec,pmlrec)
			end
		end
	end
	xcall ibc_window(D_REMOVE, clock_id)

	return
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;display_clock_screen,
	display_clock_screen,
	xcall pminvx_set_period_est_clock(cm5rec,
	&       wg_pm_curr_clock, dsp_pml_est_usage, dsp_pml_est_usage_pd,
	&       pmc_interval, pmc_frequency,
	&       whgine_vj.wg_pm_chg_date_fr,whgine_vj.wg_pm_chg_date_to,
	&       pmhrec, pmlrec, true, disp_message,,,true)
	if(.not.orig_whgine_vj)
		orig_whgine_vj = whgine_vj
	xcall i_display(clock_id, 'disp_set', whgine_vj)
	xcall i_dspfld(clock_id,'dsp_pml_clock', pml_clock, gold_com)
	xcall i_dspfld(clock_id,'dsp_pml_curr_clock_date', pml_curr_clock_date, gold_com)
	xcall i_dspfld(clock_id,'dsp_pml_est_usage', dsp_pml_est_usage, gold_com)
	xcall i_dspfld(clock_id,'dsp_pml_est_usage_pd', dsp_pml_est_usage_pd, gold_com)

	return
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display Method
.function whgine_dsp_total_clock_display, ^val, reentrant
	a_data_stored           ,a      ; Data in storage form
	a_data_displayed        ,a      ; Buffer for data in display form
	.include "WND:inpinf.def"       ; Group argument of input info
	.include 'whgine_vj' repository, group = 'whgine_vj'
	;  Not passed if in I_INPFLD/I_DSPFLD.
	a_attributes            ,n      ; Attributes for display
	a_color                 ,n      ; Color for display
        ; a_method_data         ,a      ; Optional method data argument
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'pmhrec' repository, group = 'pmhrec'
	.include 'pmlrec' repository, group = 'pmlrec'

	.define SYN_TK
	.include "SRC:OPSCOM.REC"

	record general
		clock_qty,            d9
		final_text,           a40
.proc
	clock_qty = wg_pm_curr_clock - wg_pm_last_clock - wg_pm_idle_time
	xcall i_dspfld(inp_wndid, 'dsp_total_clock' ,clock_qty)
	if(.not.pml_sal_date_to)
		pml_sal_date_to=pmh_sal_date_to
	if(pml_sal_date_to.eq.wg_pm_chg_date_to) then
	begin
		final_text='FINAL INVOICE'
		if(wg_pm_last_inv_date.ge.wg_pm_curr_clock_date.and.
		&   wg_pm_chg_date_fr.eq.wg_pm_chg_date_to)
			final_text=%atrim(final_text)+' ADJUSTMENT'
	end
	else
		final_text='NOT FINAL INVOICE'

	if(clock_qty.lt.0)
		final_text=%atrim(final_text)+' PART CREDIT'

	xcall i_dspfld(inp_wndid, 'dsp_final_text' ,final_text)

	freturn TRUE
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       change method for override clock reading
.function whgine_idle_time_change , ^val
	a_data_entered,     n
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'pmlrec' repository, group='pmlrec'
	.include 'cm5rec' repository, group='cm5rec'
	a_clock_per_day,                        n
	.include 'SRC:OPSCOM.REC'
	record general
		tmp_pml_clock,  d9
.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT'))
		freturn a_pending_status
	if vj_inp_act_clock then
		tmp_pml_clock=vj_inp_act_clock-wg_pm_last_clock
	else
		tmp_pml_clock=wg_pm_curr_clock-wg_pm_last_clock
	if (tmp_pml_clock .lt. a_data_stored .and. tmp_pml_clock .gt. 0) .or.
	& (tmp_pml_clock .gt. a_data_stored .and. tmp_pml_clock .lt. 0)
	begin
		a_pending_status=D_EMITTEDERR
		xcall ibc_message('Idle Time Exceeds Total Units Expected ('+%string(tmp_pml_clock)+')')
	end
	if ( a_data_stored .lt. 0 .and. tmp_pml_clock .gt. 0)
	begin
		a_pending_status=D_EMITTEDERR
		xcall ibc_message('Idle Time is negative while Total Units Expected is positive ('+%string(tmp_pml_clock)+')')
	end
	if ( a_data_stored .gt. 0 .and. tmp_pml_clock .lt. 0)
	begin
		a_pending_status=D_EMITTEDERR
		xcall ibc_message('Idle Time is positive while Total Units Expected is negative ('+%string(tmp_pml_clock)+')')
	end
	freturn a_pending_status
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       change method for override clock reading
.function whgine_vj_inp_act_clock_change , ^val
	a_data_entered,     n
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'pmlrec' repository, group='pmlrec'
	.include 'cm5rec' repository, group='cm5rec'
	a_clock_per_day,                        n
	.include 'pmhrec' repository, group='pmhrec'

	.include 'SRC:OPSCOM.REC'
	record general
		tmp_pml_clock,  d9
		ret_val,        i4
.proc
	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT'))
		freturn a_pending_status

	if(a_data_stored)
	begin
		if %pm_clock_update(D_AUDIT_WHOLEGOOD_INVOICE, pmlrec.pml_equip_no, pmlrec.pml_equip_no, pmh_plant_equipment,
		&       a_data_stored,,true)
			freturn D_EMITTEDERR
	end
	vj_inp_act_clock=a_data_stored

	if(.not.vj_inp_act_clock) then
		tmp_pml_clock=pml_clock
	else
		tmp_pml_clock=vj_inp_act_clock

	if(vj_inp_act_clock.ne.wg_pm_curr_clock) then
		wg_pm_curr_clock_est=true
	else
		wg_pm_curr_clock_est=false

	if(pml_max_usage.and.tmp_pml_clock.gt.pml_max_usage)
	begin
		xcall ibc_message('Warning - The maximum usage is set at '+%string(pml_max_usage)
		&       +' and the current clock setting of '+%string(tmp_pml_clock)+' exceeds this')
	end
	xcall i_init(inp_wndid,  'inp_set', whgine_vj, 'vj_inp_act_clock_date,wg_pm_idle_time')
	if(.not.vj_inp_act_clock) then
		xcall i_next(inp_wndid,  'inp_set', '*DONE*')
	else
	begin
		xcall ibc_enable(inp_wndid, 'vj_inp_act_clock_date')
		xcall i_next(inp_wndid,  'inp_set', 'vj_inp_act_clock_date')
	end
	freturn D_OK
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgine_clock_date_change, ^val, reentrant
	a_data_entered          ,a      ; A buffer containg the field data as
                                        ;  entered by the user.
	a_data_stored           ,d      ; A buffer for the final storage of the
                                        ;  data.
	a_pending_status        ,n      ; The result of Toolkit's field
                                        ;  validations.
	.include "WND:inpinf.def"       ; Group argument of input info
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'GOLD_AX' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'pmlrec' repository, group='pmlrec'
	.include 'cm5rec' repository, group='cm5rec'

	external function
		f_alpha11_date,         a
		julian,                 d
	record general
		tmp_date,       d8


		.include 'SRC:OPSCOM.REC'
.proc
	a_pending_status = %stored_date_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj)
	if(( a_pending_status.ne.D_OK ).or.(g_select .and. (g_entnam.eq.'I_DRILL')))
		freturn a_pending_status
	;all okay but want an actual date not 'TODAY','SME',...etc
	a_data_stored=%f_get_date(a_data_stored,TRUE)

	; if there is a maximum age in days held on control file, check the
	; date entered compared with this and the end invoice date.
	if(cm5_pm_max_act_days)
	begin
		tmp_date=%julian((%julian(whgine_vj.wg_pm_chg_date_to)-cm5_pm_max_act_days),true)
		if(a_data_stored.lt.tmp_date)
		begin
			xcall ibc_message('Warning - the date entered is earlier than'
			&                 +' the invoice period end date set at '
			&                 +%f_alpha11_date(whgine_vj.wg_pm_chg_date_to)
			&                 +' minus '
			&                 +%string(cm5_pm_max_act_days)
			&                 +' days maximum age of current clock date.')
		end
	end
	wg_pm_curr_clock_date=a_data_stored

	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       change method for current clock reading
;       displys a warning message if current < previous
.function whgine_wg_pm_model_change , ^val
	a_data_entered,     a
	a_data_stored,      a
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'fkeys' repository, group='fkeys'
	pmm_chn,   n

	.include "SRC:OPSCOM.REC"

	external function
		f_curr_fc,      d


	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	record general
		.include 'pmmrec' repository, group = 'pmmrec'
.proc
	if( (a_pending_status.ne.D_OK .and. a_pending_status.ne.D_REQERR) .or.
	&   g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL' .or. g_entnam.eq.'I_HYPER')
		freturn a_pending_status

	a_pending_status = %pmm_change(a_data_entered, a_data_stored,
	&       a_pending_status, inputinfo, whgine_vj)

	if( (a_pending_status.ne.D_OK .and. a_pending_status.ne.D_REQERR) .or.
	&   g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL' .or. g_entnam.eq.'I_HYPER')
		freturn a_pending_status

	if (a_data_entered.eqs.'?')
	begin
		clear a_data_entered, a_data_stored
		xcall m_signal('I_DRILL')
		freturn D_OK
	end

	if(.not.a_data_stored) freturn D_EMITTEDERR


	whgine_vj.vj_inp_pm_group.wg_pm_model=a_data_stored

	xcall whgine_set_pm_chrg_default(inp_wndid,whgine_vj,pmmrec,gold_com,gold_ax,pmm_chn)
	if(.not.pmmrec.pmm_model)
		xcall ibc_message('WARNING - Non standard model entered')

	if(.not.whgine_vj.vj_inp_pm_group.wg_pm_charge_code.and.pmmrec.pmm_charge_code)
		xcall i_putfld(inp_wndid,, whgine_vj, 'wg_pm_charge_code', pmmrec.pmm_charge_code, gold_com, gold_ax )

	if(.not.whgine_vj.vj_inp_pm_group.wg_pm_contract_charge.and.pmmrec.pmm_contract_charge)
	begin
		pmmrec.pmm_contract_charge=%f_curr_fc(pmmrec.pmm_contract_charge,pass_gen_data.vi_exch_rate)
		xcall i_putfld(inp_wndid,, whgine_vj, 'wg_pm_contract_charge', pmmrec.pmm_contract_charge, gold_com, gold_ax )
	end
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_pm_chrg_default
	inp_wndid,              n
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'pmmrec' repository, group = 'pmmrec'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	pmm_chn,   n

	record general
		.include 'pmc_user' repository, group = 'pmc_user'
		err,		d3

.proc
	xcall file(pmm_chn, pmmrec, whgine_vj.vj_inp_pm_group.wg_pm_model, 'RD', err)
	if(err)
	begin
		clear pmmrec
	end

	xcall i_user(inp_wndid, 'wg_pm_charge_code', pmc_user)
	pmc_user.pmc_user_model = pmmrec.pmm_model
	clear pmc_user.pmmrec_mh
	clear pmc_user.pmc_handle_in_use

	xcall i_user(inp_wndid, 'wg_pm_charge_code',, pmc_user)
	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_deladd_from_cmf
	.include 'wgd_deladd' repository, group='aWgd_del_add'
	.include 'cmfrec' repository, group='cmfrec'
endparams

	record general
		loop,           d1

.proc
	wgd_deladd(1) = cmf_name
	for loop = 1 until 4 do wgd_deladd(loop+1) = cmf_address(loop)
	wgd_del_postcode = cmf_post_cd
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Desc : Process Documents tab
;
.subroutine whgine_proc_docs, reentrant
	a_wndid ,n
	.include 'GOLD_COM' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_passed' repository, group='whgine_passed'
	.include 'whgine_hdr' repository, group='whgine_hdr'
	.include 'whgine_lst' repository, group='whgine_lst'
	.include 'add_part_passed' repository, group='add_part_passed'
	.include 'invoice_totals' repository, group='invoice_totals'
	.include 'whgine_cmnt_lst' repository, group='whgine_cmnt_lst'
	.include 'add_part_str' repository, group='part_data'
	.include 'whgine_inv_tab' repository, group= 'whgine_inv_tab'
	.include 'whgine_vb' repository, group= 'whgine_vb'
	.include 'whgine_vj' repository, group= 'whgine_vj'
	.include 'whgine_vj' repository, group= 'whgine_nstk'
	.include 'doclst_pass' repository, group = 'doclst_pass'
	.include 'doc_search' repository, group='doc_search'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:CMSCOM.REC'

	record tmp
		hold_scut_avail,        d1

.proc
	xcall ibctab_highlight(gold_com.tabset_id, true, gold_com.tabhdr_id)
	xcall disp_curr(inv_curr )

	scut_avail = %get_shortcut
	hold_scut_avail = scut_avail
	xcall shortcut_off

	xcall e_sect(T$ARROW_KEYS, D_CLEAR, D_LEFT)

	xcall doc_list(gold_com, gold_ax, a_wndid, fkeys[DOC_FKEYS], doclst_pass, doc_search)

	scut_avail = hold_scut_avail
	if (scut_avail)
		xcall shortcut_on

	xcall ibctab_highlight(gold_com.tabset_id, false)
	xreturn
.end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; hisasr hisasr
.subroutine whgineArriveVJ_code
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'GOLD_COM'     repository, group = 'gold_com'
	.include 'GOLD_AX'      repository, group = 'gold_ax'
	.include 'fkeys'        repository, group = 'wFKeys'

	.include 'SRC:OPSCOM.REC'

	record General
		.include 'vw_user' repository, group = 'vw_user'

.proc

	xcall i_user(inp_wndid,'vj_code',vw_user)
	vw_user.mak_cod = whgine_vj.vj_mak      ; if blank will also set user data blank
	vw_user.fld_vwmodl = false              ; if blank will also set user data blank
	vw_user.include_vxf = false
	xcall i_user(inp_wndid,'vj_code',,vw_user)
	xreturn
.end;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgineDisplayVJ_CODE,^val
	a_data_stored        ,a
	a_data_displayed     ,a
	.include "WND:inpinf.def"
	.include 'whgine_vj' repository, group='whgine_vj'
	a_attributes    ,n
	a_color         ,n
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'

	record General
		.include 'vw_user' repository, group = 'vw_user'
		h_modl,         a20
		h_model,        a20

		f_modl_drill,   d1
.proc
	h_model = vj_model
	xcall vw_check_drill_for_modl(a_data_stored, vj_model, f_modl_drill)
	h_modl=vj_model

	xcall i_user(inp_wndid,'vj_model',vw_user)
	vw_user.mak_cod = vj_mak                ; if blank will also set user data blank
	vw_user.model_code = a_data_stored      ; if blank will also set user data blank
	vw_user.fld_vwmodl = true
	vw_user.include_vxf = f_modl_drill

	xcall i_user(inp_wndid,'vj_model',,vw_user)

	if(f_modl_drill) then
		xcall i_fldmod(inp_wndid,'VJ_MODEL',,,D_FLD_DRILL, 'vw_drill', D_FLD_DFLT, h_modl)
	else
	begin
		if(h_modl) then
			xcall i_fldmod(inp_wndid,'VJ_MODEL',,,D_FLD_DRILL, '', D_FLD_DFLT, h_modl)
		else
			xcall i_fldmod(inp_wndid,'VJ_MODEL',,,D_FLD_DRILL, '', D_OFF, D_FLD_DFLT)
	end
	if (h_model && h_model != '?' && h_model != '*')
	begin
		xcall i_putfld(inp_wndid, '*CURR*', whgine_vj, 'vj_model', h_model)
	end
	freturn TRUE
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgineDisplayVB_CODE,^val
	a_data_stored        ,a
	a_data_displayed     ,a
	.include "WND:inpinf.def"
	.include 'whgine_vb' repository, group='whgine_vb'
	a_attributes    ,n
	a_color         ,n
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'

	record General
		.include 'vw_user' repository, group = 'vw_user'
		h_modl,         a20
		h_model,        a20

		f_modl_drill,   d1
.proc
	h_model = vb_tmod
	xcall vw_check_drill_for_modl(a_data_stored, vb_tmod, f_modl_drill)
	h_modl=vb_tmod
	;	if(.not.h_model.and.vb_tmod) h_model=vb_tmod

	xcall i_user(inp_wndid,'vb_tmod',vw_user)
	vw_user.mak_cod = vb_mak                ; if blank will also set user data blank
	vw_user.model_code = a_data_stored      ; if blank will also set user data blank
	vw_user.fld_vwmodl = true
	vw_user.include_vxf = true
	xcall i_user(inp_wndid,'vb_tmod',,vw_user)

	if(f_modl_drill) then
		xcall i_fldmod(inp_wndid,'VB_TMOD',,,D_FLD_DRILL, 'vw_drill', D_FLD_DFLT, h_modl)
	else
	begin
		if(h_modl) then
			xcall i_fldmod(inp_wndid,'VB_TMOD',,,D_FLD_DRILL, '', D_FLD_DFLT, h_modl)
		else
			xcall i_fldmod(inp_wndid,'VB_TMOD',,,D_FLD_DRILL, '', D_OFF, D_FLD_DFLT)
	end
	vb_tmod = h_model
	xcall i_putfld(inp_wndid,'*CURR*',whgine_vb,'vb_tmod',h_model)
	;	if(h_model.and.h_model.ne.'?'.and.h_model.ne.'*')
	;	  begin
	;	    vb_tmod = h_model
	;	    xcall i_putfld(inp_wndid,'*CURR*',whgine_vb,'vb_tmod',vb_tmod)
	;	  end
	freturn TRUE
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
.function whgineChangeVJ_MODEL, ^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VWREC.REC'



	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal


	record General
		.include 'vw_user' repository, group = 'vw_user'
		fldnam,         a30
	.align
	record ints
		FileError,      i4
.proc

	; WG7465 - REPLACE J_OVER WITH J_NEW_MOD 	IE. O'ride with New Mod
	; WG7465         if (g_select.and.g_entnam.eq.'J_OVER'.and.a_data_entered)
	if (g_select.and.g_entnam.eq.'J_NEW_MOD'.and.a_data_entered)	; WG7465
	begin
		clear g_select, g_entnam
		xcall i_next(inp_wndid,'*CURR*','VJ_MODEL')
		freturn D_OK
	end
	clear General, ^i(ints)
	if (a_data_entered(%trim(a_data_entered):1).eq.'?'.OR.
	&   a_data_entered(%trim(a_data_entered):1).eq.'*')
	begin
		clear a_data_entered(%trim(a_data_entered):1)
		a_data_stored = a_data_entered
		xcall m_signal('I_DRILL')
		freturn D_OK
	end

	fldnam = %i_getstring( inp_wndid, inp_fldnam )

	; read record using main model code. if this fails then non standard
	; model therefore no point in going through vw change
	xcall file(pass_chn_data.chn(VW_FILE),vwrec,vj_code,'RD',FileError,,,,,D_NO_LOCK)
	if(.not.FileError)
	begin

		xcall vw_any_vxrec_for_vxmodl(vj_code, a_data_stored, fileerror)
		if(.not.fileerror)
		begin
			;                a_pending_status = %vw_change(a_data_entered,a_data_stored,a_pending_status,inputinfo,
			;                &       whgine_vj,gold_com,gold_ax,a_dummy_fkeys, vx_rfa)
			a_pending_status = %vw_change(a_data_entered,a_data_stored,a_pending_status,inputinfo,
			&       whgine_vj,gold_com,gold_ax,a_dummy_fkeys)
			xcall i_user(inp_wndid,fldnam,vw_user)	; AP180810
			vx_rfa=vw_user.vxf_rfa			; AP180810

			if ((a_pending_status.ne.D_OK .and. a_pending_status.ne.D_REQERR) .or.
			&   g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL' .or. g_entnam.eq.'I_HYPER')
				freturn a_pending_status

			xcall vw_get_vwrec_vxrec(inp_wndid, fldnam, vwrec, vj_code, vx_rfa)
			if(whgine_passed.f_acc_wg_exclude.and.%f_chk_vgf_restricted(,vwrec.vwgrp,dt, true))
				freturn D_EMITTEDERR

			; xcall i_dspfld(fm_TabSet.key_header_id,'vmcode',a_data_stored,gold_com,gold_ax)

			a_data_stored = vwrec.vwmodl
			xcall whgine_set_model_fields(inp_wndid, vwrec,  whgine_vj)
			xcall i_putfld(inp_wndid,'*CURR*',whgine_vj,'VJ_MODEL',a_data_stored)
		end
	end

	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.function whgineChangeVJ_CODE, ^val
	a_data_entered       ,a
	a_data_stored        ,a
	a_pending_status     ,n
	.include "WND:inpinf.def"
	.include 'whgine_vj' repository, group='whgine_vj'
	.include 'gold_com' repository, group = 'gold_com'
	.include 'gold_ax' repository, group = 'gold_ax'
	a_dummy_fkeys,          a
	.include 'whgine_passed' repository, group='whgine_passed'
	group fkeys,    [MAX_FKEYS] a
		.include 'fkeys' repository, group='fkeys_grp'
	endgroup
	.include 'whgine_lst' repository, group = 'whgine_lst'
	.include 'whgine_inv_tab' repository, group = 'whgine_inv_tab'
	.include 'whgine_hdr' repository, group = 'whgine_hdr'
	.include 'add_part_passed' repository, req inout group='add_part_passed'
	.include 'invoice_totals' repository, req inout group='invoice_totals'
	endparams

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:VWREC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,whgine_pass_chn_data_str
	endglobal
	record General
		.include 'vw_user' repository, group = 'vw_user'
		fldnam,         a30
	.align
	record ints
		FileError,      i4
.proc

	; WG7465 - REPLACE J_OVER WITH J_NEW_MOD 	IE. O'ride with New Mod
	; WG7465        if (g_select.and.g_entnam.eq.'J_OVER'.and.a_data_entered)
	if (g_select.and.g_entnam.eq.'J_NEW_MOD'.and.a_data_entered)	; WG7465
	begin
		clear g_select, g_entnam
		xcall i_next(inp_wndid,'*CURR*','VJ_MODEL')
		freturn D_OK
	end
	clear General, ^i(ints)

	fldnam = %i_getstring( inp_wndid, inp_fldnam )
	xcall i_user(inp_wndid,'vj_code',vw_user)
	vw_user.mak_cod = VJ_MAK                ; if blank will also set user data blank
	xcall i_user(inp_wndid,'vj_code',,vw_user)

	;       clear h_rfa
	a_pending_status = %vw_change(a_data_entered,a_data_stored,a_pending_status,inputinfo,
	&       whgine_vj,gold_com,gold_ax,a_dummy_fkeys, vx_rfa)

	if ((a_pending_status.ne.D_OK .and. a_pending_status.ne.D_REQERR) .or.
	&   g_entnam.eq.'J_QUIT' .or. g_entnam.eq.'I_DRILL' .or. g_entnam.eq.'I_HYPER')
		freturn a_pending_status

	xcall file(pass_chn_data.chn(VW_FILE),vwrec,a_data_stored,'RD',FileError,,,,,D_NO_LOCK)

	if (vwrec.vwcode .eq. %atrim(a_data_stored))
	begin
		if(whgine_passed.f_acc_wg_exclude.and.%f_chk_vgf_restricted(,vwrec.vwgrp,dt, true))
			freturn D_EMITTEDERR
		a_data_stored = vwrec.vwcode
		whgine_vj.vj_code = vwrec.vwcode
		xcall whgine_set_model_fields(inp_wndid, vwrec,  whgine_vj)
		; if a non stocked item then set other model fields
		if(.not.vj_vm_exists)
			xcall whgine_set_nstk_model_details(inp_wndid, whgine_vj, gold_com, gold_ax, whgine_passed, vwrec, whgine_hdr, invoice_totals)
	end
	else
		f_new_model = true

	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.subroutine whgine_set_model_fields
	pass_inp_wndid,         n
	.include 'VWREC'        repository, group = 'vwrec'
	.include 'WHGINE_VJ'    repository, group = 'WHGINE_VJ'
.proc
	;       vmspec[]=vwspec[]
	;       vmgrp=vwgrp
	;       vmmak=vwmake

	;       vjnspc[]=vwspec[]
	;       vjngrp=vwgrp
	;       vjnmak=vwmake

	vj_spec[]=vwspec[]
	;       vj_grp=vwgrp
	;       vj_mak=vwmake

	;       xcall i_putfld(pass_inp_wndid,'*CURR*',whgine_vj,'vj_model',vj_model)
	;       xcall i_putfld(pass_inp_wndid,'*CURR*',whgine_vj,'vmspec',vwrec.vwspec)
	;       xcall i_putfld(pass_inp_wndid,'*CURR*',whgine_vj,'vj_grp',vj_grp)
	;       xcall i_putfld(pass_inp_wndid,'*CURR*',whgine_vj,'vj_mak',vj_mak)

	xreturn
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       change method for reg date -
.function whgine_vj_reg_date_change , ^val
	a_data_entered,     a
	a_data_stored,      n
	a_pending_status,   n
	.include 'WND:inpinf.def'
	.include 'whgine_vj' repository, group = 'whgine_vj'
	.include 'gold_com' repository, group='gold_com'
	.include 'gold_ax' repository, group='gold_ax'
	.include 'whgine_passed' repository, group='whgine_passed'

	.include 'SRC:OPSCOM.REC'
.proc

	if a_pending_status .ne. D_OK .or. (g_select .and.
	&       (g_entnam .eq. 'J_QUIT'))
		freturn a_pending_status

	vj_reg_date = a_data_stored
	xcall whgine_set_dflt_vmmotd(inp_wndid, whgine_vj, true)
	freturn D_OK
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       default mot exp date from reg date -
.subroutine whgine_set_dflt_vmmotd
	inp_wndid,		n
	.include 'whgine_vj' repository, group = 'whgine_vj'
	ask_user,		n	; not passed when initially loading the wgd

	external function
		f_yes_no,               d

	.include 'SRC:OPSCOM.REC'
	record general
		h_vmmotd,	d8
.proc

	if(vj_type.eq.1 .and. vj_used .eq. 0.and. vj_reg_date)
	begin
		h_vmmotd = vj_vmmotd
		vj_vmmotd = vj_reg_date
		xcall add_months(vj_vmmotd, 36)
		if(vj_vmmotd.gt.h_vmmotd .and. h_vmmotd)
		begin
			if(%passed(ask_user).and.%f_yes_no( 'Recalculate MOT expiry Date ? ', 21 ) .ne. D_YES)
				vj_vmmotd = h_vmmotd
		end
		else
			vj_vmmotd = h_vmmotd

		xcall i_dspfld(inp_wndid, 'vj_vmmotd', vj_vmmotd)
	end
	xreturn
.end
;;;;;;l;l;l;l;l;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       update the free stock figures on pdf and create movement on pmv
.subroutine whgine_upd_part_data
	.include 'virec' repository, group= 'virec'
	.include 'vjrec' repository, group= 'vjrec'
	.include 'cmfrec' repository, group= 'cmfrec'
	.include 'ivtrec' repository, group= 'ivtrec'
	pmf_chn,        n
	pdf_chn,        n
	hid_chn,       n
	hpd_chn,       n

	.include 'SRC:OPSCOM.REC'

	.include 'SRC:HIDREC.REC'
	.include 'SRC:HPDREC.REC'

	.include 'pmfrec' repository, record= 'pmfrec'
	.include 'pdfrec' repository, record= 'pdfrec'
	.include 'pmvrec' repository, record= 'pmvrec'

	external function
		f_curr_bc,              d

	record general
		tmp_qty,        d10.3
		line_alloc,     d1
		new_batchno,    a6
		hadto_alloc,    i4
		cannot_alloc,   i4
		new_batchline,  i4
		sign,           d1
		err,            d3

.proc
	xcall file(pmf_chn,pmfrec,vjrec.vj_part_no,'RD',err)
	if(err) xreturn
	if(pmf_type .eq. D_PMF_TYP_MEMO )
		xreturn        ; memo part so n/a

	if (!vjsold)
		xreturn                            ; no change so exit

	pdf_depot = dt
	pdf_part_no = vjrec.vj_part_no

	xcall file(pdf_chn,pdfrec,pdf_key,'RE',err)
	if(err)
		xreturn

	if(viivcr.eq.D_VIIVCR_INVOICE .or.viivcr.eq.D_VIIVCR_PART_INV) then
		sign=1                ; invoice
	else
		sign=-1               ; credit

	if (vj_part_type.gt.D_PMF_TYP_MEMO)
		call make_hort

	xcall upd_pdf_wip(D_WIP_INS_MODE, D_WIP_WGD, vjrec, virec,
	&		       pdfrec, ivtrec, cmfrec, vjsold)

	xcall file(pdf_chn, pdfrec, pdf_key, 'WR', err)
	if(err) xcall ibc_message('Error updating depot stock record')

	Xreturn

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       Copy across Hort details
	make_hort,
	if (.NOT. new_batchno .and. viivcr .EQ. D_VIIVCR_CREDIT )
	begin
		repeat
		begin
			xcall dep_seq( dt, DEP_H_REC, new_batchno )
			hpd_batch = new_batchno
			xcall file( hpd_chn, hpdrec, hpd_batch, 'RD', err, 3,,,,Q_NO_LOCK)
			if( hpd_batch .ne. new_batchno ) exitloop
		end
	end

	clear hidkey0
	hidk0_link = D_HID_LINK_WGDS
	hidk0_invoice_no = vi_orig_invo
	hidk0_invoice_date = vi_orig_idat
	hidk0_line_no = vj_line

	xcall file( hid_chn, hidrec, hidkey0, 'FI', err )
	do forever
	begin
		xcall file( hid_chn, hidrec,, 'RS', err,,,,,Q_NO_TLOCK )
		if (err .OR. hid_link.ne.D_HID_LINK_WGDS .or.
		&   hid_invoice_no .NE. vi_orig_invo  ||
		&   hid_invoice_date .NE. vi_orig_idat  ||
		&   hid_line_no .NE. vj_line)
			exitloop

		clear line_alloc
		hid_invoice_no = vjjob
		hid_invoice_date = 0

		hpdk3_batch = hid_batch
		hpdk3_bat_line = hid_bat_line
		xcall file(hpd_chn,hpdrec,hpdkey3,'RD',err,3)
		if (.NOT. err) then
		begin
			if (viivcr .EQ. D_VIIVCR_CREDIT ) then
				; CREDITING - create new batch and bring in as a "receipt"
				call return_hpd
			else
			begin
				if (hpd_stk_qty .GE. hid_qty) then
					call reinv_hpd
				else
					call alloc_hpd
			end
		end
		else
			call alloc_hpd

		; Check if matched or found suitable equivalent for line.
		;  ONLY WRITE AWAY HID RECORD IF IT DID!
		if (line_alloc)
		begin
			hid_invoice_no = vijob
			hid_link = D_HID_LINK_WGDS
			hid_batch = hpd_batch
			hid_bat_line = hpd_bat_line
			hid_source = hpd_source
			xcall file( hid_chn, hidrec, , 'ST', err)
		end

	end

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       CREDITING - create new batch and bring in as a "receipt"
	return_hpd,
	hpd_status = 0
	hpd_batch = new_batchno
	incr new_batchline
	hpd_bat_line = new_batchline
	hpd_source = 5
	;        hpd_pur_ord_no = auto_advice
	hpd_pur_ord_no = virec.vijob
	hpd_stk_qty = 0
	hpd_alloc = hid_qty
	xcall file( hpd_chn, hpdrec,, 'ST', err )

	line_alloc = TRUE

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       RE-INVOICING A CREDIT with the original item still there...
	reinv_hpd,
	hpd_source = 0
	hpd_stk_qty = hpd_stk_qty - hid_qty
	xcall file( hpd_chn, hpdrec,, 'WR', err )

	line_alloc = TRUE

	return

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;       Select first available HPD record
	alloc_hpd,
	clear hpdkey0
	hpdk0_status = 0
	hpdk0_part = hid_part
	hpdk0_depot = dt
	xcall file( hpd_chn, hpdrec, hpdkey0, 'FI', err )

	do forever
	begin
		xcall file( hpd_chn, hpdrec, , 'RS', err )
		if (err .OR.
		&             hpd_status .NE. 0 .OR.
		&             hpd_part .NE. hid_part .OR.
		&             hpdk0_depot .NE. dt)
		begin
			incr cannot_alloc
			exitloop
		end

		if (hpd_stk_qty .LT. hid_qty)
			nextloop

		hpd_source = 0
		hpd_stk_qty = hpd_stk_qty - hid_qty
		hpd_retail = %f_curr_bc((vj_f_rrp*sign),vi_cur_cnv)
		xcall file( hpd_chn, hpdrec, , 'WR', err )
		incr hadto_alloc
		hid_serial_no = hpd_serial

		line_alloc = TRUE

		exitloop
	end

	return
.end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	after a wholegood has been entered, if applicable, this
;	routine checks if there is already a pm contract for the
;	equipment line.  If there is, the routine will not allow
;	amendmnt of it from whgine.  Instead, a mesage to this effect
;	it displayed and the user may go into the contract enquiry
subroutine whgine_validate_pm_entry_ok
	.include 'whgine_vj' repository, group='aWhgineVJ'
	endparams

	global data section whgine_gen_data
	record
		pass_gen_data, whgine_pass_gen_data_str
	endglobal

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal
	record
		lFileError,	int
		lMessage,	a1024
		.include 'pmlrec' repository, group='lPMLRec'
		.include 'pmhrec' repository, group='lPMHRec'
	endrecord

proc
	pass_gen_data.f_pm_exists=false
	pass_gen_data.f_pm_att=false
	xcall file(pass_chn_data.chn(PML_FILE) , lPMLRec, aWhgineVJ.vj_tstk,  'FI', lFileError,1)
	repeat
	begin
		xcall file(pass_chn_data.chn(PML_FILE) , lPMLRec,,  'RS', lFileError,1,,,,D_NO_LOCK)
		if(lFileError || aWhgineVJ.vj_tstk != lPMLRec.pml_equip_no) exitloop

		; if its the same contract then better make sure it is wgd type
		pmh_contract = pml_contract
		pmh_site_add_no = pml_site_add_no
		xcall file(pass_chn_data.chn(PMH_FILE) , lPMHRec, pmh_key0,  'RD', lFileError,,,,,D_NO_LOCK)
		if(lFileError) nextloop
		if(pmh_plant_equipment) nextloop
		; if it gets to here, then there is a valid contract for the
		; equipment and the user will not be able to enter any contract
		; details.  However, will offer the user the opportunity to
		; look at the contract
		pass_gen_data.f_pm_exists = true

		; having established that pm exists - check attachments
		lFileError = %whgine_check_pm_details(aWhgineVJ.vj_tstk, false, aWhgineVJ.vj_inp_pm_group)
		clear aWhgineVJ.vj_inp_pm_group
		aWhgineVJ.vj_inp_pm_group.wg_pm_contract=lPMLRec.pml_contract
		aWhgineVJ.vj_inp_pm_group.wg_pm_site_add_no=lPMLRec.pml_site_add_no
		; treat this field as a flag to indicate that the details held are
		; from an existing contract
		aWhgineVJ.vj_inp_pm_group.wg_pm_idle_time=999999999

		xcall s_bld(lMessage,,
		&	+'WARNING - Planned Maintenance Contract No %a already exists for {W} No %a'
		&	+' and therefore a contract will not be automatically created.  If you want the'
		&	+' automated contract, you will need to clear the item off the existing contract first then'
		&	+' clear and re-enter this {W} line.'
		&	,pml_contract,vj_tstk)
		if(pass_gen_data.f_pm_att)
			lMessage = %atrim(lMessage)+'  Also, Down Payment Attachment exists but will not be applied to the contract.'
		xcall ibc_message(%atrim(lMessage))
		exitloop
	end
	return
endsubroutine
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	subroutine to check if the advice has been copied before
.subroutine WhgineCheckCopyNotDoneBefore
	in req aJobNo,	a
	.include 'virec' repository, group='aVIRec'
	endparams

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	external function
		f_alpha11_date,         a

	record
		lHoldViinvo,	a6
		lHoldViidat,	d8
		lFileError,	int
		lMessage,	a200
		.include 'vqrec' repository, group='lVQRec'
		.include 'hwrec' repository, group='lHWRec'
	endrecord

.proc
	begin
		lHoldViinvo=aVIRec.viinvo
		lHoldViidat=aVIRec.viidat

		; finds the top sequence record and hopefully with it a stock number
		; we can use to look at the HW file with
		lFileError=%xf_file(pass_chn_data.chn(VQ_FILE), lVQRec, aVIRec.vijob, 'FI')
		repeat
		begin
			if %xf_file(pass_chn_data.chn(VQ_FILE), lVQRec,, 'RS',,,Q_NO_LOCK)
				exitloop
			if(lVQRec.vq_job != aVIRec.vijob) exitloop
			if(lVQRec.vq_type != D_VJ_WGD) nextloop
			exitloop
		end

		if(lVQRec.vq_type != D_VJ_WGD || lVQRec.vq_job != aVIRec.vijob) exit

		; have a wholegood to use as basis for washout read.
		; for each sale type washout record for the wholegood, read
		; the vi record to check the original inv no and date. Display
		; a message if it is and quit.  otherwise, read next until end of wgd
		lFileError=%xf_file(pass_chn_data.chn(HW_FILE), lHWRec, lVQRec.vq_stok, 'FI')
		repeat
		begin
			if(%xf_file(pass_chn_data.chn(HW_FILE), lHWRec,, 'RS',,,Q_NO_LOCK))
				exitloop
			if(lHWRec.hwstk1 != lVQRec.vq_stok) exitloop
			if(lHWRec.hwttyp != HW_SALE) nextloop

			; not interested in the current advice
			if(lHWRec.hwjob == aJobNo) nextloop

			if(lHWRec.hwjob != aVIRec.vijob)
			begin
				if(%xf_file(pass_chn_data.chn(VI_FILE),aVIRec,lHWRec.hwjob,'RD',,,Q_NO_LOCK))
					nextloop

				if(! aVIRec.vi_orig_invo || ! aVIRec.vi_orig_idat ) nextloop

				;WARNING - Advice:xxxxxx auto generated from Advice:xxxxxx Invoice:xxxxxx Date:dd/mm/yyyy',
				if(aVIRec.vi_orig_invo == lHoldViinvo && aVIRec.vi_orig_idat == lHoldViidat)
				begin
					xcall s_bld(lMessage,,'WARNING - Advice:%a auto generated from Advice:%a. Invoice No:%a %a',
					&   aVIRec.vijob, aJobNo, aVIRec.viinvo, %f_alpha11_date(aVIRec.viidat))
					xcall ibc_message(%atrim(lMessage))
					exitloop
				end
			end
		end
		; restore current advice
		lFileError = %xf_file(pass_chn_data.chn(VI_FILE),aVIRec,aJobNo,'RD')
	end
	xreturn
.end
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;       check to see if wholegood is ok to select as self bill
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
function WHGINE_Check_Trade_In_Ok, ^val
	req in aTxType,	n
	.include 'vmrec' repository, req in group='aVMRec'
	.include 'virec' repository, req in group='aVIRec'
	endparams

	.include 'SRC:CMSCOM.REC'
	.include 'SRC:CM3REC.REC'

	global data section whgine_chn_data
	record
		pass_chn_data,  whgine_pass_chn_data_str
	endglobal

	record
		lInvalid,	int
		lFileError,	int
		.include 'vdrec' repository, group='lVDRec'
		.include 'ivtrec' repository, group='lIVTRec'
	endrecord

proc
	lInvalid = true
	validation_error, 	begin
		if (%check_vm_depot)
			exit validation_error
		if (aVMRec.vm_sb_adv)
		begin
			xcall ibc_message('Invalid - Trade-In {WHOLEGD} ' + aVMRec.vmstok
			&        + ' has already been selected for Invoicing. See advice no ' + aVMRec.vm_sb_advno)
			exit validation_error
		end

		if (aVMRec.vm_sb_adv)
		begin
			xcall ibc_message('Invalid - Trade-In {WHOLEGD} ' + aVMRec.vmstok
			&      	+ ' has already been selected for Invoicing. See advice no ' + aVMRec.vm_sb_advno)
			exit validation_error
		end

		if (aVMRec.vmpsys != 'C')
		begin
			xcall ibc_message('Invalid - Trade-in Stock no. ' + aVMRec.vmstok + ' is not customer supplied.')
			exit validation_error
		end

		if ((! aTxType && aVMRec.vmass == D_WG_IN_STOCK) ||
		&     (aTxType && aVMRec.vmass != D_WG_IN_STOCK))
		begin
			xcall ibc_message('Invalid - Trade-in Stock no. ' + aVMRec.vmstok + ' is not the correct status.')
			exit validation_error
		end

		if (aVMRec.vmstat)
		begin
			lFileError = %xf_file(g_com_chn, cm3rec, 3, 'RN',,,Q_NO_LOCK)
			if (aVMRec.vmstat == cm3rec.cm3_on_plant)
			begin
				xcall ibc_message('Invalid - Trade-In {WHOLEGD} ' + aVMRec.vmstok
				&        +' has been transferred to Plant. You will need to transfer this back to {WHOLEGD}s'
				&		 +' to enable auto credit option.')
				exit validation_error
			end
		end

		if (aVMRec.vmsold && aVMRec.vm_qualifying != true && aVMRec.vmityp &&
		&	(cms_country == EIRE_VAT || cms_country == UK_VAT))
		begin
			if (! %xf_file(pass_chn_data.chn(IVT_FILE), lIVTRec, aVMRec.vmityp, 'RD',,, Q_NO_LOCK))
			begin
				if (lIVTRec.ivt_prog_code == P_COD_CAR_SAL || lIVTRec.ivt_prog_code == P_U_CAR_SAL_TRD )
				begin
					xcall ibc_message('Invalid - Trade-in Stock no. ' + aVMRec.vmstok + ' has been sold on VAT Margin Scheme basis.'
					& + ' You must credit this before attempting to credit the trade in.')
					exit validation_error
				end
			end
		end

		; if credit and self billers not in use, check the wg to make sure no
		; cost postings made.
		if (! cms_wg_sb_in_use && aTxType && vi_not_sb == D_VI_NOT_SB_PUR_INV)
		begin
			if (aVMRec.vm_fin_inv)
			begin
				xcall file(pass_chn_data.chn(VD_FILE), lVDRec, aVMRec.vmstok, 'FI', lFileError, 1)
				repeat
				begin
					xcall file(pass_chn_data.chn(VD_FILE), lVDRec,, 'RS', lFileError,,,,, D_NO_LOCK)
					if (lFileError || lVDRec.vdstok != aVMRec.vmstok)
					begin
						lInvalid = false
						exitloop
					end
					if (! lVDRec.vd_fin_inv)
						exitloop
				end
			end
			if(lInvalid)
				xcall ibc_message('Invalid - cost postings must be reversed first')
		end
		else
			lInvalid = false
	end
	freturn lInvalid
endfunction
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;	Adds tracking record if stop flag set or credit limit password has
	; 	been added
subroutine WHGINE_Trk_Stop_Flag
	.include 'cmfrec' repository, group = 'aCMFRec'
	aAdviceNo,	a
	endparams

	.include 'SRC:OPSCOM.REC'
	.include 'SRC:TRKREC.REC'

	record lGeneral
		lFileError,	d3
		lFileName,	a14
		lTrkOpen,	d1
		lTrkChn,	i4
	endrecord

proc
	clear lGeneral
	lFileName = trkfile
	lFileName(8:3) = cn, 'XXX'
	xcall u_fndfil(lFileName, 'U:I', lTrkChn)
	if (! lTrkChn)
	begin
		xcall u_open(lTrkChn, 'U:I', lFilename,,, lFileError)
		lTrkOpen = D_TRUE
	end

	clear trkrec
	trkrec.trk_type = 1
	trkrec.trk_code = aCMFRec.cmf_acc_no
	trkrec.trk_date = %ndate
	xcall time(trkrec.trk_time)
	trkrec.trk_operator = user_init

	if (aCMFRec.cmf_stop == 2)
		xcall s_bld(trk_text,, '{W} Stop Flag Override - Advice No. %6a', aAdviceNo)
	else
		xcall s_bld (trk_text,,'{W} Cr Limit Password Entered - Advice No. %6a', aAdviceNo)
	xcall file(lTrkChn, trkrec, trkrec.trk_key, 'ST', lFileError)

	if (lTrkOpen)
		xcall u_close(lTrkChn)

	xreturn
endsubroutine

; set fields in vjrec from fields in whgine_vj.
subroutine WHGINE_set_vj_fields

	.include 'vjrec' repository, req inout group = 'aVJRec'
	.include 'whgine_vj' repository, req in group = 'aWhgineVJ'
	req in aTransferRRP,	n
endparams

record lLocalVars
	lSpecCount,		int
endrecord

proc
	vjtstk = vj_tstk
	vjtype = vj_type

	if (vj_used)
		vjused = 'U'
	else
		vjused = 'N'

	vjcode = vj_code
	vjnmod = vj_model
	vjngrp = vj_grp
	vjnmak = vj_mak
	if( vjnstk < D_VJ_PART)
		for lSpecCount from 1 thru 10
			vjnspc[lSpecCount] = vj_spec[lSpecCount]
	vjnser = vj_ser
	vjnreg = vj_reg
	vj_dreg = vj_reg_date
	vjnclk = vj_clok
	vj_hide = vj_hide_ln
	vj_hide_attach = vj_hide_att
	vjnvat = vj_vat
	vjcost = vj_fc_cost
	vj_f_rrp = aTransferRRP
	vj_f_vi_rrp = vj_fc_vi_rrp
	vj_f_sett = vj_fc_sett
	vj_f_disc = vj_fc_disc
	vj_f_vi_disc=vj_fc_vi_disc
	if(.not.vj_f_disc)
		clear vj_f_vi_disc
	vjsold = 1
	vj_qual = vj_qualify
	vj_kit_status = vj_kit_part

	xreturn

endsubroutine

function WHGINE_prnt_custom_form, ^val

	.include 'gold_com' repository, req in group = 'aGoldCom'
	.include 'gold_ax' repository, req in group = 'aGoldAX'
	.include 'virec' repository, req in group = 'aViRec'
endparams

.include 'SRC:OPSCOM.REC'

external function
	f_get_custom,		a
	f_yes_no,			d
endexternal

record lLocalVars
	.include 'doc_print' repository, group = 'doc_print'
	.include 'SRC:VEHMSG.REC'
	lReturnVal,			int
	lDesignForm,		a25
endrecord

proc
	init lLocalVars

	lDesignForm = %f_get_custom(aGoldCom, aGoldAx, 'WGD', true)
	if (lDesignForm)
	begin
		data lPrintSelfBill,	int

		lPrintSelfBill = %f_yes_no('Print for Trade Ins ? ')

		doc_print.dpr_form_type = DOC_FORM_CUSTOM_FORM
		doc_print.dpr_form_subtype = '{W}'
		doc_print.dpr_depot = vi_depot
		doc_print.dpr_inv_type = vi_ityp
		doc_print.dpr_doc_lic = DOC_TYP_WHOLEGOOD
		doc_print.dpr_txt_type = ITX_FILE_WHG
		doc_print.dpr_80col = D_80COL
		doc_print.dpr_invoices = D_INVOICE
		doc_print.dpr_reprint = D_REPRINT
		doc_print.dpr_single = D_YES
		doc_print.dpr_design_form = lDesignForm

		snd_job_no = vijob
		snd_stat = vistat
		snd_prog = 'WHGINE'

		xcall whgprt(sndmsg, doc_print, ! lPrintSelfBill)

		lReturnVal = D_NO_ERROR
	end
	else
		lReturnVal = D_USER_ABORT

	freturn lReturnVal
endfunction


; Reset invoice flag for deleted items when cancelling update

subroutine WHGINE_reset_inv_flag

	.include 'whgine_passed' repository, group = 'aWhginePassed'
	.include 'whgine_hdr' repository, group = 'aWhgineHdr'
endparams

.include 'SRC:OPSCOM.REC'
.include 'SRC:VMCOM.REC'

global data section whgine_gen_data
record
	pass_gen_data,whgine_pass_gen_data_str
endglobal

global data section whgine_chn_data
record
	pass_chn_data,whgine_pass_chn_data_str
endglobal

record lLocalVars
	.include 'whgine_lst' repository, group='lWhgineList'
	lRequest,		int
	lListError,		int
	lFileError,		int
	lVmChannel,		int
endrecord

proc
	init lLocalVars

	lRequest = D_LL_FIRST
	xcall ll_process(pass_chn_data.lst_cntrl, lRequest, lWhgineList, lListError)
	while (! lListError)
	begin
		if (lst_vm_exists && lst_ntype == D_VJ_WGD)
		begin
			lVmChannel = pass_chn_data.chn(VM_FILE)
			xcall file(lVmChannel, vmrec, lst_tstk, 'RE', lFileError)
			if (lFileError)
			begin
				lVmChannel = pass_chn_data.chn(HM_FILE)
				xcall file(lVmChannel, vmrec, lst_tstk, 'RE', lFileError)
				if (lFileError)
					clear vmrec
			end
			if (! lFileError)
			begin
				vmrec.vminvf = true
				vmrec.vmcust = vi_cusacc
				vmrec.vmadno = vi_job
				xcall file(lVmChannel ,vmrec, , 'WR', lFileError)
			end
		end
		lRequest = D_LL_NEXT
		xcall ll_process( pass_chn_data.lst_cntrl, lRequest, lWhgineList, lListError )
	end
	xreturn
endsubroutine

; Is main cost set for VAT margin scheme

function whgine_main_cost_set, ^val
	.include 'gold_com'	repository, req in group = 'aGoldCom'
	.include 'vmrec' repository, req in group = 'aVmRec'
endparams

.include 'SRC:OPSCOM.REC'
.include 'SRC:HWREC.REC'

record lLocalVars
	lMainCostSet,	int
	lFileName,		a D_FILENAME_LEN
	lFileError,		int
	lHwChn,			int
endrecord

proc
	init lLocalVars

	lFileName = hwfile
	lFileName(7:3) = aGoldCom.cur_company, 'XXX'
	xcall u_open(lHwChn, 'I:I', lFileName, , , lFileError)
	if (! lFileError)
	begin
		lFileError = %xf_file(lHwChn, hwrec, vmstok, 'FI')
		repeat
		begin
			lFileError = %xf_file(lHwChn, hwrec, vmstok, 'RS')
			if (lFileError == $ERR_EOF || hwstk1 != vmstok )
				exitloop

			if (hwttyp != HW_INV_CRN)
				nextloop

			if (hw_main_cost)
			begin
				lMainCostSet = true
				exitloop
			end

		end
		xcall u_close(lHwChn)
	end

	freturn lMainCostSet
endfunction

; Check vat margin cost set

function WHGINE_chk_main_cost, ^val

	.include 'gold_com'	repository, req in group = 'aGoldCom'
	req in	aJobNo,			a
	.include 'whgine_passed' repository, req in group = 'aWhginePassed'
	in aPreventContinue,	n
endparams

.include 'SRC:OPSCOM.REC'
.include 'SRC:VIREC.REC'
.include 'SRC:VMCOM.REC'

external function
	f_no_yes,		d
endexternal

global data section whgine_chn_data
record
	pass_chn_data,  whgine_pass_chn_data_str
endglobal

record lLocalVars
	lFileError,		int
	lReject,		int
	lVmExists,		a1
	lVmRfa,			D_RFA_TYPE
endrecord

proc
	init lLocalVars

	xcall file(pass_chn_data.chn(VJ_FILE), vjrec, aJobNo, 'FI', lFileError)
	repeat
	begin
		xcall file(pass_chn_data.chn(VJ_FILE), vjrec, , 'RS', lFileError, , , , , D_NO_LOCK)
		if (lFileError || vjjob != aJobNo)
		begin
			exitloop
		end

		if (vjnstk == D_VJ_WGD)
		begin
			pass_chn_data.h_stok = vjtstk
			xcall check_vm_exists(aWhginePassed, lVmExists, lVmRfa)
			if (lVmExists)
			begin
				if (vmpsys == 'S' && ! vm_qualifying && ! %whgine_main_cost_set(aGoldCom, vmrec))
				begin
					if (^passed(aPreventContinue) && aPreventContinue)
					begin
						xcall ibc_message('Unable to Invoice - ' + %atrim(vjtstk) + ' does not have Main Cost set')
						lReject = true
					end
					else
					begin
						if (%f_no_yes(%atrim(vjtstk) + ' does not have Main Cost set - Continue ?' ) != D_YES)
						begin
							lReject = true
						end
					end
				end
			end
		end
	end

	freturn lReject
endfunction


; Warn if finance scheme exists for Wholegood

subroutine WHGINE_WarnFinanceScheme
	.include 'vmrec' repository, req in group = 'aVmRec'
endparams

.include 'SRC:OPSCOM.REC'

record lLocalVars
	lLomDesc,		a30
	lError,			int
endrecord

proc
	init lLocalVars

	if (aVmRec.vm_lombard)
	begin
		xcall LOM_DRILL_FileRead(aVmRec.vm_lombard, lLomDesc, lError)
		xcall ibc_message('Warning - ' + aVmRec.vmstok + ' has a Finance Scheme Code set to ' + aVmRec.vm_lombard + ': ' + lLomDesc)
	end
	
	xreturn
endsubroutine
